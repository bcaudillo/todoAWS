{"ast":null,"code":"import { __authMode, __authToken, __headers } from '../types/index.mjs';\nimport { resolveOwnerFields } from '../utils/resolveOwnerFields.mjs';\nconst connectionType = {\n  HAS_ONE: 'HAS_ONE',\n  HAS_MANY: 'HAS_MANY',\n  BELONGS_TO: 'BELONGS_TO'\n};\n/**\n *\n * @param GraphQL response object\n * @returns response object with `items` properties flattened\n */\nconst flattenItems = obj => {\n  const res = {};\n  Object.entries(obj).forEach(_ref => {\n    let [prop, value] = _ref;\n    if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n      if (value.items !== undefined) {\n        res[prop] = value.items.map(item => flattenItems(item));\n        return;\n      }\n      res[prop] = flattenItems(value);\n      return;\n    }\n    res[prop] = value;\n  });\n  return res;\n};\n// TODO: this should accept single result to support CRUD methods; create helper for array/list\nfunction initializeModel(client, modelName, result, modelIntrospection, authMode, authToken) {\n  let context = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  const introModel = modelIntrospection.models[modelName];\n  const introModelFields = introModel.fields;\n  const modelFields = Object.entries(introModelFields).filter(_ref2 => {\n    var _field$type;\n    let [_, field] = _ref2;\n    return (field === null || field === void 0 || (_field$type = field.type) === null || _field$type === void 0 ? void 0 : _field$type.model) !== undefined;\n  }).map(_ref3 => {\n    let [fieldName] = _ref3;\n    return fieldName;\n  });\n  return result.map(record => {\n    const initializedRelationalFields = {};\n    for (const fieldName of modelFields) {\n      var _modelField$associati;\n      const modelField = introModelFields[fieldName];\n      const modelFieldType = modelField === null || modelField === void 0 ? void 0 : modelField.type;\n      const relatedModelName = modelFieldType.model;\n      const relatedModel = modelIntrospection.models[relatedModelName];\n      const relatedModelPKFieldName = relatedModel.primaryKeyInfo.primaryKeyFieldName;\n      const relatedModelSKFieldNames = relatedModel.primaryKeyInfo.sortKeyFieldNames;\n      const relationType = (_modelField$associati = modelField.association) === null || _modelField$associati === void 0 ? void 0 : _modelField$associati.connectionType;\n      let connectionFields = [];\n      if (modelField.association && 'associatedWith' in modelField.association) {\n        connectionFields = modelField.association.associatedWith;\n      }\n      const targetNames = [];\n      if (modelField.association && 'targetNames' in modelField.association) {\n        targetNames.push(...modelField.association.targetNames);\n      }\n      switch (relationType) {\n        case connectionType.HAS_ONE:\n        case connectionType.BELONGS_TO:\n          {\n            const sortKeyValues = relatedModelSKFieldNames.reduce(\n            // TODO(Eslint): is this implementation correct?\n            // eslint-disable-next-line array-callback-return\n            (acc, curVal) => {\n              if (record[curVal]) {\n                return acc[curVal] = record[curVal];\n              }\n            }, {});\n            if (context) {\n              initializedRelationalFields[fieldName] = (contextSpec, options) => {\n                if (record[targetNames[0]]) {\n                  return client.models[relatedModelName].get(contextSpec, {\n                    [relatedModelPKFieldName]: record[targetNames[0]],\n                    ...sortKeyValues\n                  }, {\n                    authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                    authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                  });\n                }\n                return undefined;\n              };\n            } else {\n              initializedRelationalFields[fieldName] = options => {\n                if (record[targetNames[0]]) {\n                  return client.models[relatedModelName].get({\n                    [relatedModelPKFieldName]: record[targetNames[0]],\n                    ...sortKeyValues\n                  }, {\n                    authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                    authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                  });\n                }\n                return undefined;\n              };\n            }\n            break;\n          }\n        case connectionType.HAS_MANY:\n          {\n            const parentPk = introModel.primaryKeyInfo.primaryKeyFieldName;\n            const parentSK = introModel.primaryKeyInfo.sortKeyFieldNames;\n            // M:N check - TODO: refactor\n            const relatedModelField = relatedModel.fields[connectionFields[0]];\n            const relatedModelFieldType = relatedModelField.type;\n            if (relatedModelFieldType.model) {\n              let relatedTargetNames = [];\n              if (relatedModelField.association && 'targetNames' in relatedModelField.association) {\n                var _relatedModelField$as;\n                relatedTargetNames = (_relatedModelField$as = relatedModelField.association) === null || _relatedModelField$as === void 0 ? void 0 : _relatedModelField$as.targetNames;\n              }\n              const hasManyFilter = relatedTargetNames.map((field, idx) => {\n                if (idx === 0) {\n                  return {\n                    [field]: {\n                      eq: record[parentPk]\n                    }\n                  };\n                }\n                return {\n                  [field]: {\n                    eq: record[parentSK[idx - 1]]\n                  }\n                };\n              });\n              if (context) {\n                initializedRelationalFields[fieldName] = (contextSpec, options) => {\n                  if (record[parentPk]) {\n                    return client.models[relatedModelName].list(contextSpec, {\n                      filter: {\n                        and: hasManyFilter\n                      },\n                      limit: options === null || options === void 0 ? void 0 : options.limit,\n                      nextToken: options === null || options === void 0 ? void 0 : options.nextToken,\n                      authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                      authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                    });\n                  }\n                  return [];\n                };\n              } else {\n                initializedRelationalFields[fieldName] = options => {\n                  if (record[parentPk]) {\n                    return client.models[relatedModelName].list({\n                      filter: {\n                        and: hasManyFilter\n                      },\n                      limit: options === null || options === void 0 ? void 0 : options.limit,\n                      nextToken: options === null || options === void 0 ? void 0 : options.nextToken,\n                      authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                      authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                    });\n                  }\n                  return [];\n                };\n              }\n              break;\n            }\n            const hasManyFilter = connectionFields.map((field, idx) => {\n              if (idx === 0) {\n                return {\n                  [field]: {\n                    eq: record[parentPk]\n                  }\n                };\n              }\n              return {\n                [field]: {\n                  eq: record[parentSK[idx - 1]]\n                }\n              };\n            });\n            if (context) {\n              initializedRelationalFields[fieldName] = (contextSpec, options) => {\n                if (record[parentPk]) {\n                  return client.models[relatedModelName].list(contextSpec, {\n                    filter: {\n                      and: hasManyFilter\n                    },\n                    limit: options === null || options === void 0 ? void 0 : options.limit,\n                    nextToken: options === null || options === void 0 ? void 0 : options.nextToken,\n                    authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                    authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                  });\n                }\n                return [];\n              };\n            } else {\n              initializedRelationalFields[fieldName] = options => {\n                if (record[parentPk]) {\n                  return client.models[relatedModelName].list({\n                    filter: {\n                      and: hasManyFilter\n                    },\n                    limit: options === null || options === void 0 ? void 0 : options.limit,\n                    nextToken: options === null || options === void 0 ? void 0 : options.nextToken,\n                    authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                    authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                  });\n                }\n                return [];\n              };\n            }\n            break;\n          }\n      }\n    }\n    return {\n      ...record,\n      ...initializedRelationalFields\n    };\n  });\n}\nconst graphQLOperationsInfo = {\n  CREATE: {\n    operationPrefix: 'create',\n    usePlural: false\n  },\n  READ: {\n    operationPrefix: 'get',\n    usePlural: false\n  },\n  UPDATE: {\n    operationPrefix: 'update',\n    usePlural: false\n  },\n  DELETE: {\n    operationPrefix: 'delete',\n    usePlural: false\n  },\n  LIST: {\n    operationPrefix: 'list',\n    usePlural: true\n  },\n  INDEX_QUERY: {\n    operationPrefix: '',\n    usePlural: false\n  },\n  ONCREATE: {\n    operationPrefix: 'onCreate',\n    usePlural: false\n  },\n  ONUPDATE: {\n    operationPrefix: 'onUpdate',\n    usePlural: false\n  },\n  ONDELETE: {\n    operationPrefix: 'onDelete',\n    usePlural: false\n  },\n  OBSERVE_QUERY: {\n    operationPrefix: 'observeQuery',\n    usePlural: false\n  }\n};\nconst SELECTION_SET_WILDCARD = '*';\nfunction defaultSelectionSetForNonModelWithIR(nonModelDefinition, modelIntrospection) {\n  const {\n    fields\n  } = nonModelDefinition;\n  const mappedFields = Object.values(fields).map(_ref4 => {\n    let {\n      type,\n      name\n    } = _ref4;\n    if (typeof type.enum === 'string') {\n      return [name, FIELD_IR];\n    }\n    if (typeof type.nonModel === 'string') {\n      return [name, defaultSelectionSetForNonModelWithIR(modelIntrospection.nonModels[type.nonModel], modelIntrospection)];\n    }\n    if (typeof type === 'string') {\n      return [name, FIELD_IR];\n    }\n    return undefined;\n  }).filter(pair => pair !== undefined);\n  return Object.fromEntries(mappedFields);\n}\nfunction defaultSelectionSetForModel(modelDefinition) {\n  // fields that are explicitly part of the graphql schema; not\n  // inferred from owner auth rules.\n  const {\n    fields\n  } = modelDefinition;\n  const explicitFields = Object.values(fields)\n  // Default selection set omits model fields\n  .map(_ref5 => {\n    let {\n      type,\n      name\n    } = _ref5;\n    if (typeof type === 'string') return name;\n    if (typeof type === 'object') {\n      if (typeof (type === null || type === void 0 ? void 0 : type.enum) === 'string') {\n        return name;\n      } else if (typeof (type === null || type === void 0 ? void 0 : type.nonModel) === 'string') {\n        return \"\".concat(name, \".\").concat(SELECTION_SET_WILDCARD);\n      }\n    }\n    return undefined;\n  }).filter(Boolean);\n  // fields used for owner auth rules that may or may not also\n  // be explicit on the model.\n  const ownerFields = resolveOwnerFields(modelDefinition);\n  return Array.from(new Set(explicitFields.concat(ownerFields)));\n}\nconst FIELD_IR = '';\n/**\n * Generates nested Custom Selection Set IR from path\n *\n * @param modelDefinitions\n * @param modelName\n * @param selectionSet - array of object paths\n * @example\n * ### Given\n * `selectionSet = ['id', 'comments.post.id']`\n * ### Returns\n * ```ts\n * {\n *   id: '',\n *   comments: {\n *     items: { post: { id: '' } }\n *   }\n * }\n * ```\n */\nfunction customSelectionSetToIR(modelIntrospection, modelName, selectionSet) {\n  const dotNotationToObject = (path, modelOrNonModelName) => {\n    var _modelIntrospection$m, _modelOrNonModelField, _modelOrNonModelField2;\n    const [fieldName, ...rest] = path.split('.');\n    const nested = rest[0];\n    const modelOrNonModelDefinition = (_modelIntrospection$m = modelIntrospection.models[modelOrNonModelName]) !== null && _modelIntrospection$m !== void 0 ? _modelIntrospection$m : modelIntrospection.nonModels[modelOrNonModelName];\n    const modelOrNonModelFields = modelOrNonModelDefinition === null || modelOrNonModelDefinition === void 0 ? void 0 : modelOrNonModelDefinition.fields;\n    const relatedModel = modelOrNonModelFields === null || modelOrNonModelFields === void 0 || (_modelOrNonModelField = modelOrNonModelFields[fieldName]) === null || _modelOrNonModelField === void 0 || (_modelOrNonModelField = _modelOrNonModelField.type) === null || _modelOrNonModelField === void 0 ? void 0 : _modelOrNonModelField.model;\n    const relatedModelDefinition = modelIntrospection.models[relatedModel];\n    const relatedNonModel = modelOrNonModelFields === null || modelOrNonModelFields === void 0 || (_modelOrNonModelField2 = modelOrNonModelFields[fieldName]) === null || _modelOrNonModelField2 === void 0 || (_modelOrNonModelField2 = _modelOrNonModelField2.type) === null || _modelOrNonModelField2 === void 0 ? void 0 : _modelOrNonModelField2.nonModel;\n    const relatedNonModelDefinition = modelIntrospection.nonModels[relatedNonModel];\n    const isModelOrNonModelOrFieldType = relatedModelDefinition ? 'model' : relatedNonModelDefinition ? 'nonModel' : 'field';\n    if (isModelOrNonModelOrFieldType === 'nonModel') {\n      let result = {};\n      if (!nested) {\n        throw Error(\"\".concat(fieldName, \" must declare a wildcard (*) or a field of custom type \").concat(relatedNonModel));\n      }\n      if (nested === SELECTION_SET_WILDCARD) {\n        result = {\n          [fieldName]: defaultSelectionSetForNonModelWithIR(relatedNonModelDefinition, modelIntrospection)\n        };\n      } else {\n        result = {\n          [fieldName]: dotNotationToObject(rest.join('.'), relatedNonModel)\n        };\n      }\n      return result;\n    } else if (isModelOrNonModelOrFieldType === 'model') {\n      var _modelOrNonModelField3;\n      let result = {};\n      if (!nested) {\n        throw Error(\"\".concat(fieldName, \" must declare a wildcard (*) or a field of model \").concat(relatedModel));\n      }\n      if (nested === SELECTION_SET_WILDCARD) {\n        const nestedRelatedModelDefinition = modelIntrospection.models[relatedModel];\n        result = {\n          [fieldName]: modelsDefaultSelectionSetIR(nestedRelatedModelDefinition)\n        };\n      } else {\n        result = {\n          [fieldName]: dotNotationToObject(rest.join('.'), relatedModel)\n        };\n      }\n      if ((_modelOrNonModelField3 = modelOrNonModelFields[fieldName]) !== null && _modelOrNonModelField3 !== void 0 && _modelOrNonModelField3.isArray) {\n        result = {\n          [fieldName]: {\n            items: result[fieldName]\n          }\n        };\n      }\n      return result;\n    } else {\n      var _nonModelDefinition$f;\n      const modelField = modelOrNonModelFields === null || modelOrNonModelFields === void 0 ? void 0 : modelOrNonModelFields[fieldName];\n      const nonModelDefinition = modelIntrospection.nonModels[modelOrNonModelName];\n      const nonModelField = nonModelDefinition === null || nonModelDefinition === void 0 || (_nonModelDefinition$f = nonModelDefinition.fields) === null || _nonModelDefinition$f === void 0 ? void 0 : _nonModelDefinition$f[fieldName];\n      if (!nonModelDefinition) {\n        const isOwnerField = resolveOwnerFields(modelOrNonModelDefinition).includes(fieldName);\n        if (!modelField && !isOwnerField) {\n          throw Error(\"\".concat(fieldName, \" is not a field of model \").concat(modelOrNonModelName));\n        }\n      } else {\n        if (!nonModelField) {\n          throw Error(\"\".concat(fieldName, \" is not a field of custom type \").concat(modelOrNonModelName));\n        }\n      }\n      return {\n        [fieldName]: FIELD_IR\n      };\n    }\n  };\n  return selectionSet.reduce((resultObj, path) => deepMergeSelectionSetObjects(dotNotationToObject(path, modelName), resultObj), {});\n}\nconst modelsDefaultSelectionSetIR = relatedModelDefinition => {\n  const defaultSelectionSet = defaultSelectionSetForModel(relatedModelDefinition);\n  const reduced = defaultSelectionSet.reduce((acc, curVal) => {\n    acc[curVal] = FIELD_IR;\n    return acc;\n  }, {});\n  return reduced;\n};\n/**\n * Stringifies selection set IR\n * * @example\n * ### Given\n * ```ts\n * {\n *   id: '',\n *   comments: {\n *     items: { post: { id: '' } }\n *   }\n * }\n * ```\n * ### Returns\n * `'id comments { items { post { id } } }'`\n */\nfunction selectionSetIRToString(obj) {\n  const res = [];\n  Object.entries(obj).forEach(_ref6 => {\n    let [fieldName, value] = _ref6;\n    if (value === FIELD_IR) {\n      res.push(fieldName);\n    } else if (typeof value === 'object' && value !== null) {\n      if (value !== null && value !== void 0 && value.items) {\n        res.push(fieldName, '{', 'items', '{', selectionSetIRToString(value.items), '}', '}');\n      } else {\n        res.push(fieldName, '{', selectionSetIRToString(value), '}');\n      }\n    }\n  });\n  return res.join(' ');\n}\n/**\n * Recursively merges selection set objects from `source` onto `target`.\n *\n * `target` will be updated. `source` will be left alone.\n *\n * @param source The object to merge into target.\n * @param target The object to be mutated.\n */\nfunction deepMergeSelectionSetObjects(source, target) {\n  const isObject = obj => obj && typeof obj === 'object';\n  for (const key in source) {\n    // This verification avoids 'Prototype Pollution' issue\n    if (!Object.prototype.hasOwnProperty.call(source, key)) continue;\n    if (Object.prototype.hasOwnProperty.call(target, key) && isObject(target[key])) {\n      deepMergeSelectionSetObjects(source[key], target[key]);\n    } else {\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction generateSelectionSet(modelIntrospection, modelName, selectionSet) {\n  const modelDefinition = modelIntrospection.models[modelName];\n  const selSetIr = customSelectionSetToIR(modelIntrospection, modelName, selectionSet !== null && selectionSet !== void 0 ? selectionSet : defaultSelectionSetForModel(modelDefinition));\n  const selSetString = selectionSetIRToString(selSetIr);\n  return selSetString;\n}\nfunction generateGraphQLDocument(modelIntrospection, modelName, modelOperation, listArgs, indexMeta) {\n  var _graphQLArguments, _graphQLOperationType, _graphQLArguments2, _graphQLSelectionSet, _graphQLArguments3, _graphQLOperationType2, _graphQLSelectionSet2, _graphQLArguments4, _graphQLOperationType3, _graphQLSelectionSet3, _graphQLArguments5, _graphQLOperationType4, _graphQLSelectionSet4;\n  const modelDefinition = modelIntrospection.models[modelName];\n  const {\n    name,\n    pluralName,\n    fields,\n    primaryKeyInfo: {\n      isCustomPrimaryKey,\n      primaryKeyFieldName,\n      sortKeyFieldNames\n    }\n  } = modelDefinition;\n  const {\n    operationPrefix,\n    usePlural\n  } = graphQLOperationsInfo[modelOperation];\n  const {\n    selectionSet\n  } = listArgs || {};\n  let graphQLFieldName;\n  let indexQueryArgs;\n  if (operationPrefix) {\n    graphQLFieldName = \"\".concat(operationPrefix).concat(usePlural ? pluralName : name);\n  } else if (indexMeta) {\n    const {\n      queryField,\n      pk,\n      sk = []\n    } = indexMeta;\n    graphQLFieldName = queryField;\n    const skQueryArgs = sk.reduce((acc, fieldName) => {\n      const fieldType = fields[fieldName].type;\n      acc[fieldName] = \"Model\".concat(fieldType, \"KeyConditionInput\");\n      return acc;\n    }, {});\n    indexQueryArgs = {\n      [pk]: \"\".concat(fields[pk].type, \"!\"),\n      ...skQueryArgs\n    };\n  } else {\n    throw new Error('Error generating GraphQL Document - invalid operation name');\n  }\n  let graphQLOperationType;\n  let graphQLSelectionSet;\n  let graphQLArguments;\n  const selectionSetFields = generateSelectionSet(modelIntrospection, modelName, selectionSet);\n  switch (modelOperation) {\n    case 'CREATE':\n    case 'UPDATE':\n    case 'DELETE':\n      (_graphQLArguments = graphQLArguments) !== null && _graphQLArguments !== void 0 ? _graphQLArguments : graphQLArguments = {\n        input: \"\".concat(operationPrefix.charAt(0).toLocaleUpperCase() + operationPrefix.slice(1)).concat(name, \"Input!\")\n      };\n      (_graphQLOperationType = graphQLOperationType) !== null && _graphQLOperationType !== void 0 ? _graphQLOperationType : graphQLOperationType = 'mutation';\n    // TODO(Eslint): this this case clause correct without the break statement?\n    // eslint-disable-next-line no-fallthrough\n    case 'READ':\n      (_graphQLArguments2 = graphQLArguments) !== null && _graphQLArguments2 !== void 0 ? _graphQLArguments2 : graphQLArguments = isCustomPrimaryKey ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {\n        acc[fieldName] = \"\".concat(fields[fieldName].type, \"!\");\n        return acc;\n      }, {}) : {\n        [primaryKeyFieldName]: \"\".concat(fields[primaryKeyFieldName].type, \"!\")\n      };\n      (_graphQLSelectionSet = graphQLSelectionSet) !== null && _graphQLSelectionSet !== void 0 ? _graphQLSelectionSet : graphQLSelectionSet = selectionSetFields;\n    // TODO(Eslint): this this case clause correct without the break statement?\n    // eslint-disable-next-line no-fallthrough\n    case 'LIST':\n      (_graphQLArguments3 = graphQLArguments) !== null && _graphQLArguments3 !== void 0 ? _graphQLArguments3 : graphQLArguments = {\n        filter: \"Model\".concat(name, \"FilterInput\"),\n        ...(sortKeyFieldNames.length > 0 ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {\n          acc[fieldName] = \"\".concat(fields[fieldName].type);\n          return acc;\n        }, {\n          sortDirection: 'ModelSortDirection'\n        }) : []),\n        limit: 'Int',\n        nextToken: 'String'\n      };\n      (_graphQLOperationType2 = graphQLOperationType) !== null && _graphQLOperationType2 !== void 0 ? _graphQLOperationType2 : graphQLOperationType = 'query';\n      (_graphQLSelectionSet2 = graphQLSelectionSet) !== null && _graphQLSelectionSet2 !== void 0 ? _graphQLSelectionSet2 : graphQLSelectionSet = \"items { \".concat(selectionSetFields, \" } nextToken __typename\");\n    // TODO(Eslint): this this case clause correct without the break statement?\n    // eslint-disable-next-line no-fallthrough\n    case 'INDEX_QUERY':\n      (_graphQLArguments4 = graphQLArguments) !== null && _graphQLArguments4 !== void 0 ? _graphQLArguments4 : graphQLArguments = {\n        ...indexQueryArgs,\n        filter: \"Model\".concat(name, \"FilterInput\"),\n        sortDirection: 'ModelSortDirection',\n        limit: 'Int',\n        nextToken: 'String'\n      };\n      (_graphQLOperationType3 = graphQLOperationType) !== null && _graphQLOperationType3 !== void 0 ? _graphQLOperationType3 : graphQLOperationType = 'query';\n      (_graphQLSelectionSet3 = graphQLSelectionSet) !== null && _graphQLSelectionSet3 !== void 0 ? _graphQLSelectionSet3 : graphQLSelectionSet = \"items { \".concat(selectionSetFields, \" } nextToken __typename\");\n    // TODO(Eslint): this this case clause correct without the break statement?\n    // eslint-disable-next-line no-fallthrough\n    case 'ONCREATE':\n    case 'ONUPDATE':\n    case 'ONDELETE':\n      (_graphQLArguments5 = graphQLArguments) !== null && _graphQLArguments5 !== void 0 ? _graphQLArguments5 : graphQLArguments = {\n        filter: \"ModelSubscription\".concat(name, \"FilterInput\")\n      };\n      (_graphQLOperationType4 = graphQLOperationType) !== null && _graphQLOperationType4 !== void 0 ? _graphQLOperationType4 : graphQLOperationType = 'subscription';\n      (_graphQLSelectionSet4 = graphQLSelectionSet) !== null && _graphQLSelectionSet4 !== void 0 ? _graphQLSelectionSet4 : graphQLSelectionSet = selectionSetFields;\n      break;\n    case 'OBSERVE_QUERY':\n    default:\n      throw new Error('Internal error: Attempted to generate graphql document for observeQuery. Please report this error.');\n  }\n  const graphQLDocument = \"\".concat(graphQLOperationType).concat(graphQLArguments ? \"(\".concat(Object.entries(graphQLArguments).map(_ref7 => {\n    let [fieldName, type] = _ref7;\n    return \"$\".concat(fieldName, \": \").concat(type);\n  }), \")\") : '', \" { \").concat(graphQLFieldName).concat(graphQLArguments ? \"(\".concat(Object.keys(graphQLArguments).map(fieldName => \"\".concat(fieldName, \": $\").concat(fieldName)), \")\") : '', \" { \").concat(graphQLSelectionSet, \" } }\");\n  return graphQLDocument;\n}\nfunction buildGraphQLVariables(modelDefinition, operation, arg, modelIntrospection, indexMeta) {\n  const {\n    fields,\n    primaryKeyInfo: {\n      isCustomPrimaryKey,\n      primaryKeyFieldName,\n      sortKeyFieldNames\n    }\n  } = modelDefinition;\n  let variables = {};\n  // TODO: process input\n  switch (operation) {\n    case 'CREATE':\n      variables = {\n        input: arg ? normalizeMutationInput(arg, modelDefinition, modelIntrospection) : {}\n      };\n      break;\n    case 'UPDATE':\n      // readonly fields are not  updated\n      variables = {\n        input: arg ? Object.fromEntries(Object.entries(normalizeMutationInput(arg, modelDefinition, modelIntrospection)).filter(_ref8 => {\n          let [fieldName] = _ref8;\n          const {\n            isReadOnly\n          } = fields[fieldName];\n          return !isReadOnly;\n        })) : {}\n      };\n      break;\n    case 'READ':\n    case 'DELETE':\n      // only identifiers are sent\n      if (arg) {\n        variables = isCustomPrimaryKey ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {\n          acc[fieldName] = arg[fieldName];\n          return acc;\n        }, {}) : {\n          [primaryKeyFieldName]: arg[primaryKeyFieldName]\n        };\n      }\n      if (operation === 'DELETE') {\n        variables = {\n          input: variables\n        };\n      }\n      break;\n    case 'LIST':\n      if (arg !== null && arg !== void 0 && arg.filter) {\n        variables.filter = arg.filter;\n      }\n      if (arg !== null && arg !== void 0 && arg.sortDirection) {\n        variables.sortDirection = arg.sortDirection;\n        variables[primaryKeyFieldName] = arg[primaryKeyFieldName];\n      }\n      if (arg !== null && arg !== void 0 && arg.nextToken) {\n        variables.nextToken = arg.nextToken;\n      }\n      if (arg !== null && arg !== void 0 && arg.limit) {\n        variables.limit = arg.limit;\n      }\n      break;\n    case 'INDEX_QUERY':\n      {\n        const {\n          pk,\n          sk = []\n        } = indexMeta;\n        variables[pk] = arg[pk];\n        for (const skField of sk) {\n          variables[skField] = arg[skField];\n        }\n        if (arg !== null && arg !== void 0 && arg.filter) {\n          variables.filter = arg.filter;\n        }\n        if (arg !== null && arg !== void 0 && arg.sortDirection) {\n          variables.sortDirection = arg.sortDirection;\n        }\n        if (arg !== null && arg !== void 0 && arg.nextToken) {\n          variables.nextToken = arg.nextToken;\n        }\n        if (arg !== null && arg !== void 0 && arg.limit) {\n          variables.limit = arg.limit;\n        }\n        break;\n      }\n    case 'ONCREATE':\n    case 'ONUPDATE':\n    case 'ONDELETE':\n      if (arg !== null && arg !== void 0 && arg.filter) {\n        variables = {\n          filter: arg.filter\n        };\n      }\n      break;\n    case 'OBSERVE_QUERY':\n      throw new Error('Internal error: Attempted to build variables for observeQuery. Please report this error.');\n    default:\n      {\n        const exhaustiveCheck = operation;\n        throw new Error(\"Unhandled operation case: \".concat(exhaustiveCheck));\n      }\n  }\n  return variables;\n}\n/**\n * Iterates over mutation input values and resolves any model inputs to their corresponding join fields/values\n *\n * @example\n * ### Usage\n * ```ts\n * const result = normalizeMutationInput({ post: post }, model, modelDefinition);\n * ```\n * ### Result\n * ```ts\n * { postId: \"abc123\" }\n * ```\n *\n */\nfunction normalizeMutationInput(mutationInput, model, modelIntrospection) {\n  const {\n    fields\n  } = model;\n  const normalized = {};\n  Object.entries(mutationInput).forEach(_ref9 => {\n    var _fields$inputFieldNam;\n    let [inputFieldName, inputValue] = _ref9;\n    const fieldType = (_fields$inputFieldNam = fields[inputFieldName]) === null || _fields$inputFieldNam === void 0 ? void 0 : _fields$inputFieldNam.type;\n    const relatedModelName = fieldType === null || fieldType === void 0 ? void 0 : fieldType.model;\n    if (relatedModelName) {\n      var _fields$inputFieldNam2;\n      const association = (_fields$inputFieldNam2 = fields[inputFieldName]) === null || _fields$inputFieldNam2 === void 0 ? void 0 : _fields$inputFieldNam2.association;\n      const relatedModelDef = modelIntrospection.models[relatedModelName];\n      const relatedModelPkInfo = relatedModelDef.primaryKeyInfo;\n      if ((association === null || association === void 0 ? void 0 : association.connectionType) === connectionType.HAS_ONE) {\n        const associationHasOne = association;\n        associationHasOne.targetNames.forEach((targetName, idx) => {\n          const associatedFieldName = associationHasOne.associatedWith[idx];\n          normalized[targetName] = inputValue[associatedFieldName];\n        });\n      }\n      if ((association === null || association === void 0 ? void 0 : association.connectionType) === connectionType.BELONGS_TO) {\n        const associationBelongsTo = association;\n        associationBelongsTo.targetNames.forEach((targetName, idx) => {\n          if (idx === 0) {\n            const associatedFieldName = relatedModelPkInfo.primaryKeyFieldName;\n            normalized[targetName] = inputValue[associatedFieldName];\n          } else {\n            const associatedFieldName = relatedModelPkInfo.sortKeyFieldNames[idx - 1];\n            normalized[targetName] = inputValue[associatedFieldName];\n          }\n        });\n      }\n    } else {\n      normalized[inputFieldName] = inputValue;\n    }\n  });\n  return normalized;\n}\n/**\n * Produces a parameter object that can contains auth mode/token overrides\n * only if present in either `options` (first) or configured on the `client`\n * as a fallback.\n *\n * @param client Configured client from `generateClient`\n * @param options Args/Options object from call site.\n * @returns\n */\nfunction authModeParams(client) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return {\n    authMode: options.authMode || client[__authMode],\n    authToken: options.authToken || client[__authToken]\n  };\n}\n/**\n * Retrieves custom headers from either the client or request options.\n * @param client V6Client | V6ClientSSRRequest | V6ClientSSRCookies - for extracting client headers\n * @param requestHeaders {@link CustomHeaders} - request headers\n * @returns custom headers as {@link CustomHeaders}\n */\nfunction getCustomHeaders(client, requestHeaders) {\n  let headers = client[__headers] || {};\n  // Individual request headers will take precedence over client headers.\n  // We intentionally do *not* merge client and request headers.\n  if (requestHeaders) {\n    headers = requestHeaders;\n  }\n  return headers;\n}\nexport { authModeParams, buildGraphQLVariables, customSelectionSetToIR, defaultSelectionSetForNonModelWithIR, flattenItems, generateGraphQLDocument, generateSelectionSet, getCustomHeaders, graphQLOperationsInfo, initializeModel, normalizeMutationInput, selectionSetIRToString };","map":{"version":3,"names":["connectionType","HAS_ONE","HAS_MANY","BELONGS_TO","flattenItems","obj","res","Object","entries","forEach","_ref","prop","value","Array","isArray","items","undefined","map","item","initializeModel","client","modelName","result","modelIntrospection","authMode","authToken","context","arguments","length","introModel","models","introModelFields","fields","modelFields","filter","_ref2","_field$type","_","field","type","model","_ref3","fieldName","record","initializedRelationalFields","_modelField$associati","modelField","modelFieldType","relatedModelName","relatedModel","relatedModelPKFieldName","primaryKeyInfo","primaryKeyFieldName","relatedModelSKFieldNames","sortKeyFieldNames","relationType","association","connectionFields","associatedWith","targetNames","push","sortKeyValues","reduce","acc","curVal","contextSpec","options","get","parentPk","parentSK","relatedModelField","relatedModelFieldType","relatedTargetNames","_relatedModelField$as","hasManyFilter","idx","eq","list","and","limit","nextToken","graphQLOperationsInfo","CREATE","operationPrefix","usePlural","READ","UPDATE","DELETE","LIST","INDEX_QUERY","ONCREATE","ONUPDATE","ONDELETE","OBSERVE_QUERY","SELECTION_SET_WILDCARD","defaultSelectionSetForNonModelWithIR","nonModelDefinition","mappedFields","values","_ref4","name","enum","FIELD_IR","nonModel","nonModels","pair","fromEntries","defaultSelectionSetForModel","modelDefinition","explicitFields","_ref5","concat","Boolean","ownerFields","resolveOwnerFields","from","Set","customSelectionSetToIR","selectionSet","dotNotationToObject","path","modelOrNonModelName","_modelIntrospection$m","_modelOrNonModelField","_modelOrNonModelField2","rest","split","nested","modelOrNonModelDefinition","modelOrNonModelFields","relatedModelDefinition","relatedNonModel","relatedNonModelDefinition","isModelOrNonModelOrFieldType","Error","join","_modelOrNonModelField3","nestedRelatedModelDefinition","modelsDefaultSelectionSetIR","_nonModelDefinition$f","nonModelField","isOwnerField","includes","resultObj","deepMergeSelectionSetObjects","defaultSelectionSet","reduced","selectionSetIRToString","_ref6","source","target","isObject","key","prototype","hasOwnProperty","call","generateSelectionSet","selSetIr","selSetString","generateGraphQLDocument","modelOperation","listArgs","indexMeta","_graphQLArguments","_graphQLOperationType","_graphQLArguments2","_graphQLSelectionSet","_graphQLArguments3","_graphQLOperationType2","_graphQLSelectionSet2","_graphQLArguments4","_graphQLOperationType3","_graphQLSelectionSet3","_graphQLArguments5","_graphQLOperationType4","_graphQLSelectionSet4","pluralName","isCustomPrimaryKey","graphQLFieldName","indexQueryArgs","queryField","pk","sk","skQueryArgs","fieldType","graphQLOperationType","graphQLSelectionSet","graphQLArguments","selectionSetFields","input","charAt","toLocaleUpperCase","slice","sortDirection","graphQLDocument","_ref7","keys","buildGraphQLVariables","operation","arg","variables","normalizeMutationInput","_ref8","isReadOnly","skField","exhaustiveCheck","mutationInput","normalized","_ref9","_fields$inputFieldNam","inputFieldName","inputValue","_fields$inputFieldNam2","relatedModelDef","relatedModelPkInfo","associationHasOne","targetName","associatedFieldName","associationBelongsTo","authModeParams","__authMode","__authToken","getCustomHeaders","requestHeaders","headers","__headers"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@aws-amplify/api-graphql/src/internals/APIClient.ts"],"sourcesContent":["import { __authMode, __authToken, __headers, } from '../types';\nimport { resolveOwnerFields } from '../utils/resolveOwnerFields';\nconst connectionType = {\n    HAS_ONE: 'HAS_ONE',\n    HAS_MANY: 'HAS_MANY',\n    BELONGS_TO: 'BELONGS_TO',\n};\n/**\n *\n * @param GraphQL response object\n * @returns response object with `items` properties flattened\n */\nexport const flattenItems = (obj) => {\n    const res = {};\n    Object.entries(obj).forEach(([prop, value]) => {\n        if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n            if (value.items !== undefined) {\n                res[prop] = value.items.map((item) => flattenItems(item));\n                return;\n            }\n            res[prop] = flattenItems(value);\n            return;\n        }\n        res[prop] = value;\n    });\n    return res;\n};\n// TODO: this should accept single result to support CRUD methods; create helper for array/list\nexport function initializeModel(client, modelName, result, modelIntrospection, authMode, authToken, context = false) {\n    const introModel = modelIntrospection.models[modelName];\n    const introModelFields = introModel.fields;\n    const modelFields = Object.entries(introModelFields)\n        .filter(([_, field]) => field?.type?.model !== undefined)\n        .map(([fieldName]) => fieldName);\n    return result.map(record => {\n        const initializedRelationalFields = {};\n        for (const fieldName of modelFields) {\n            const modelField = introModelFields[fieldName];\n            const modelFieldType = modelField?.type;\n            const relatedModelName = modelFieldType.model;\n            const relatedModel = modelIntrospection.models[relatedModelName];\n            const relatedModelPKFieldName = relatedModel.primaryKeyInfo.primaryKeyFieldName;\n            const relatedModelSKFieldNames = relatedModel.primaryKeyInfo.sortKeyFieldNames;\n            const relationType = modelField.association?.connectionType;\n            let connectionFields = [];\n            if (modelField.association &&\n                'associatedWith' in modelField.association) {\n                connectionFields = modelField.association.associatedWith;\n            }\n            const targetNames = [];\n            if (modelField.association && 'targetNames' in modelField.association) {\n                targetNames.push(...modelField.association.targetNames);\n            }\n            switch (relationType) {\n                case connectionType.HAS_ONE:\n                case connectionType.BELONGS_TO: {\n                    const sortKeyValues = relatedModelSKFieldNames.reduce(\n                    // TODO(Eslint): is this implementation correct?\n                    // eslint-disable-next-line array-callback-return\n                    (acc, curVal) => {\n                        if (record[curVal]) {\n                            return (acc[curVal] = record[curVal]);\n                        }\n                    }, {});\n                    if (context) {\n                        initializedRelationalFields[fieldName] = (contextSpec, options) => {\n                            if (record[targetNames[0]]) {\n                                return client.models[relatedModelName].get(contextSpec, {\n                                    [relatedModelPKFieldName]: record[targetNames[0]],\n                                    ...sortKeyValues,\n                                }, {\n                                    authMode: options?.authMode || authMode,\n                                    authToken: options?.authToken || authToken,\n                                });\n                            }\n                            return undefined;\n                        };\n                    }\n                    else {\n                        initializedRelationalFields[fieldName] = (options) => {\n                            if (record[targetNames[0]]) {\n                                return client.models[relatedModelName].get({\n                                    [relatedModelPKFieldName]: record[targetNames[0]],\n                                    ...sortKeyValues,\n                                }, {\n                                    authMode: options?.authMode || authMode,\n                                    authToken: options?.authToken || authToken,\n                                });\n                            }\n                            return undefined;\n                        };\n                    }\n                    break;\n                }\n                case connectionType.HAS_MANY: {\n                    const parentPk = introModel.primaryKeyInfo.primaryKeyFieldName;\n                    const parentSK = introModel.primaryKeyInfo.sortKeyFieldNames;\n                    // M:N check - TODO: refactor\n                    const relatedModelField = relatedModel.fields[connectionFields[0]];\n                    const relatedModelFieldType = relatedModelField.type;\n                    if (relatedModelFieldType.model) {\n                        let relatedTargetNames = [];\n                        if (relatedModelField.association &&\n                            'targetNames' in relatedModelField.association) {\n                            relatedTargetNames = relatedModelField.association?.targetNames;\n                        }\n                        const hasManyFilter = relatedTargetNames.map((field, idx) => {\n                            if (idx === 0) {\n                                return { [field]: { eq: record[parentPk] } };\n                            }\n                            return { [field]: { eq: record[parentSK[idx - 1]] } };\n                        });\n                        if (context) {\n                            initializedRelationalFields[fieldName] = (contextSpec, options) => {\n                                if (record[parentPk]) {\n                                    return client.models[relatedModelName].list(contextSpec, {\n                                        filter: { and: hasManyFilter },\n                                        limit: options?.limit,\n                                        nextToken: options?.nextToken,\n                                        authMode: options?.authMode || authMode,\n                                        authToken: options?.authToken || authToken,\n                                    });\n                                }\n                                return [];\n                            };\n                        }\n                        else {\n                            initializedRelationalFields[fieldName] = (options) => {\n                                if (record[parentPk]) {\n                                    return client.models[relatedModelName].list({\n                                        filter: { and: hasManyFilter },\n                                        limit: options?.limit,\n                                        nextToken: options?.nextToken,\n                                        authMode: options?.authMode || authMode,\n                                        authToken: options?.authToken || authToken,\n                                    });\n                                }\n                                return [];\n                            };\n                        }\n                        break;\n                    }\n                    const hasManyFilter = connectionFields.map((field, idx) => {\n                        if (idx === 0) {\n                            return { [field]: { eq: record[parentPk] } };\n                        }\n                        return { [field]: { eq: record[parentSK[idx - 1]] } };\n                    });\n                    if (context) {\n                        initializedRelationalFields[fieldName] = (contextSpec, options) => {\n                            if (record[parentPk]) {\n                                return client.models[relatedModelName].list(contextSpec, {\n                                    filter: { and: hasManyFilter },\n                                    limit: options?.limit,\n                                    nextToken: options?.nextToken,\n                                    authMode: options?.authMode || authMode,\n                                    authToken: options?.authToken || authToken,\n                                });\n                            }\n                            return [];\n                        };\n                    }\n                    else {\n                        initializedRelationalFields[fieldName] = (options) => {\n                            if (record[parentPk]) {\n                                return client.models[relatedModelName].list({\n                                    filter: { and: hasManyFilter },\n                                    limit: options?.limit,\n                                    nextToken: options?.nextToken,\n                                    authMode: options?.authMode || authMode,\n                                    authToken: options?.authToken || authToken,\n                                });\n                            }\n                            return [];\n                        };\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n        return { ...record, ...initializedRelationalFields };\n    });\n}\nexport const graphQLOperationsInfo = {\n    CREATE: { operationPrefix: 'create', usePlural: false },\n    READ: { operationPrefix: 'get', usePlural: false },\n    UPDATE: { operationPrefix: 'update', usePlural: false },\n    DELETE: { operationPrefix: 'delete', usePlural: false },\n    LIST: { operationPrefix: 'list', usePlural: true },\n    INDEX_QUERY: { operationPrefix: '', usePlural: false },\n    ONCREATE: { operationPrefix: 'onCreate', usePlural: false },\n    ONUPDATE: { operationPrefix: 'onUpdate', usePlural: false },\n    ONDELETE: { operationPrefix: 'onDelete', usePlural: false },\n    OBSERVE_QUERY: { operationPrefix: 'observeQuery', usePlural: false },\n};\nconst SELECTION_SET_WILDCARD = '*';\nexport function defaultSelectionSetForNonModelWithIR(nonModelDefinition, modelIntrospection) {\n    const { fields } = nonModelDefinition;\n    const mappedFields = Object.values(fields)\n        .map(({ type, name }) => {\n        if (typeof type.enum === 'string') {\n            return [name, FIELD_IR];\n        }\n        if (typeof type.nonModel === 'string') {\n            return [\n                name,\n                defaultSelectionSetForNonModelWithIR(modelIntrospection.nonModels[type.nonModel], modelIntrospection),\n            ];\n        }\n        if (typeof type === 'string') {\n            return [name, FIELD_IR];\n        }\n        return undefined;\n    })\n        .filter((pair) => pair !== undefined);\n    return Object.fromEntries(mappedFields);\n}\nfunction defaultSelectionSetForModel(modelDefinition) {\n    // fields that are explicitly part of the graphql schema; not\n    // inferred from owner auth rules.\n    const { fields } = modelDefinition;\n    const explicitFields = Object.values(fields)\n        // Default selection set omits model fields\n        .map(({ type, name }) => {\n        if (typeof type === 'string')\n            return name;\n        if (typeof type === 'object') {\n            if (typeof type?.enum === 'string') {\n                return name;\n            }\n            else if (typeof type?.nonModel === 'string') {\n                return `${name}.${SELECTION_SET_WILDCARD}`;\n            }\n        }\n        return undefined;\n    })\n        .filter(Boolean);\n    // fields used for owner auth rules that may or may not also\n    // be explicit on the model.\n    const ownerFields = resolveOwnerFields(modelDefinition);\n    return Array.from(new Set(explicitFields.concat(ownerFields)));\n}\nconst FIELD_IR = '';\n/**\n * Generates nested Custom Selection Set IR from path\n *\n * @param modelDefinitions\n * @param modelName\n * @param selectionSet - array of object paths\n * @example\n * ### Given\n * `selectionSet = ['id', 'comments.post.id']`\n * ### Returns\n * ```ts\n * {\n *   id: '',\n *   comments: {\n *     items: { post: { id: '' } }\n *   }\n * }\n * ```\n */\nexport function customSelectionSetToIR(modelIntrospection, modelName, selectionSet) {\n    const dotNotationToObject = (path, modelOrNonModelName) => {\n        const [fieldName, ...rest] = path.split('.');\n        const nested = rest[0];\n        const modelOrNonModelDefinition = modelIntrospection.models[modelOrNonModelName] ??\n            modelIntrospection.nonModels[modelOrNonModelName];\n        const modelOrNonModelFields = modelOrNonModelDefinition?.fields;\n        const relatedModel = modelOrNonModelFields?.[fieldName]?.type?.model;\n        const relatedModelDefinition = modelIntrospection.models[relatedModel];\n        const relatedNonModel = modelOrNonModelFields?.[fieldName]?.type?.nonModel;\n        const relatedNonModelDefinition = modelIntrospection.nonModels[relatedNonModel];\n        const isModelOrNonModelOrFieldType = relatedModelDefinition\n            ? 'model'\n            : relatedNonModelDefinition\n                ? 'nonModel'\n                : 'field';\n        if (isModelOrNonModelOrFieldType === 'nonModel') {\n            let result = {};\n            if (!nested) {\n                throw Error(`${fieldName} must declare a wildcard (*) or a field of custom type ${relatedNonModel}`);\n            }\n            if (nested === SELECTION_SET_WILDCARD) {\n                result = {\n                    [fieldName]: defaultSelectionSetForNonModelWithIR(relatedNonModelDefinition, modelIntrospection),\n                };\n            }\n            else {\n                result = {\n                    [fieldName]: dotNotationToObject(rest.join('.'), relatedNonModel),\n                };\n            }\n            return result;\n        }\n        else if (isModelOrNonModelOrFieldType === 'model') {\n            let result = {};\n            if (!nested) {\n                throw Error(`${fieldName} must declare a wildcard (*) or a field of model ${relatedModel}`);\n            }\n            if (nested === SELECTION_SET_WILDCARD) {\n                const nestedRelatedModelDefinition = modelIntrospection.models[relatedModel];\n                result = {\n                    [fieldName]: modelsDefaultSelectionSetIR(nestedRelatedModelDefinition),\n                };\n            }\n            else {\n                result = {\n                    [fieldName]: dotNotationToObject(rest.join('.'), relatedModel),\n                };\n            }\n            if (modelOrNonModelFields[fieldName]?.isArray) {\n                result = {\n                    [fieldName]: {\n                        items: result[fieldName],\n                    },\n                };\n            }\n            return result;\n        }\n        else {\n            const modelField = modelOrNonModelFields?.[fieldName];\n            const nonModelDefinition = modelIntrospection.nonModels[modelOrNonModelName];\n            const nonModelField = nonModelDefinition?.fields?.[fieldName];\n            if (!nonModelDefinition) {\n                const isOwnerField = resolveOwnerFields(modelOrNonModelDefinition).includes(fieldName);\n                if (!modelField && !isOwnerField) {\n                    throw Error(`${fieldName} is not a field of model ${modelOrNonModelName}`);\n                }\n            }\n            else {\n                if (!nonModelField) {\n                    throw Error(`${fieldName} is not a field of custom type ${modelOrNonModelName}`);\n                }\n            }\n            return { [fieldName]: FIELD_IR };\n        }\n    };\n    return selectionSet.reduce((resultObj, path) => deepMergeSelectionSetObjects(dotNotationToObject(path, modelName), resultObj), {});\n}\nconst modelsDefaultSelectionSetIR = (relatedModelDefinition) => {\n    const defaultSelectionSet = defaultSelectionSetForModel(relatedModelDefinition);\n    const reduced = defaultSelectionSet.reduce((acc, curVal) => {\n        acc[curVal] = FIELD_IR;\n        return acc;\n    }, {});\n    return reduced;\n};\n/**\n * Stringifies selection set IR\n * * @example\n * ### Given\n * ```ts\n * {\n *   id: '',\n *   comments: {\n *     items: { post: { id: '' } }\n *   }\n * }\n * ```\n * ### Returns\n * `'id comments { items { post { id } } }'`\n */\nexport function selectionSetIRToString(obj) {\n    const res = [];\n    Object.entries(obj).forEach(([fieldName, value]) => {\n        if (value === FIELD_IR) {\n            res.push(fieldName);\n        }\n        else if (typeof value === 'object' && value !== null) {\n            if (value?.items) {\n                res.push(fieldName, '{', 'items', '{', selectionSetIRToString(value.items), '}', '}');\n            }\n            else {\n                res.push(fieldName, '{', selectionSetIRToString(value), '}');\n            }\n        }\n    });\n    return res.join(' ');\n}\n/**\n * Recursively merges selection set objects from `source` onto `target`.\n *\n * `target` will be updated. `source` will be left alone.\n *\n * @param source The object to merge into target.\n * @param target The object to be mutated.\n */\nfunction deepMergeSelectionSetObjects(source, target) {\n    const isObject = (obj) => obj && typeof obj === 'object';\n    for (const key in source) {\n        // This verification avoids 'Prototype Pollution' issue\n        if (!Object.prototype.hasOwnProperty.call(source, key))\n            continue;\n        if (Object.prototype.hasOwnProperty.call(target, key) &&\n            isObject(target[key])) {\n            deepMergeSelectionSetObjects(source[key], target[key]);\n        }\n        else {\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nexport function generateSelectionSet(modelIntrospection, modelName, selectionSet) {\n    const modelDefinition = modelIntrospection.models[modelName];\n    const selSetIr = customSelectionSetToIR(modelIntrospection, modelName, selectionSet ?? defaultSelectionSetForModel(modelDefinition));\n    const selSetString = selectionSetIRToString(selSetIr);\n    return selSetString;\n}\nexport function generateGraphQLDocument(modelIntrospection, modelName, modelOperation, listArgs, indexMeta) {\n    const modelDefinition = modelIntrospection.models[modelName];\n    const { name, pluralName, fields, primaryKeyInfo: { isCustomPrimaryKey, primaryKeyFieldName, sortKeyFieldNames, }, } = modelDefinition;\n    const { operationPrefix, usePlural } = graphQLOperationsInfo[modelOperation];\n    const { selectionSet } = listArgs || {};\n    let graphQLFieldName;\n    let indexQueryArgs;\n    if (operationPrefix) {\n        graphQLFieldName = `${operationPrefix}${usePlural ? pluralName : name}`;\n    }\n    else if (indexMeta) {\n        const { queryField, pk, sk = [] } = indexMeta;\n        graphQLFieldName = queryField;\n        const skQueryArgs = sk.reduce((acc, fieldName) => {\n            const fieldType = fields[fieldName].type;\n            acc[fieldName] = `Model${fieldType}KeyConditionInput`;\n            return acc;\n        }, {});\n        indexQueryArgs = {\n            [pk]: `${fields[pk].type}!`,\n            ...skQueryArgs,\n        };\n    }\n    else {\n        throw new Error('Error generating GraphQL Document - invalid operation name');\n    }\n    let graphQLOperationType;\n    let graphQLSelectionSet;\n    let graphQLArguments;\n    const selectionSetFields = generateSelectionSet(modelIntrospection, modelName, selectionSet);\n    switch (modelOperation) {\n        case 'CREATE':\n        case 'UPDATE':\n        case 'DELETE':\n            graphQLArguments ??\n                (graphQLArguments = {\n                    input: `${operationPrefix.charAt(0).toLocaleUpperCase() +\n                        operationPrefix.slice(1)}${name}Input!`,\n                });\n            graphQLOperationType ?? (graphQLOperationType = 'mutation');\n        // TODO(Eslint): this this case clause correct without the break statement?\n        // eslint-disable-next-line no-fallthrough\n        case 'READ':\n            graphQLArguments ??\n                (graphQLArguments = isCustomPrimaryKey\n                    ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {\n                        acc[fieldName] = `${fields[fieldName].type}!`;\n                        return acc;\n                    }, {})\n                    : {\n                        [primaryKeyFieldName]: `${fields[primaryKeyFieldName].type}!`,\n                    });\n            graphQLSelectionSet ?? (graphQLSelectionSet = selectionSetFields);\n        // TODO(Eslint): this this case clause correct without the break statement?\n        // eslint-disable-next-line no-fallthrough\n        case 'LIST':\n            graphQLArguments ??\n                (graphQLArguments = {\n                    filter: `Model${name}FilterInput`,\n                    ...(sortKeyFieldNames.length > 0\n                        ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {\n                            acc[fieldName] = `${fields[fieldName].type}`;\n                            return acc;\n                        }, { sortDirection: 'ModelSortDirection' })\n                        : []),\n                    limit: 'Int',\n                    nextToken: 'String',\n                });\n            graphQLOperationType ?? (graphQLOperationType = 'query');\n            graphQLSelectionSet ??\n                (graphQLSelectionSet = `items { ${selectionSetFields} } nextToken __typename`);\n        // TODO(Eslint): this this case clause correct without the break statement?\n        // eslint-disable-next-line no-fallthrough\n        case 'INDEX_QUERY':\n            graphQLArguments ??\n                (graphQLArguments = {\n                    ...indexQueryArgs,\n                    filter: `Model${name}FilterInput`,\n                    sortDirection: 'ModelSortDirection',\n                    limit: 'Int',\n                    nextToken: 'String',\n                });\n            graphQLOperationType ?? (graphQLOperationType = 'query');\n            graphQLSelectionSet ??\n                (graphQLSelectionSet = `items { ${selectionSetFields} } nextToken __typename`);\n        // TODO(Eslint): this this case clause correct without the break statement?\n        // eslint-disable-next-line no-fallthrough\n        case 'ONCREATE':\n        case 'ONUPDATE':\n        case 'ONDELETE':\n            graphQLArguments ??\n                (graphQLArguments = {\n                    filter: `ModelSubscription${name}FilterInput`,\n                });\n            graphQLOperationType ?? (graphQLOperationType = 'subscription');\n            graphQLSelectionSet ?? (graphQLSelectionSet = selectionSetFields);\n            break;\n        case 'OBSERVE_QUERY':\n        default:\n            throw new Error('Internal error: Attempted to generate graphql document for observeQuery. Please report this error.');\n    }\n    const graphQLDocument = `${graphQLOperationType}${graphQLArguments\n        ? `(${Object.entries(graphQLArguments).map(([fieldName, type]) => `$${fieldName}: ${type}`)})`\n        : ''} { ${graphQLFieldName}${graphQLArguments\n        ? `(${Object.keys(graphQLArguments).map(fieldName => `${fieldName}: $${fieldName}`)})`\n        : ''} { ${graphQLSelectionSet} } }`;\n    return graphQLDocument;\n}\nexport function buildGraphQLVariables(modelDefinition, operation, arg, modelIntrospection, indexMeta) {\n    const { fields, primaryKeyInfo: { isCustomPrimaryKey, primaryKeyFieldName, sortKeyFieldNames, }, } = modelDefinition;\n    let variables = {};\n    // TODO: process input\n    switch (operation) {\n        case 'CREATE':\n            variables = {\n                input: arg\n                    ? normalizeMutationInput(arg, modelDefinition, modelIntrospection)\n                    : {},\n            };\n            break;\n        case 'UPDATE':\n            // readonly fields are not  updated\n            variables = {\n                input: arg\n                    ? Object.fromEntries(Object.entries(normalizeMutationInput(arg, modelDefinition, modelIntrospection)).filter(([fieldName]) => {\n                        const { isReadOnly } = fields[fieldName];\n                        return !isReadOnly;\n                    }))\n                    : {},\n            };\n            break;\n        case 'READ':\n        case 'DELETE':\n            // only identifiers are sent\n            if (arg) {\n                variables = isCustomPrimaryKey\n                    ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {\n                        acc[fieldName] = arg[fieldName];\n                        return acc;\n                    }, {})\n                    : { [primaryKeyFieldName]: arg[primaryKeyFieldName] };\n            }\n            if (operation === 'DELETE') {\n                variables = { input: variables };\n            }\n            break;\n        case 'LIST':\n            if (arg?.filter) {\n                variables.filter = arg.filter;\n            }\n            if (arg?.sortDirection) {\n                variables.sortDirection = arg.sortDirection;\n                variables[primaryKeyFieldName] = arg[primaryKeyFieldName];\n            }\n            if (arg?.nextToken) {\n                variables.nextToken = arg.nextToken;\n            }\n            if (arg?.limit) {\n                variables.limit = arg.limit;\n            }\n            break;\n        case 'INDEX_QUERY': {\n            const { pk, sk = [] } = indexMeta;\n            variables[pk] = arg[pk];\n            for (const skField of sk) {\n                variables[skField] = arg[skField];\n            }\n            if (arg?.filter) {\n                variables.filter = arg.filter;\n            }\n            if (arg?.sortDirection) {\n                variables.sortDirection = arg.sortDirection;\n            }\n            if (arg?.nextToken) {\n                variables.nextToken = arg.nextToken;\n            }\n            if (arg?.limit) {\n                variables.limit = arg.limit;\n            }\n            break;\n        }\n        case 'ONCREATE':\n        case 'ONUPDATE':\n        case 'ONDELETE':\n            if (arg?.filter) {\n                variables = { filter: arg.filter };\n            }\n            break;\n        case 'OBSERVE_QUERY':\n            throw new Error('Internal error: Attempted to build variables for observeQuery. Please report this error.');\n            break;\n        default: {\n            const exhaustiveCheck = operation;\n            throw new Error(`Unhandled operation case: ${exhaustiveCheck}`);\n        }\n    }\n    return variables;\n}\n/**\n * Iterates over mutation input values and resolves any model inputs to their corresponding join fields/values\n *\n * @example\n * ### Usage\n * ```ts\n * const result = normalizeMutationInput({ post: post }, model, modelDefinition);\n * ```\n * ### Result\n * ```ts\n * { postId: \"abc123\" }\n * ```\n *\n */\nexport function normalizeMutationInput(mutationInput, model, modelIntrospection) {\n    const { fields } = model;\n    const normalized = {};\n    Object.entries(mutationInput).forEach(([inputFieldName, inputValue]) => {\n        const fieldType = fields[inputFieldName]?.type;\n        const relatedModelName = fieldType?.model;\n        if (relatedModelName) {\n            const association = fields[inputFieldName]?.association;\n            const relatedModelDef = modelIntrospection.models[relatedModelName];\n            const relatedModelPkInfo = relatedModelDef.primaryKeyInfo;\n            if (association?.connectionType === connectionType.HAS_ONE) {\n                const associationHasOne = association;\n                associationHasOne.targetNames.forEach((targetName, idx) => {\n                    const associatedFieldName = associationHasOne.associatedWith[idx];\n                    normalized[targetName] = inputValue[associatedFieldName];\n                });\n            }\n            if (association?.connectionType === connectionType.BELONGS_TO) {\n                const associationBelongsTo = association;\n                associationBelongsTo.targetNames.forEach((targetName, idx) => {\n                    if (idx === 0) {\n                        const associatedFieldName = relatedModelPkInfo.primaryKeyFieldName;\n                        normalized[targetName] = inputValue[associatedFieldName];\n                    }\n                    else {\n                        const associatedFieldName = relatedModelPkInfo.sortKeyFieldNames[idx - 1];\n                        normalized[targetName] = inputValue[associatedFieldName];\n                    }\n                });\n            }\n        }\n        else {\n            normalized[inputFieldName] = inputValue;\n        }\n    });\n    return normalized;\n}\n/**\n * Produces a parameter object that can contains auth mode/token overrides\n * only if present in either `options` (first) or configured on the `client`\n * as a fallback.\n *\n * @param client Configured client from `generateClient`\n * @param options Args/Options object from call site.\n * @returns\n */\nexport function authModeParams(client, options = {}) {\n    return {\n        authMode: options.authMode || client[__authMode],\n        authToken: options.authToken || client[__authToken],\n    };\n}\n/**\n * Retrieves custom headers from either the client or request options.\n * @param client V6Client | V6ClientSSRRequest | V6ClientSSRCookies - for extracting client headers\n * @param requestHeaders {@link CustomHeaders} - request headers\n * @returns custom headers as {@link CustomHeaders}\n */\nexport function getCustomHeaders(client, requestHeaders) {\n    let headers = client[__headers] || {};\n    // Individual request headers will take precedence over client headers.\n    // We intentionally do *not* merge client and request headers.\n    if (requestHeaders) {\n        headers = requestHeaders;\n    }\n    return headers;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}