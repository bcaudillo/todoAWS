{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar dlv_1 = __importDefault(require(\"dlv\"));\nfunction matches(event, matcher) {\n  if (!matcher) {\n    throw new Error('No matcher supplied!');\n  }\n  switch (matcher.type) {\n    case 'all':\n      return all();\n    case 'fql':\n      return fql(matcher.ir, event);\n    default:\n      throw new Error(\"Matcher of type \".concat(matcher.type, \" unsupported.\"));\n  }\n}\nexports.default = matches;\nfunction all() {\n  return true;\n}\nfunction fql(ir, event) {\n  if (!ir) {\n    return false;\n  }\n  try {\n    ir = JSON.parse(ir);\n  } catch (e) {\n    throw new Error(\"Failed to JSON.parse FQL intermediate representation \\\"\".concat(ir, \"\\\": \").concat(e));\n  }\n  var result = fqlEvaluate(ir, event);\n  if (typeof result !== 'boolean') {\n    // An error was returned, or a lowercase, typeof, or similar function was run alone. Nothing to evaluate.\n    return false;\n  }\n  return result;\n}\n// FQL is 100% type strict in Go. Show no mercy to types which do not comply.\nfunction fqlEvaluate(ir, event) {\n  // If the given ir chunk is not an array, then we should check the single given path or value for literally `true`.\n  if (!Array.isArray(ir)) {\n    return getValue(ir, event) === true;\n  }\n  // Otherwise, it is a sequence of ordered steps to follow to reach our solution!\n  var item = ir[0];\n  switch (item) {\n    /*** Unary cases ***/\n    // '!' => Invert the result\n    case '!':\n      return !fqlEvaluate(ir[1], event);\n    /*** Binary cases ***/\n    // 'or' => Any condition being true returns true\n    case 'or':\n      for (var i = 1; i < ir.length; i++) {\n        if (fqlEvaluate(ir[i], event)) {\n          return true;\n        }\n      }\n      return false;\n    // 'and' => Any condition being false returns false\n    case 'and':\n      for (var i = 1; i < ir.length; i++) {\n        if (!fqlEvaluate(ir[i], event)) {\n          return false;\n        }\n      }\n      return true;\n    // Equivalence comparisons\n    case '=':\n    case '!=':\n      return compareItems(getValue(ir[1], event), getValue(ir[2], event), item, event);\n    // Numerical comparisons\n    case '<=':\n    case '<':\n    case '>':\n    case '>=':\n      // Compare the two values with the given operator.\n      return compareNumbers(getValue(ir[1], event), getValue(ir[2], event), item, event);\n    // item in [list]' => Checks whether item is in list\n    case 'in':\n      return checkInList(getValue(ir[1], event), getValue(ir[2], event), event);\n    /*** Functions ***/\n    // 'contains(str1, str2)' => The first string has a substring of the second string\n    case 'contains':\n      return contains(getValue(ir[1], event), getValue(ir[2], event));\n    // 'match(str, match)' => The given string matches the provided glob matcher\n    case 'match':\n      return match(getValue(ir[1], event), getValue(ir[2], event));\n    // 'lowercase(str)' => Returns a lowercased string, null if the item is not a string\n    case 'lowercase':\n      var target = getValue(ir[1], event);\n      if (typeof target !== 'string') {\n        return null;\n      }\n      return target.toLowerCase();\n    // 'typeof(val)' => Returns the FQL type of the value\n    case 'typeof':\n      // TODO: Do we need mapping to allow for universal comparisons? e.g. Object -> JSON, Array -> List, Floats?\n      return typeof getValue(ir[1], event);\n    // 'length(val)' => Returns the length of an array or string, NaN if neither\n    case 'length':\n      return length(getValue(ir[1], event));\n    // If nothing hit, we or the IR messed up somewhere.\n    default:\n      throw new Error(\"FQL IR could not evaluate for token: \".concat(item));\n  }\n}\nfunction getValue(item, event) {\n  // If item is an array, leave it as-is.\n  if (Array.isArray(item)) {\n    return item;\n  }\n  // If item is an object, it has the form of `{\"value\": VAL}`\n  if (typeof item === 'object') {\n    return item.value;\n  }\n  // Otherwise, it's an event path, e.g. \"properties.email\"\n  return (0, dlv_1.default)(event, item);\n}\nfunction checkInList(item, list, event) {\n  return list.find(function (it) {\n    return getValue(it, event) === item;\n  }) !== undefined;\n}\nfunction compareNumbers(first, second, operator, event) {\n  // Check if it's more IR (such as a length() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event);\n  }\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event);\n  }\n  if (typeof first !== 'number' || typeof second !== 'number') {\n    return false;\n  }\n  // Reminder: NaN is not comparable to any other number (including NaN) and will always return false as desired.\n  switch (operator) {\n    // '<=' => The first number is less than or equal to the second.\n    case '<=':\n      return first <= second;\n    // '>=' => The first number is greater than or equal to the second\n    case '>=':\n      return first >= second;\n    // '<' The first number is less than the second.\n    case '<':\n      return first < second;\n    // '>' The first number is greater than the second.\n    case '>':\n      return first > second;\n    default:\n      throw new Error(\"Invalid operator in compareNumbers: \".concat(operator));\n  }\n}\nfunction compareItems(first, second, operator, event) {\n  // Check if it's more IR (such as a lowercase() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event);\n  }\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event);\n  }\n  if (typeof first === 'object' && typeof second === 'object') {\n    first = JSON.stringify(first);\n    second = JSON.stringify(second);\n  }\n  // Objects with the exact same contents AND order ARE considered identical. (Don't compare by reference)\n  // Even in Go, this MUST be the same byte order.\n  // e.g. {a: 1, b:2} === {a: 1, b:2} BUT {a:1, b:2} !== {b:2, a:1}\n  // Maybe later we'll use a stable stringifier, but we're matching server-side behavior for now.\n  switch (operator) {\n    // '=' => The two following items are exactly identical\n    case '=':\n      return first === second;\n    // '!=' => The two following items are NOT exactly identical.\n    case '!=':\n      return first !== second;\n    default:\n      throw new Error(\"Invalid operator in compareItems: \".concat(operator));\n  }\n}\nfunction contains(first, second) {\n  if (typeof first !== 'string' || typeof second !== 'string') {\n    return false;\n  }\n  return first.indexOf(second) !== -1;\n}\nfunction match(str, glob) {\n  if (typeof str !== 'string' || typeof glob !== 'string') {\n    return false;\n  }\n  return globMatches(glob, str);\n}\nfunction length(item) {\n  // Match server-side behavior.\n  if (item === null) {\n    return 0;\n  }\n  // Type-check to avoid returning .length of an object\n  if (!Array.isArray(item) && typeof item !== 'string') {\n    return NaN;\n  }\n  return item.length;\n}\n// This is a heuristic technically speaking, but should be close enough. The odds of someone trying to test\n// a func with identical IR notation is pretty low.\nfunction isIR(value) {\n  // TODO: This can be better checked by checking if this is a {\"value\": THIS}\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  // Function checks\n  if ((value[0] === 'lowercase' || value[0] === 'length' || value[0] === 'typeof') && value.length === 2) {\n    return true;\n  }\n  if ((value[0] === 'contains' || value[0] === 'match') && value.length === 3) {\n    return true;\n  }\n  return false;\n}\n// Any reputable glob matcher is designed to work on filesystems and doesn't allow the override of the separator\n// character \"/\". This is problematic since our server-side representation e.g. evaluates \"match('ab/c', 'a*)\"\n// as TRUE, whereas any glob matcher for JS available does false. So we're rewriting it here.\n// See: https://github.com/segmentio/glob/blob/master/glob.go\nfunction globMatches(pattern, str) {\n  var _a, _b;\n  Pattern: while (pattern.length > 0) {\n    var star = void 0;\n    var chunk = void 0;\n    _a = scanChunk(pattern), star = _a.star, chunk = _a.chunk, pattern = _a.pattern;\n    if (star && chunk === '') {\n      // Trailing * matches rest of string\n      return true;\n    }\n    // Look for match at current position\n    var _c = matchChunk(chunk, str),\n      t = _c.t,\n      ok = _c.ok,\n      err = _c.err;\n    if (err) {\n      return false;\n    }\n    // If we're the last chunk, make sure we've exhausted the str\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length === 0 || pattern.length > 0)) {\n      str = t;\n      continue;\n    }\n    if (star) {\n      // Look for match, skipping i+1 bytes.\n      for (var i = 0; i < str.length; i++) {\n        ;\n        _b = matchChunk(chunk, str.slice(i + 1)), t = _b.t, ok = _b.ok, err = _b.err;\n        if (ok) {\n          // If we're the last chunk, make sure we exhausted the str.\n          if (pattern.length === 0 && t.length > 0) {\n            continue;\n          }\n          str = t;\n          continue Pattern;\n        }\n        if (err) {\n          return false;\n        }\n      }\n    }\n    return false;\n  }\n  return str.length === 0;\n}\nfunction scanChunk(pattern) {\n  var result = {\n    star: false,\n    chunk: '',\n    pattern: ''\n  };\n  while (pattern.length > 0 && pattern[0] === '*') {\n    pattern = pattern.slice(1);\n    result.star = true;\n  }\n  var inRange = false;\n  var i;\n  Scan: for (i = 0; i < pattern.length; i++) {\n    switch (pattern[i]) {\n      case '\\\\':\n        // Error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++;\n        }\n        break;\n      case '[':\n        inRange = true;\n        break;\n      case ']':\n        inRange = false;\n        break;\n      case '*':\n        if (!inRange) {\n          break Scan;\n        }\n    }\n  }\n  result.chunk = pattern.slice(0, i);\n  result.pattern = pattern.slice(i);\n  return result;\n}\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\nfunction matchChunk(chunk, str) {\n  var _a, _b;\n  var result = {\n    t: '',\n    ok: false,\n    err: false\n  };\n  while (chunk.length > 0) {\n    if (str.length === 0) {\n      return result;\n    }\n    switch (chunk[0]) {\n      case '[':\n        var char = str[0];\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n        var notNegated = true;\n        if (chunk.length > 0 && chunk[0] === '^') {\n          notNegated = false;\n          chunk = chunk.slice(1);\n        }\n        // Parse all ranges\n        var foundMatch = false;\n        var nRange = 0;\n        while (true) {\n          if (chunk.length > 0 && chunk[0] === ']' && nRange > 0) {\n            chunk = chunk.slice(1);\n            break;\n          }\n          var lo = '';\n          var hi = '';\n          var err = void 0;\n          _a = getEsc(chunk), lo = _a.char, chunk = _a.newChunk, err = _a.err;\n          if (err) {\n            return result;\n          }\n          hi = lo;\n          if (chunk[0] === '-') {\n            ;\n            _b = getEsc(chunk.slice(1)), hi = _b.char, chunk = _b.newChunk, err = _b.err;\n            if (err) {\n              return result;\n            }\n          }\n          if (lo <= char && char <= hi) {\n            foundMatch = true;\n          }\n          nRange++;\n        }\n        if (foundMatch !== notNegated) {\n          return result;\n        }\n        break;\n      case '?':\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n        break;\n      case '\\\\':\n        chunk = chunk.slice(1);\n        if (chunk.length === 0) {\n          result.err = true;\n          return result;\n        }\n      // Fallthrough, missing break intentional.\n      default:\n        if (chunk[0] !== str[0]) {\n          return result;\n        }\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n    }\n  }\n  result.t = str;\n  result.ok = true;\n  result.err = false;\n  return result;\n}\n// getEsc gets a possibly-escaped character from chunk, for a character class.\nfunction getEsc(chunk) {\n  var result = {\n    char: '',\n    newChunk: '',\n    err: false\n  };\n  if (chunk.length === 0 || chunk[0] === '-' || chunk[0] === ']') {\n    result.err = true;\n    return result;\n  }\n  if (chunk[0] === '\\\\') {\n    chunk = chunk.slice(1);\n    if (chunk.length === 0) {\n      result.err = true;\n      return result;\n    }\n  }\n  // Unlike Go, JS strings operate on characters instead of bytes.\n  // This is why we aren't copying over the GetRuneFromString stuff.\n  result.char = chunk[0];\n  result.newChunk = chunk.slice(1);\n  if (result.newChunk.length === 0) {\n    result.err = true;\n  }\n  return result;\n}","map":{"version":3,"names":["dlv_1","__importDefault","require","matches","event","matcher","Error","type","all","fql","ir","concat","exports","default","JSON","parse","e","result","fqlEvaluate","Array","isArray","getValue","item","i","length","compareItems","compareNumbers","checkInList","contains","match","target","toLowerCase","value","list","find","it","undefined","first","second","operator","isIR","stringify","indexOf","str","glob","globMatches","NaN","pattern","Pattern","star","chunk","_a","scanChunk","_c","matchChunk","t","ok","err","_b","slice","inRange","Scan","char","notNegated","foundMatch","nRange","lo","hi","getEsc","newChunk"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/tsub/src/matchers.ts"],"sourcesContent":["import * as Store from './store'\nimport get from 'dlv'\n\nexport default function matches(event, matcher: Store.Matcher): boolean {\n  if (!matcher) {\n    throw new Error('No matcher supplied!')\n  }\n\n  switch (matcher.type) {\n    case 'all':\n      return all()\n    case 'fql':\n      return fql(matcher.ir, event)\n    default:\n      throw new Error(`Matcher of type ${matcher.type} unsupported.`)\n  }\n}\n\nfunction all(): boolean {\n  return true\n}\n\nfunction fql(ir: Store.Matcher['ir'], event): boolean {\n  if (!ir) {\n    return false\n  }\n\n  try {\n    ir = JSON.parse(ir)\n  } catch (e) {\n    throw new Error(`Failed to JSON.parse FQL intermediate representation \"${ir}\": ${e}`)\n  }\n\n  const result = fqlEvaluate(ir, event)\n  if (typeof result !== 'boolean') {\n    // An error was returned, or a lowercase, typeof, or similar function was run alone. Nothing to evaluate.\n    return false\n  }\n\n  return result\n}\n\n// FQL is 100% type strict in Go. Show no mercy to types which do not comply.\nfunction fqlEvaluate(ir, event) {\n  // If the given ir chunk is not an array, then we should check the single given path or value for literally `true`.\n  if (!Array.isArray(ir)) {\n    return getValue(ir, event) === true\n  }\n\n  // Otherwise, it is a sequence of ordered steps to follow to reach our solution!\n  const item = ir[0]\n  switch (item) {\n    /*** Unary cases ***/\n    // '!' => Invert the result\n    case '!':\n      return !fqlEvaluate(ir[1], event)\n\n    /*** Binary cases ***/\n    // 'or' => Any condition being true returns true\n    case 'or':\n      for (let i = 1; i < ir.length; i++) {\n        if (fqlEvaluate(ir[i], event)) {\n          return true\n        }\n      }\n      return false\n    // 'and' => Any condition being false returns false\n    case 'and':\n      for (let i = 1; i < ir.length; i++) {\n        if (!fqlEvaluate(ir[i], event)) {\n          return false\n        }\n      }\n      return true\n    // Equivalence comparisons\n    case '=':\n    case '!=':\n      return compareItems(getValue(ir[1], event), getValue(ir[2], event), item, event)\n    // Numerical comparisons\n    case '<=':\n    case '<':\n    case '>':\n    case '>=':\n      // Compare the two values with the given operator.\n      return compareNumbers(getValue(ir[1], event), getValue(ir[2], event), item, event)\n    // item in [list]' => Checks whether item is in list\n    case 'in':\n      return checkInList(getValue(ir[1], event), getValue(ir[2], event), event)\n\n    /*** Functions ***/\n    // 'contains(str1, str2)' => The first string has a substring of the second string\n    case 'contains':\n      return contains(getValue(ir[1], event), getValue(ir[2], event))\n    // 'match(str, match)' => The given string matches the provided glob matcher\n    case 'match':\n      return match(getValue(ir[1], event), getValue(ir[2], event))\n    // 'lowercase(str)' => Returns a lowercased string, null if the item is not a string\n    case 'lowercase':\n      const target = getValue(ir[1], event)\n      if (typeof target !== 'string') {\n        return null\n      }\n      return target.toLowerCase()\n    // 'typeof(val)' => Returns the FQL type of the value\n    case 'typeof':\n      // TODO: Do we need mapping to allow for universal comparisons? e.g. Object -> JSON, Array -> List, Floats?\n      return typeof getValue(ir[1], event)\n    // 'length(val)' => Returns the length of an array or string, NaN if neither\n    case 'length':\n      return length(getValue(ir[1], event))\n    // If nothing hit, we or the IR messed up somewhere.\n    default:\n      throw new Error(`FQL IR could not evaluate for token: ${item}`)\n  }\n}\n\nfunction getValue(item, event) {\n  // If item is an array, leave it as-is.\n  if (Array.isArray(item)) {\n    return item\n  }\n\n  // If item is an object, it has the form of `{\"value\": VAL}`\n  if (typeof item === 'object') {\n    return item.value\n  }\n\n  // Otherwise, it's an event path, e.g. \"properties.email\"\n  return get(event, item)\n}\n\nfunction checkInList(item, list, event): boolean {\n  return list.find(it => getValue(it, event) === item) !== undefined\n}\n\nfunction compareNumbers(first, second, operator, event): boolean {\n  // Check if it's more IR (such as a length() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event)\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event)\n  }\n\n  if (typeof first !== 'number' || typeof second !== 'number') {\n    return false\n  }\n\n  // Reminder: NaN is not comparable to any other number (including NaN) and will always return false as desired.\n  switch (operator) {\n    // '<=' => The first number is less than or equal to the second.\n    case '<=':\n      return first <= second\n    // '>=' => The first number is greater than or equal to the second\n    case '>=':\n      return first >= second\n    // '<' The first number is less than the second.\n    case '<':\n      return first < second\n    // '>' The first number is greater than the second.\n    case '>':\n      return first > second\n    default:\n      throw new Error(`Invalid operator in compareNumbers: ${operator}`)\n  }\n}\n\nfunction compareItems(first, second, operator, event): boolean {\n  // Check if it's more IR (such as a lowercase() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event)\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event)\n  }\n\n  if (typeof first === 'object' && typeof second === 'object') {\n    first = JSON.stringify(first)\n    second = JSON.stringify(second)\n  }\n\n  // Objects with the exact same contents AND order ARE considered identical. (Don't compare by reference)\n  // Even in Go, this MUST be the same byte order.\n  // e.g. {a: 1, b:2} === {a: 1, b:2} BUT {a:1, b:2} !== {b:2, a:1}\n  // Maybe later we'll use a stable stringifier, but we're matching server-side behavior for now.\n  switch (operator) {\n    // '=' => The two following items are exactly identical\n    case '=':\n      return first === second\n    // '!=' => The two following items are NOT exactly identical.\n    case '!=':\n      return first !== second\n    default:\n      throw new Error(`Invalid operator in compareItems: ${operator}`)\n  }\n}\n\nfunction contains(first, second): boolean {\n  if (typeof first !== 'string' || typeof second !== 'string') {\n    return false\n  }\n\n  return first.indexOf(second) !== -1\n}\n\nfunction match(str, glob): boolean {\n  if (typeof str !== 'string' || typeof glob !== 'string') {\n    return false\n  }\n\n  return globMatches(glob, str)\n}\n\nfunction length(item) {\n  // Match server-side behavior.\n  if (item === null) {\n    return 0\n  }\n\n  // Type-check to avoid returning .length of an object\n  if (!Array.isArray(item) && typeof item !== 'string') {\n    return NaN\n  }\n\n  return item.length\n}\n\n// This is a heuristic technically speaking, but should be close enough. The odds of someone trying to test\n// a func with identical IR notation is pretty low.\nfunction isIR(value): boolean {\n  // TODO: This can be better checked by checking if this is a {\"value\": THIS}\n  if (!Array.isArray(value)) {\n    return false\n  }\n\n  // Function checks\n  if (\n    (value[0] === 'lowercase' || value[0] === 'length' || value[0] === 'typeof') &&\n    value.length === 2\n  ) {\n    return true\n  }\n\n  if ((value[0] === 'contains' || value[0] === 'match') && value.length === 3) {\n    return true\n  }\n\n  return false\n}\n\n// Any reputable glob matcher is designed to work on filesystems and doesn't allow the override of the separator\n// character \"/\". This is problematic since our server-side representation e.g. evaluates \"match('ab/c', 'a*)\"\n// as TRUE, whereas any glob matcher for JS available does false. So we're rewriting it here.\n// See: https://github.com/segmentio/glob/blob/master/glob.go\nfunction globMatches(pattern, str): boolean {\n  Pattern: while (pattern.length > 0) {\n    let star\n    let chunk\n    ;({ star, chunk, pattern } = scanChunk(pattern))\n    if (star && chunk === '') {\n      // Trailing * matches rest of string\n      return true\n    }\n\n    // Look for match at current position\n    let { t, ok, err } = matchChunk(chunk, str)\n    if (err) {\n      return false\n    }\n\n    // If we're the last chunk, make sure we've exhausted the str\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length === 0 || pattern.length > 0)) {\n      str = t\n      continue\n    }\n\n    if (star) {\n      // Look for match, skipping i+1 bytes.\n      for (let i = 0; i < str.length; i++) {\n        ;({ t, ok, err } = matchChunk(chunk, str.slice(i + 1)))\n        if (ok) {\n          // If we're the last chunk, make sure we exhausted the str.\n          if (pattern.length === 0 && t.length > 0) {\n            continue\n          }\n\n          str = t\n          continue Pattern\n        }\n\n        if (err) {\n          return false\n        }\n      }\n    }\n\n    return false\n  }\n\n  return str.length === 0\n}\n\nfunction scanChunk(pattern): any {\n  const result = {\n    star: false,\n    chunk: '',\n    pattern: '',\n  }\n\n  while (pattern.length > 0 && pattern[0] === '*') {\n    pattern = pattern.slice(1)\n    result.star = true\n  }\n\n  let inRange = false\n  let i\n\n  Scan: for (i = 0; i < pattern.length; i++) {\n    switch (pattern[i]) {\n      case '\\\\':\n        // Error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++\n        }\n        break\n      case '[':\n        inRange = true\n        break\n      case ']':\n        inRange = false\n        break\n      case '*':\n        if (!inRange) {\n          break Scan\n        }\n    }\n  }\n\n  result.chunk = pattern.slice(0, i)\n  result.pattern = pattern.slice(i)\n  return result\n}\n\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\nfunction matchChunk(chunk, str): any {\n  const result = {\n    t: '',\n    ok: false,\n    err: false,\n  }\n\n  while (chunk.length > 0) {\n    if (str.length === 0) {\n      return result\n    }\n\n    switch (chunk[0]) {\n      case '[':\n        const char = str[0]\n        str = str.slice(1)\n        chunk = chunk.slice(1)\n\n        let notNegated = true\n        if (chunk.length > 0 && chunk[0] === '^') {\n          notNegated = false\n          chunk = chunk.slice(1)\n        }\n\n        // Parse all ranges\n        let foundMatch = false\n        let nRange = 0\n        while (true) {\n          if (chunk.length > 0 && chunk[0] === ']' && nRange > 0) {\n            chunk = chunk.slice(1)\n            break\n          }\n\n          let lo = ''\n          let hi = ''\n          let err\n          ;({ char: lo, newChunk: chunk, err } = getEsc(chunk))\n          if (err) {\n            return result\n          }\n\n          hi = lo\n          if (chunk[0] === '-') {\n            ;({ char: hi, newChunk: chunk, err } = getEsc(chunk.slice(1)))\n            if (err) {\n              return result\n            }\n          }\n\n          if (lo <= char && char <= hi) {\n            foundMatch = true\n          }\n\n          nRange++\n        }\n\n        if (foundMatch !== notNegated) {\n          return result\n        }\n        break\n      case '?':\n        str = str.slice(1)\n        chunk = chunk.slice(1)\n        break\n      case '\\\\':\n        chunk = chunk.slice(1)\n        if (chunk.length === 0) {\n          result.err = true\n          return result\n        }\n      // Fallthrough, missing break intentional.\n      default:\n        if (chunk[0] !== str[0]) {\n          return result\n        }\n        str = str.slice(1)\n        chunk = chunk.slice(1)\n    }\n  }\n\n  result.t = str\n  result.ok = true\n  result.err = false\n  return result\n}\n\n// getEsc gets a possibly-escaped character from chunk, for a character class.\nfunction getEsc(chunk): any {\n  const result = {\n    char: '',\n    newChunk: '',\n    err: false,\n  }\n\n  if (chunk.length === 0 || chunk[0] === '-' || chunk[0] === ']') {\n    result.err = true\n    return result\n  }\n\n  if (chunk[0] === '\\\\') {\n    chunk = chunk.slice(1)\n    if (chunk.length === 0) {\n      result.err = true\n      return result\n    }\n  }\n\n  // Unlike Go, JS strings operate on characters instead of bytes.\n  // This is why we aren't copying over the GetRuneFromString stuff.\n  result.char = chunk[0]\n  result.newChunk = chunk.slice(1)\n  if (result.newChunk.length === 0) {\n    result.err = true\n  }\n\n  return result\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}