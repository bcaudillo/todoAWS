{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar md5_1 = __importDefault(require(\"tiny-hashes/md5\"));\nvar dlv_1 = __importDefault(require(\"dlv\"));\nvar math_base_special_ldexp_1 = __importDefault(require(\"@stdlib/math-base-special-ldexp\"));\nvar dset_1 = require(\"dset\");\nvar unset_1 = require(\"./unset\");\nfunction transform(payload, transformers) {\n  var transformedPayload = payload;\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n    switch (transformer.type) {\n      case 'drop':\n        return null;\n      case 'drop_properties':\n        dropProperties(transformedPayload, transformer.config);\n        break;\n      case 'allow_properties':\n        allowProperties(transformedPayload, transformer.config);\n        break;\n      case 'sample_event':\n        if (sampleEvent(transformedPayload, transformer.config)) {\n          break;\n        }\n        return null;\n      case 'map_properties':\n        mapProperties(transformedPayload, transformer.config);\n        break;\n      case 'hash_properties':\n        // Not yet supported, but don't throw an error. Just ignore.\n        break;\n      default:\n        throw new Error(\"Transformer of type \\\"\".concat(transformer.type, \"\\\" is unsupported.\"));\n    }\n  }\n  return transformedPayload;\n}\nexports.default = transform;\n// dropProperties removes all specified props from the object.\nfunction dropProperties(payload, config) {\n  filterProperties(payload, config.drop, function (matchedObj, dropList) {\n    dropList.forEach(function (k) {\n      return delete matchedObj[k];\n    });\n  });\n}\n// allowProperties ONLY allows the specific targets within the keys. (e.g. \"a.foo\": [\"bar\", \"baz\"]\n// on {a: {foo: {bar: 1, baz: 2}, other: 3}} will not have any drops, as it only looks inside a.foo\nfunction allowProperties(payload, config) {\n  filterProperties(payload, config.allow, function (matchedObj, preserveList) {\n    Object.keys(matchedObj).forEach(function (key) {\n      if (!preserveList.includes(key)) {\n        delete matchedObj[key];\n      }\n    });\n  });\n}\nfunction filterProperties(payload, ruleSet, filterCb) {\n  Object.entries(ruleSet).forEach(function (_a) {\n    var key = _a[0],\n      targets = _a[1];\n    var filter = function (obj) {\n      // Can only act on objects.\n      if (typeof obj !== 'object' || obj === null) {\n        return;\n      }\n      filterCb(obj, targets);\n    };\n    // If key is empty, it refers to the top-level object.\n    var matchedObject = key === '' ? payload : (0, dlv_1.default)(payload, key);\n    if (Array.isArray(matchedObject)) {\n      matchedObject.forEach(filter);\n    } else {\n      filter(matchedObject);\n    }\n  });\n}\nfunction mapProperties(payload, config) {\n  // Some configs might try to modify or read from a field multiple times. We will only ever read\n  // values as they were before any modifications began. Thus, if you try to override e.g.\n  // {a: {b: 1}} with set(a, 'b', 2) (which results in {a: {b: 2}}) and then try to copy a.b into\n  // a.c, you will get {a: {b: 2, c:1}} and NOT {a: {b:2, c:2}}. This prevents map evaluation\n  // order from mattering, and === what server-side does.\n  // See: https://github.com/segmentio/tsub/blob/661695a63b60b90471796e667458f076af788c19/transformers/map_properties.go#L179-L200\n  var initialPayload = JSON.parse(JSON.stringify(payload));\n  for (var key in config.map) {\n    if (!config.map.hasOwnProperty(key)) {\n      continue;\n    }\n    var actionMap = config.map[key];\n    // Can't manipulate non-objects. Check that the parent is one. Strip the last .field\n    // from the string.\n    var splitKey = key.split('.');\n    var parent_1 = void 0;\n    if (splitKey.length > 1) {\n      splitKey.pop();\n      parent_1 = (0, dlv_1.default)(initialPayload, splitKey.join('.'));\n    } else {\n      parent_1 = payload;\n    }\n    if (typeof parent_1 !== 'object') {\n      continue;\n    }\n    // These actions are exclusive to each other.\n    if (actionMap.copy) {\n      var valueToCopy = (0, dlv_1.default)(initialPayload, actionMap.copy);\n      if (valueToCopy !== undefined) {\n        (0, dset_1.dset)(payload, key, valueToCopy);\n      }\n    } else if (actionMap.move) {\n      var valueToMove = (0, dlv_1.default)(initialPayload, actionMap.move);\n      if (valueToMove !== undefined) {\n        (0, dset_1.dset)(payload, key, valueToMove);\n      }\n      (0, unset_1.unset)(payload, actionMap.move);\n    }\n    // Have to check only if property exists, as null, undefined, and other vals could be explicitly set.\n    else if (actionMap.hasOwnProperty('set')) {\n      (0, dset_1.dset)(payload, key, actionMap.set);\n    }\n    // to_string is not exclusive and can be paired with other actions. Final action.\n    if (actionMap.to_string) {\n      var valueToString = (0, dlv_1.default)(payload, key);\n      // Do not string arrays and objects. Do not double-encode strings.\n      if (typeof valueToString === 'string' || typeof valueToString === 'object' && valueToString !== null) {\n        continue;\n      }\n      // TODO: Check stringifier in Golang for parity.\n      if (valueToString !== undefined) {\n        (0, dset_1.dset)(payload, key, JSON.stringify(valueToString));\n      } else {\n        // TODO: Check this behavior.\n        (0, dset_1.dset)(payload, key, 'undefined');\n      }\n    }\n  }\n}\nfunction sampleEvent(payload, config) {\n  if (config.sample.percent <= 0) {\n    return false;\n  } else if (config.sample.percent >= 1) {\n    return true;\n  }\n  // If we're not filtering deterministically, just use raw percentage.\n  if (!config.sample.path) {\n    return samplePercent(config.sample.percent);\n  }\n  // Otherwise, use a deterministic hash.\n  return sampleConsistentPercent(payload, config);\n}\nfunction samplePercent(percent) {\n  // Math.random returns [0, 1) => 0.0<>0.9999...\n  return Math.random() <= percent;\n}\n// sampleConsistentPercent converts an input string of bytes into a consistent uniform\n// continuous distribution of [0.0, 1.0]. This is based on\n// http://mumble.net/~campbell/tmp/random_real.c, but using the digest\n// result of the input value as the random information.\n// IMPORTANT - This function needs to === the Golang implementation to ensure that the two return the same vals!\n// See: https://github.com/segmentio/sampler/blob/65cb04132305a04fcd4bcaef67d57fbe40c30241/sampler.go#L13-L38\n// Since AJS supports IE9+ (typed arrays were introduced in IE10) we're doing some manual array math.\n// This could be done directly with strings, but arrays are easier to reason about/have better function support.\nfunction sampleConsistentPercent(payload, config) {\n  var field = (0, dlv_1.default)(payload, config.sample.path);\n  // Operate off of JSON bytes. TODO: Validate all type behavior, esp. strings.\n  var digest = (0, md5_1.default)(JSON.stringify(field));\n  var exponent = -64;\n  // Manually maintain 64-bit int as an array.\n  var significand = [];\n  // Left-shift and OR for first 8 bytes of digest. (8 bytes * 8 = 64 bits)\n  consumeDigest(digest.slice(0, 8), significand);\n  var leadingZeros = 0;\n  for (var i = 0; i < 64; i++) {\n    if (significand[i] === 1) {\n      break;\n    }\n    leadingZeros++;\n  }\n  if (leadingZeros !== 0) {\n    // Use the last 8 bytes of the digest, same as before.\n    var val = [];\n    consumeDigest(digest.slice(9, 16), val);\n    exponent -= leadingZeros;\n    // Left-shift away leading zeros in significand.\n    significand.splice(0, leadingZeros);\n    // Right-shift val by 64 minus leading zeros and push into significand.\n    val.splice(64 - leadingZeros);\n    significand = significand.concat(val);\n  }\n  // Flip 64th bit\n  significand[63] = significand[63] === 0 ? 1 : 0;\n  // Convert our manual binary into a JS num (binary arr => binary string => psuedo-int) and run the ldexp!\n  return (0, math_base_special_ldexp_1.default)(parseInt(significand.join(''), 2), exponent) < config.sample.percent;\n}\n// Array byte filler helper\nfunction consumeDigest(digest, arr) {\n  for (var i = 0; i < 8; i++) {\n    var remainder = digest[i];\n    for (var binary = 128; binary >= 1; binary /= 2) {\n      if (remainder - binary >= 0) {\n        remainder -= binary;\n        arr.push(1);\n      } else {\n        arr.push(0);\n      }\n    }\n  }\n}","map":{"version":3,"names":["md5_1","__importDefault","require","dlv_1","math_base_special_ldexp_1","dset_1","unset_1","transform","payload","transformers","transformedPayload","_i","transformers_1","length","transformer","type","dropProperties","config","allowProperties","sampleEvent","mapProperties","Error","concat","exports","default","filterProperties","drop","matchedObj","dropList","forEach","k","allow","preserveList","Object","keys","key","includes","ruleSet","filterCb","entries","_a","targets","filter","obj","matchedObject","Array","isArray","initialPayload","JSON","parse","stringify","map","hasOwnProperty","actionMap","splitKey","split","parent_1","pop","join","copy","valueToCopy","undefined","dset","move","valueToMove","unset","set","to_string","valueToString","sample","percent","path","samplePercent","sampleConsistentPercent","Math","random","field","digest","exponent","significand","consumeDigest","slice","leadingZeros","i","val","splice","parseInt","arr","remainder","binary","push"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/tsub/src/transformers.ts"],"sourcesContent":["import { Transformer } from './store'\nimport MD5 from 'tiny-hashes/md5'\nimport get from 'dlv'\nimport ldexp from '@stdlib/math-base-special-ldexp'\nimport { dset } from 'dset';\nimport { unset } from './unset'\n\nexport type KeyTarget = Record<string, string[]>\n\nexport interface TransformerConfig {\n  allow?: KeyTarget\n  drop?: KeyTarget\n  sample?: TransformerConfigSample\n  map?: Record<string, TransformerConfigMap>\n}\n\nexport interface TransformerConfigSample {\n  percent: number\n  path: string\n}\n\nexport interface TransformerConfigMap {\n  set?: any\n  copy?: string\n  move?: string\n  to_string?: boolean\n}\n\nexport default function transform(payload: any, transformers: Transformer[]): any {\n  const transformedPayload: any = payload\n\n  for (const transformer of transformers) {\n    switch (transformer.type) {\n      case 'drop':\n        return null\n      case 'drop_properties':\n        dropProperties(transformedPayload, transformer.config)\n        break\n      case 'allow_properties':\n        allowProperties(transformedPayload, transformer.config)\n        break\n      case 'sample_event':\n        if (sampleEvent(transformedPayload, transformer.config)) {\n          break\n        }\n        return null\n      case 'map_properties':\n        mapProperties(transformedPayload, transformer.config)\n        break\n      case 'hash_properties':\n        // Not yet supported, but don't throw an error. Just ignore.\n        break\n      default:\n        throw new Error(`Transformer of type \"${transformer.type}\" is unsupported.`)\n    }\n  }\n\n  return transformedPayload\n}\n\n// dropProperties removes all specified props from the object.\nfunction dropProperties(payload: any, config: TransformerConfig) {\n  filterProperties(payload, config.drop, (matchedObj, dropList) => {\n    dropList.forEach(k => delete matchedObj[k])\n  })\n}\n\n// allowProperties ONLY allows the specific targets within the keys. (e.g. \"a.foo\": [\"bar\", \"baz\"]\n// on {a: {foo: {bar: 1, baz: 2}, other: 3}} will not have any drops, as it only looks inside a.foo\nfunction allowProperties(payload: any, config: TransformerConfig) {\n  filterProperties(payload, config.allow, (matchedObj, preserveList) => {\n    Object.keys(matchedObj).forEach(key => {\n      if (!preserveList.includes(key)) {\n        delete matchedObj[key]\n      }\n    })\n  })\n}\n\nfunction filterProperties(payload: any, ruleSet: KeyTarget, filterCb: (matchedObject: any, targets: string[]) => void) {\n  Object.entries(ruleSet).forEach(([key, targets]) => {\n    const filter = (obj: any) => {\n      // Can only act on objects.\n      if (typeof obj !== 'object' || obj === null) {\n        return\n      }\n      \n      filterCb(obj, targets)\n    }\n\n    // If key is empty, it refers to the top-level object.\n    const matchedObject = key === '' ? payload : get(payload, key)\n\n    if (Array.isArray(matchedObject)) {\n      matchedObject.forEach(filter)\n    } else {\n      filter(matchedObject)\n    }\n  })\n}\n\nfunction mapProperties(payload: any, config: TransformerConfig) {\n  // Some configs might try to modify or read from a field multiple times. We will only ever read\n  // values as they were before any modifications began. Thus, if you try to override e.g.\n  // {a: {b: 1}} with set(a, 'b', 2) (which results in {a: {b: 2}}) and then try to copy a.b into\n  // a.c, you will get {a: {b: 2, c:1}} and NOT {a: {b:2, c:2}}. This prevents map evaluation\n  // order from mattering, and === what server-side does.\n  // See: https://github.com/segmentio/tsub/blob/661695a63b60b90471796e667458f076af788c19/transformers/map_properties.go#L179-L200\n  const initialPayload = JSON.parse(JSON.stringify(payload))\n\n  for (const key in config.map) {\n    if (!config.map.hasOwnProperty(key)) {\n      continue\n    }\n\n    const actionMap: TransformerConfigMap = config.map[key]\n\n    // Can't manipulate non-objects. Check that the parent is one. Strip the last .field\n    // from the string.\n    const splitKey = key.split('.')\n    let parent\n    if (splitKey.length > 1) {\n      splitKey.pop()\n      parent = get(initialPayload, splitKey.join('.'))\n    } else {\n      parent = payload\n    }\n\n    if (typeof parent !== 'object') {\n      continue\n    }\n\n    // These actions are exclusive to each other.\n    if (actionMap.copy) {\n      const valueToCopy = get(initialPayload, actionMap.copy)\n      if (valueToCopy !== undefined) {\n        dset(payload, key, valueToCopy)\n      }\n    } else if (actionMap.move) {\n      const valueToMove = get(initialPayload, actionMap.move)\n      if (valueToMove !== undefined) {\n        dset(payload, key, valueToMove)\n      }\n\n      unset(payload, actionMap.move)\n    }\n    // Have to check only if property exists, as null, undefined, and other vals could be explicitly set.\n    else if (actionMap.hasOwnProperty('set')) {\n      dset(payload, key, actionMap.set)\n    }\n\n    // to_string is not exclusive and can be paired with other actions. Final action.\n    if (actionMap.to_string) {\n      const valueToString = get(payload, key)\n\n      // Do not string arrays and objects. Do not double-encode strings.\n      if (\n        typeof valueToString === 'string' ||\n        (typeof valueToString === 'object' && valueToString !== null)\n      ) {\n        continue\n      }\n\n      // TODO: Check stringifier in Golang for parity.\n      if (valueToString !== undefined) {\n        dset(payload, key, JSON.stringify(valueToString))\n      } else {\n        // TODO: Check this behavior.\n        dset(payload, key, 'undefined')\n      }\n    }\n  }\n}\n\nfunction sampleEvent(payload: any, config: TransformerConfig): boolean {\n  if (config.sample.percent <= 0) {\n    return false\n  } else if (config.sample.percent >= 1) {\n    return true\n  }\n\n  // If we're not filtering deterministically, just use raw percentage.\n  if (!config.sample.path) {\n    return samplePercent(config.sample.percent)\n  }\n\n  // Otherwise, use a deterministic hash.\n  return sampleConsistentPercent(payload, config)\n}\n\nfunction samplePercent(percent: number): boolean {\n  // Math.random returns [0, 1) => 0.0<>0.9999...\n  return Math.random() <= percent\n}\n\n// sampleConsistentPercent converts an input string of bytes into a consistent uniform\n// continuous distribution of [0.0, 1.0]. This is based on\n// http://mumble.net/~campbell/tmp/random_real.c, but using the digest\n// result of the input value as the random information.\n\n// IMPORTANT - This function needs to === the Golang implementation to ensure that the two return the same vals!\n// See: https://github.com/segmentio/sampler/blob/65cb04132305a04fcd4bcaef67d57fbe40c30241/sampler.go#L13-L38\n\n// Since AJS supports IE9+ (typed arrays were introduced in IE10) we're doing some manual array math.\n// This could be done directly with strings, but arrays are easier to reason about/have better function support.\nfunction sampleConsistentPercent(payload: any, config: TransformerConfig): boolean {\n  const field = get(payload, config.sample.path)\n\n  // Operate off of JSON bytes. TODO: Validate all type behavior, esp. strings.\n  const digest: number[] = MD5(JSON.stringify(field))\n  let exponent = -64\n\n  // Manually maintain 64-bit int as an array.\n  let significand: number[] = []\n\n  // Left-shift and OR for first 8 bytes of digest. (8 bytes * 8 = 64 bits)\n  consumeDigest(digest.slice(0, 8), significand)\n\n  let leadingZeros = 0\n  for (let i = 0; i < 64; i++) {\n    if (significand[i] === 1) {\n      break\n    }\n\n    leadingZeros++\n  }\n\n  if (leadingZeros !== 0) {\n    // Use the last 8 bytes of the digest, same as before.\n    const val: number[] = []\n    consumeDigest(digest.slice(9, 16), val)\n\n    exponent -= leadingZeros\n    // Left-shift away leading zeros in significand.\n    significand.splice(0, leadingZeros)\n\n    // Right-shift val by 64 minus leading zeros and push into significand.\n    val.splice(64 - leadingZeros)\n    significand = significand.concat(val)\n  }\n\n  // Flip 64th bit\n  significand[63] = significand[63] === 0 ? 1 : 0\n\n  // Convert our manual binary into a JS num (binary arr => binary string => psuedo-int) and run the ldexp!\n  return ldexp(parseInt(significand.join(''), 2), exponent) < config.sample.percent\n}\n\n// Array byte filler helper\nfunction consumeDigest(digest: number[], arr: number[]) {\n  for (let i = 0; i < 8; i++) {\n    let remainder = digest[i]\n    for (let binary = 128; binary >= 1; binary /= 2) {\n      if (remainder - binary >= 0) {\n        remainder -= binary\n        arr.push(1)\n      } else {\n        arr.push(0)\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}