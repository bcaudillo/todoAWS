{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { ContextCancelation } from '../../core/context';\nimport { toFacade } from '../../lib/to-facade';\nexport function applyDestinationMiddleware(destination, evt, middleware) {\n  return __awaiter(this, void 0, void 0, function () {\n    function applyMiddleware(event, fn) {\n      return __awaiter(this, void 0, void 0, function () {\n        var nextCalled, returnedEvent;\n        var _a;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              nextCalled = false;\n              returnedEvent = null;\n              return [4 /*yield*/, fn({\n                payload: toFacade(event, {\n                  clone: true,\n                  traverse: false\n                }),\n                integration: destination,\n                next: function (evt) {\n                  nextCalled = true;\n                  if (evt === null) {\n                    returnedEvent = null;\n                  }\n                  if (evt) {\n                    returnedEvent = evt.obj;\n                  }\n                }\n              })];\n            case 1:\n              _b.sent();\n              if (!nextCalled && returnedEvent !== null) {\n                returnedEvent = returnedEvent;\n                returnedEvent.integrations = __assign(__assign({}, event.integrations), (_a = {}, _a[destination] = false, _a));\n              }\n              return [2 /*return*/, returnedEvent];\n          }\n        });\n      });\n    }\n    var modifiedEvent, _i, middleware_1, md, result;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          modifiedEvent = toFacade(evt, {\n            clone: true,\n            traverse: false\n          }).rawEvent();\n          _i = 0, middleware_1 = middleware;\n          _a.label = 1;\n        case 1:\n          if (!(_i < middleware_1.length)) return [3 /*break*/, 4];\n          md = middleware_1[_i];\n          return [4 /*yield*/, applyMiddleware(modifiedEvent, md)];\n        case 2:\n          result = _a.sent();\n          if (result === null) {\n            return [2 /*return*/, null];\n          }\n          modifiedEvent = result;\n          _a.label = 3;\n        case 3:\n          _i++;\n          return [3 /*break*/, 1];\n        case 4:\n          return [2 /*return*/, modifiedEvent];\n      }\n    });\n  });\n}\nexport function sourceMiddlewarePlugin(fn, integrations) {\n  function apply(ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nextCalled;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            nextCalled = false;\n            return [4 /*yield*/, fn({\n              payload: toFacade(ctx.event, {\n                clone: true,\n                traverse: false\n              }),\n              integrations: integrations !== null && integrations !== void 0 ? integrations : {},\n              next: function (evt) {\n                nextCalled = true;\n                if (evt) {\n                  ctx.event = evt.obj;\n                }\n              }\n            })];\n          case 1:\n            _a.sent();\n            if (!nextCalled) {\n              throw new ContextCancelation({\n                retry: false,\n                type: 'middleware_cancellation',\n                reason: 'Middleware `next` function skipped'\n              });\n            }\n            return [2 /*return*/, ctx];\n        }\n      });\n    });\n  }\n  return {\n    name: \"Source Middleware \".concat(fn.name),\n    type: 'before',\n    version: '0.1.0',\n    isLoaded: function () {\n      return true;\n    },\n    load: function (ctx) {\n      return Promise.resolve(ctx);\n    },\n    track: apply,\n    page: apply,\n    identify: apply,\n    alias: apply,\n    group: apply\n  };\n}","map":{"version":3,"names":["ContextCancelation","toFacade","applyDestinationMiddleware","destination","evt","middleware","applyMiddleware","event","fn","nextCalled","returnedEvent","payload","clone","traverse","integration","next","obj","_b","sent","integrations","__assign","_a","modifiedEvent","rawEvent","middleware_1","_i","length","md","result","sourceMiddlewarePlugin","apply","ctx","retry","type","reason","name","concat","version","isLoaded","load","Promise","resolve","track","page","identify","alias","group"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/analytics-next/src/plugins/middleware/index.ts"],"sourcesContent":["import { Context, ContextCancelation } from '../../core/context'\nimport { SegmentEvent } from '../../core/events'\nimport { Plugin } from '../../core/plugin'\nimport { SegmentFacade, toFacade } from '../../lib/to-facade'\n\nexport interface MiddlewareParams {\n  payload: SegmentFacade\n\n  integrations?: SegmentEvent['integrations']\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport interface DestinationMiddlewareParams {\n  payload: SegmentFacade\n  integration: string\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport type MiddlewareFunction = (\n  middleware: MiddlewareParams\n) => void | Promise<void>\n\nexport type DestinationMiddlewareFunction = (\n  middleware: DestinationMiddlewareParams\n) => void | Promise<void>\n\nexport async function applyDestinationMiddleware(\n  destination: string,\n  evt: SegmentEvent,\n  middleware: DestinationMiddlewareFunction[]\n): Promise<SegmentEvent | null> {\n  // Clone the event so mutations are localized to a single destination.\n  let modifiedEvent = toFacade(evt, {\n    clone: true,\n    traverse: false,\n  }).rawEvent() as SegmentEvent\n  async function applyMiddleware(\n    event: SegmentEvent,\n    fn: DestinationMiddlewareFunction\n  ): Promise<SegmentEvent | null> {\n    let nextCalled = false\n    let returnedEvent: SegmentEvent | null = null\n\n    await fn({\n      payload: toFacade(event, {\n        clone: true,\n        traverse: false,\n      }),\n      integration: destination,\n      next(evt) {\n        nextCalled = true\n\n        if (evt === null) {\n          returnedEvent = null\n        }\n\n        if (evt) {\n          returnedEvent = evt.obj\n        }\n      },\n    })\n\n    if (!nextCalled && returnedEvent !== null) {\n      returnedEvent = returnedEvent as SegmentEvent\n      returnedEvent.integrations = {\n        ...event.integrations,\n        [destination]: false,\n      }\n    }\n\n    return returnedEvent\n  }\n\n  for (const md of middleware) {\n    const result = await applyMiddleware(modifiedEvent, md)\n    if (result === null) {\n      return null\n    }\n    modifiedEvent = result\n  }\n\n  return modifiedEvent\n}\n\nexport function sourceMiddlewarePlugin(\n  fn: MiddlewareFunction,\n  integrations: SegmentEvent['integrations']\n): Plugin {\n  async function apply(ctx: Context): Promise<Context> {\n    let nextCalled = false\n\n    await fn({\n      payload: toFacade(ctx.event, {\n        clone: true,\n        traverse: false,\n      }),\n      integrations: integrations ?? {},\n      next(evt) {\n        nextCalled = true\n        if (evt) {\n          ctx.event = evt.obj\n        }\n      },\n    })\n\n    if (!nextCalled) {\n      throw new ContextCancelation({\n        retry: false,\n        type: 'middleware_cancellation',\n        reason: 'Middleware `next` function skipped',\n      })\n    }\n\n    return ctx\n  }\n\n  return {\n    name: `Source Middleware ${fn.name}`,\n    type: 'before',\n    version: '0.1.0',\n\n    isLoaded: (): boolean => true,\n    load: (ctx): Promise<Context> => Promise.resolve(ctx),\n\n    track: apply,\n    page: apply,\n    identify: apply,\n    alias: apply,\n    group: apply,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}