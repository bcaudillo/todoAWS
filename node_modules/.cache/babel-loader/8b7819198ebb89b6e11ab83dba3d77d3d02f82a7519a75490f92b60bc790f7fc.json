{"ast":null,"code":"import { map } from 'rxjs';\nimport { authModeParams, getCustomHeaders, flattenItems, initializeModel, selectionSetIRToString, defaultSelectionSetForNonModelWithIR, generateSelectionSet } from '../APIClient.mjs';\n\n/**\n * Type guard for checking whether a Custom Operation argument is a contextSpec object\n */\nconst argIsContextSpec = arg => {\n  var _arg$token;\n  return typeof (arg === null || arg === void 0 || (_arg$token = arg.token) === null || _arg$token === void 0 ? void 0 : _arg$token.value) === 'symbol';\n};\n/**\n * Builds an operation function, embedded with all client and context data, that\n * can be attached to a client as a custom query or mutation.\n *\n * If we have this source schema:\n *\n * ```typescript\n * a.schema({\n *   echo: a.query()\n *     .arguments({input: a.string().required()})\n *     .returns(a.string())\n * })\n * ```\n *\n * Our model intro schema will contain an entry like this:\n *\n * ```ts\n * {\n *   queries: {\n *     echo: {\n *       name: \"echo\",\n *       isArray: false,\n *       type: 'String',\n *       isRequired: false,\n *       arguments: {\n *         input: {\n *           name: 'input',\n *           isArray: false,\n *           type: String,\n *           isRequired: true\n *         }\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The `echo` object is used to build the `echo' method that goes here:\n *\n * ```typescript\n * const client = generateClent()\n * const { data } = await client.queries.echo({input: 'a string'});\n * //                                    ^\n * //                                    |\n * //                                    +-- This one right here.\n * //\n * ```\n *\n *\n * @param client The client to run graphql queries through.\n * @param modelIntrospection The model introspection schema the op comes from.\n * @param operationType The broad category of graphql operation.\n * @param operation The operation definition from the introspection schema.\n * @param useContext Whether the function needs to accept an SSR context.\n * @returns The operation function to attach to query, mutations, etc.\n */\nfunction customOpFactory(client, modelIntrospection, operationType, operation, useContext) {\n  // .arguments() are defined for the custom operation in the schema builder\n  // and are present in the model introspection schema\n  const argsDefined = operation.arguments !== undefined;\n  const op = function () {\n    var _ref;\n    // options is always the last argument\n    const options = (_ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);\n    let contextSpec;\n    let arg;\n    if (useContext) {\n      if (argIsContextSpec(arguments.length <= 0 ? undefined : arguments[0])) {\n        contextSpec = arguments.length <= 0 ? undefined : arguments[0];\n      } else {\n        throw new Error(\"Invalid first argument passed to \".concat(operation.name, \". Expected contextSpec\"));\n      }\n    }\n    if (argsDefined) {\n      if (useContext) {\n        arg = arguments.length <= 1 ? undefined : arguments[1];\n      } else {\n        arg = arguments.length <= 0 ? undefined : arguments[0];\n      }\n    }\n    if (operationType === 'subscription') {\n      return _opSubscription(\n      // subscriptions are only enabled on the clientside\n      client, modelIntrospection, operation, arg, options);\n    }\n    return _op(client, modelIntrospection, operationType, operation, arg, options, contextSpec);\n  };\n  return op;\n}\n/**\n * Runtime test and type guard to check whether `o[field]` is a `String`.\n *\n * ```typescript\n * if (hasStringField(o, 'prop')) {\n *   const s = o.prop;\n *   //    ^? const s: string\n * }\n * ```\n *\n * @param o Object to inspect\n * @param field Field to look for\n * @returns Boolean: `true` if the `o[field]` is a `string`\n */\nfunction hasStringField(o, field) {\n  return typeof o[field] === 'string';\n}\n/**\n * Generates \"outer\" arguments string for a custom operation. For example,\n * in this operation:\n *\n * ```graphql\n * query MyQuery(InputString: String!) {\n *   echoString(InputString: $InputString)\n * }\n * ```\n *\n * This function returns the top/outer level arguments as a string:\n *\n * ```json\n * \"InputString: String!\"\n * ```\n *\n * @param operation Operation object from model introspection schema.\n * @returns \"outer\" arguments string\n */\nfunction outerArguments(operation) {\n  if (operation.arguments === undefined) {\n    return '';\n  }\n  const args = Object.entries(operation.arguments).map(_ref2 => {\n    let [k, v] = _ref2;\n    const baseType = v.type + (v.isRequired ? '!' : '');\n    const finalType = v.isArray ? \"[\".concat(baseType, \"]\").concat(v.isArrayNullable ? '' : '!') : baseType;\n    return \"$\".concat(k, \": \").concat(finalType);\n  }).join(', ');\n  return args.length > 0 ? \"(\".concat(args, \")\") : '';\n}\n/**\n * Generates \"inner\" arguments string for a custom operation. For example,\n * in this operation:\n *\n * ```graphql\n * query MyQuery(InputString: String!) {\n *   echoString(InputString: $InputString)\n * }\n * ```\n *\n * This function returns the inner arguments as a string:\n *\n * ```json\n * \"InputString: $InputString\"\n * ```\n *\n * @param operation Operation object from model introspection schema.\n * @returns \"outer\" arguments string\n */\nfunction innerArguments(operation) {\n  if (operation.arguments === undefined) {\n    return '';\n  }\n  const args = Object.keys(operation.arguments).map(k => \"\".concat(k, \": $\").concat(k)).join(', ');\n  return args.length > 0 ? \"(\".concat(args, \")\") : '';\n}\n/**\n * Generates the selection set string for a custom operation. This is slightly\n * different than the selection set generation for models. If the custom op returns\n * a primitive or enum types, it doen't require a selection set at all.\n *\n * E.g., the graphql might look like this:\n *\n * ```graphql\n * query MyQuery {\n *   echoString(inputString: \"whatever\")\n * }\n * #                                     ^\n * #                                     |\n * #                                     +-- no selection set\n * ```\n *\n * Non-primitive return type selection set generation will be similar to other\n * model operations.\n *\n * @param modelIntrospection The full code-generated introspection schema.\n * @param operation The operation object from the schema.\n * @returns The selection set as a string.\n */\nfunction operationSelectionSet(modelIntrospection, operation) {\n  if (hasStringField(operation, 'type') || hasStringField(operation.type, 'enum')) {\n    return '';\n  } else if (hasStringField(operation.type, 'nonModel')) {\n    const nonModel = modelIntrospection.nonModels[operation.type.nonModel];\n    return \"{\".concat(selectionSetIRToString(defaultSelectionSetForNonModelWithIR(nonModel, modelIntrospection)), \"}\");\n  } else if (hasStringField(operation.type, 'model')) {\n    return \"{\".concat(generateSelectionSet(modelIntrospection, operation.type.model), \"}\");\n  } else {\n    return '';\n  }\n}\n/**\n * Maps an arguments objec to graphql variables, removing superfluous args and\n * screaming loudly when required args are missing.\n *\n * @param operation The operation to construct graphql request variables for.\n * @param args The arguments to map variables from.\n * @returns The graphql variables object.\n */\nfunction operationVariables(operation) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const variables = {};\n  if (operation.arguments === undefined) {\n    return variables;\n  }\n  for (const argDef of Object.values(operation.arguments)) {\n    if (typeof args[argDef.name] !== 'undefined') {\n      variables[argDef.name] = args[argDef.name];\n    } else if (argDef.isRequired) {\n      // At this point, the variable is both required and missing: We don't need\n      // to continue. The operation is expected to fail.\n      throw new Error(\"\".concat(operation.name, \" requires arguments '\").concat(argDef.name, \"'\"));\n    }\n  }\n  return variables;\n}\n/**\n * Executes an operation from the given model intro schema against a client, returning\n * a fully instantiated model when relevant.\n *\n * @param client The client to operate `graphql()` calls through.\n * @param modelIntrospection The model intro schema to construct requests from.\n * @param operationType The high level graphql operation type.\n * @param operation The specific operation name, args, return type details.\n * @param args The arguments to provide to the operation as variables.\n * @param options Request options like headers, etc.\n * @param context SSR context if relevant.\n * @returns Result from the graphql request, model-instantiated when relevant.\n */\nasync function _op(client, modelIntrospection, operationType, operation, args, options, context) {\n  const {\n    name: operationName\n  } = operation;\n  const auth = authModeParams(client, options);\n  const headers = getCustomHeaders(client, options === null || options === void 0 ? void 0 : options.headers);\n  const outerArgsString = outerArguments(operation);\n  const innerArgsString = innerArguments(operation);\n  const selectionSet = operationSelectionSet(modelIntrospection, operation);\n  const returnTypeModelName = hasStringField(operation.type, 'model') ? operation.type.model : undefined;\n  const query = \"\\n\\t\\t\".concat(operationType.toLocaleLowerCase()).concat(outerArgsString, \" {\\n\\t\\t\\t\").concat(operationName).concat(innerArgsString, \" \").concat(selectionSet, \"\\n\\t\\t}\\n\\t\");\n  const variables = operationVariables(operation, args);\n  try {\n    const {\n      data,\n      extensions\n    } = context ? await client.graphql(context, {\n      ...auth,\n      query,\n      variables\n    }, headers) : await client.graphql({\n      ...auth,\n      query,\n      variables\n    }, headers);\n    // flatten response\n    if (data) {\n      const [key] = Object.keys(data);\n      const flattenedResult = flattenItems(data)[key];\n      // TODO: custom selection set. current selection set is default selection set only\n      // custom selection set requires data-schema-type + runtime updates above.\n      const [initialized] = returnTypeModelName ? initializeModel(client, returnTypeModelName, [flattenedResult], modelIntrospection, auth.authMode, auth.authToken, !!context) : [flattenedResult];\n      return {\n        data: initialized,\n        extensions\n      };\n    } else {\n      return {\n        data: null,\n        extensions\n      };\n    }\n  } catch (error) {\n    if (error.errors) {\n      // graphql errors pass through\n      return error;\n    } else {\n      // non-graphql errors re re-thrown\n      throw error;\n    }\n  }\n}\n/**\n * Executes an operation from the given model intro schema against a client, returning\n * a fully instantiated model when relevant.\n *\n * @param client The client to operate `graphql()` calls through.\n * @param modelIntrospection The model intro schema to construct requests from.\n * @param operation The specific operation name, args, return type details.\n * @param args The arguments to provide to the operation as variables.\n * @param options Request options like headers, etc.\n * @returns Result from the graphql request, model-instantiated when relevant.\n */\nfunction _opSubscription(client, modelIntrospection, operation, args, options) {\n  const operationType = 'subscription';\n  const {\n    name: operationName\n  } = operation;\n  const auth = authModeParams(client, options);\n  const headers = getCustomHeaders(client, options === null || options === void 0 ? void 0 : options.headers);\n  const outerArgsString = outerArguments(operation);\n  const innerArgsString = innerArguments(operation);\n  const selectionSet = operationSelectionSet(modelIntrospection, operation);\n  const returnTypeModelName = hasStringField(operation.type, 'model') ? operation.type.model : undefined;\n  const query = \"\\n\\t\\t\".concat(operationType.toLocaleLowerCase()).concat(outerArgsString, \" {\\n\\t\\t\\t\").concat(operationName).concat(innerArgsString, \" \").concat(selectionSet, \"\\n\\t\\t}\\n\\t\");\n  const variables = operationVariables(operation, args);\n  const observable = client.graphql({\n    ...auth,\n    query,\n    variables\n  }, headers);\n  return observable.pipe(map(value => {\n    const [key] = Object.keys(value.data);\n    const data = value.data[key];\n    const [initialized] = returnTypeModelName ? initializeModel(client, returnTypeModelName, [data], modelIntrospection, auth.authMode, auth.authToken) : [data];\n    return initialized;\n  }));\n}\nexport { customOpFactory };","map":{"version":3,"names":["argIsContextSpec","arg","_arg$token","token","value","customOpFactory","client","modelIntrospection","operationType","operation","useContext","argsDefined","arguments","undefined","op","_ref","options","length","contextSpec","Error","concat","name","_opSubscription","_op","hasStringField","o","field","outerArguments","args","Object","entries","map","_ref2","k","v","baseType","type","isRequired","finalType","isArray","isArrayNullable","join","innerArguments","keys","operationSelectionSet","nonModel","nonModels","selectionSetIRToString","defaultSelectionSetForNonModelWithIR","generateSelectionSet","model","operationVariables","variables","argDef","values","context","operationName","auth","authModeParams","headers","getCustomHeaders","outerArgsString","innerArgsString","selectionSet","returnTypeModelName","query","toLocaleLowerCase","data","extensions","graphql","key","flattenedResult","flattenItems","initialized","initializeModel","authMode","authToken","error","errors","observable","pipe"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@aws-amplify/api-graphql/src/internals/operations/custom.ts"],"sourcesContent":["import { map } from 'rxjs';\nimport { authModeParams, defaultSelectionSetForNonModelWithIR, flattenItems, generateSelectionSet, getCustomHeaders, initializeModel, selectionSetIRToString, } from '../APIClient';\n/**\n * Type guard for checking whether a Custom Operation argument is a contextSpec object\n */\nconst argIsContextSpec = (arg) => {\n    return typeof arg?.token?.value === 'symbol';\n};\n/**\n * Builds an operation function, embedded with all client and context data, that\n * can be attached to a client as a custom query or mutation.\n *\n * If we have this source schema:\n *\n * ```typescript\n * a.schema({\n *   echo: a.query()\n *     .arguments({input: a.string().required()})\n *     .returns(a.string())\n * })\n * ```\n *\n * Our model intro schema will contain an entry like this:\n *\n * ```ts\n * {\n *   queries: {\n *     echo: {\n *       name: \"echo\",\n *       isArray: false,\n *       type: 'String',\n *       isRequired: false,\n *       arguments: {\n *         input: {\n *           name: 'input',\n *           isArray: false,\n *           type: String,\n *           isRequired: true\n *         }\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The `echo` object is used to build the `echo' method that goes here:\n *\n * ```typescript\n * const client = generateClent()\n * const { data } = await client.queries.echo({input: 'a string'});\n * //                                    ^\n * //                                    |\n * //                                    +-- This one right here.\n * //\n * ```\n *\n *\n * @param client The client to run graphql queries through.\n * @param modelIntrospection The model introspection schema the op comes from.\n * @param operationType The broad category of graphql operation.\n * @param operation The operation definition from the introspection schema.\n * @param useContext Whether the function needs to accept an SSR context.\n * @returns The operation function to attach to query, mutations, etc.\n */\nexport function customOpFactory(client, modelIntrospection, operationType, operation, useContext) {\n    // .arguments() are defined for the custom operation in the schema builder\n    // and are present in the model introspection schema\n    const argsDefined = operation.arguments !== undefined;\n    const op = (...args) => {\n        // options is always the last argument\n        const options = args[args.length - 1];\n        let contextSpec;\n        let arg;\n        if (useContext) {\n            if (argIsContextSpec(args[0])) {\n                contextSpec = args[0];\n            }\n            else {\n                throw new Error(`Invalid first argument passed to ${operation.name}. Expected contextSpec`);\n            }\n        }\n        if (argsDefined) {\n            if (useContext) {\n                arg = args[1];\n            }\n            else {\n                arg = args[0];\n            }\n        }\n        if (operationType === 'subscription') {\n            return _opSubscription(\n            // subscriptions are only enabled on the clientside\n            client, modelIntrospection, operation, arg, options);\n        }\n        return _op(client, modelIntrospection, operationType, operation, arg, options, contextSpec);\n    };\n    return op;\n}\n/**\n * Runtime test and type guard to check whether `o[field]` is a `String`.\n *\n * ```typescript\n * if (hasStringField(o, 'prop')) {\n *   const s = o.prop;\n *   //    ^? const s: string\n * }\n * ```\n *\n * @param o Object to inspect\n * @param field Field to look for\n * @returns Boolean: `true` if the `o[field]` is a `string`\n */\nfunction hasStringField(o, field) {\n    return typeof o[field] === 'string';\n}\n/**\n * Generates \"outer\" arguments string for a custom operation. For example,\n * in this operation:\n *\n * ```graphql\n * query MyQuery(InputString: String!) {\n *   echoString(InputString: $InputString)\n * }\n * ```\n *\n * This function returns the top/outer level arguments as a string:\n *\n * ```json\n * \"InputString: String!\"\n * ```\n *\n * @param operation Operation object from model introspection schema.\n * @returns \"outer\" arguments string\n */\nfunction outerArguments(operation) {\n    if (operation.arguments === undefined) {\n        return '';\n    }\n    const args = Object.entries(operation.arguments)\n        .map(([k, v]) => {\n        const baseType = v.type + (v.isRequired ? '!' : '');\n        const finalType = v.isArray\n            ? `[${baseType}]${v.isArrayNullable ? '' : '!'}`\n            : baseType;\n        return `$${k}: ${finalType}`;\n    })\n        .join(', ');\n    return args.length > 0 ? `(${args})` : '';\n}\n/**\n * Generates \"inner\" arguments string for a custom operation. For example,\n * in this operation:\n *\n * ```graphql\n * query MyQuery(InputString: String!) {\n *   echoString(InputString: $InputString)\n * }\n * ```\n *\n * This function returns the inner arguments as a string:\n *\n * ```json\n * \"InputString: $InputString\"\n * ```\n *\n * @param operation Operation object from model introspection schema.\n * @returns \"outer\" arguments string\n */\nfunction innerArguments(operation) {\n    if (operation.arguments === undefined) {\n        return '';\n    }\n    const args = Object.keys(operation.arguments)\n        .map(k => `${k}: $${k}`)\n        .join(', ');\n    return args.length > 0 ? `(${args})` : '';\n}\n/**\n * Generates the selection set string for a custom operation. This is slightly\n * different than the selection set generation for models. If the custom op returns\n * a primitive or enum types, it doen't require a selection set at all.\n *\n * E.g., the graphql might look like this:\n *\n * ```graphql\n * query MyQuery {\n *   echoString(inputString: \"whatever\")\n * }\n * #                                     ^\n * #                                     |\n * #                                     +-- no selection set\n * ```\n *\n * Non-primitive return type selection set generation will be similar to other\n * model operations.\n *\n * @param modelIntrospection The full code-generated introspection schema.\n * @param operation The operation object from the schema.\n * @returns The selection set as a string.\n */\nfunction operationSelectionSet(modelIntrospection, operation) {\n    if (hasStringField(operation, 'type') ||\n        hasStringField(operation.type, 'enum')) {\n        return '';\n    }\n    else if (hasStringField(operation.type, 'nonModel')) {\n        const nonModel = modelIntrospection.nonModels[operation.type.nonModel];\n        return `{${selectionSetIRToString(defaultSelectionSetForNonModelWithIR(nonModel, modelIntrospection))}}`;\n    }\n    else if (hasStringField(operation.type, 'model')) {\n        return `{${generateSelectionSet(modelIntrospection, operation.type.model)}}`;\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Maps an arguments objec to graphql variables, removing superfluous args and\n * screaming loudly when required args are missing.\n *\n * @param operation The operation to construct graphql request variables for.\n * @param args The arguments to map variables from.\n * @returns The graphql variables object.\n */\nfunction operationVariables(operation, args = {}) {\n    const variables = {};\n    if (operation.arguments === undefined) {\n        return variables;\n    }\n    for (const argDef of Object.values(operation.arguments)) {\n        if (typeof args[argDef.name] !== 'undefined') {\n            variables[argDef.name] = args[argDef.name];\n        }\n        else if (argDef.isRequired) {\n            // At this point, the variable is both required and missing: We don't need\n            // to continue. The operation is expected to fail.\n            throw new Error(`${operation.name} requires arguments '${argDef.name}'`);\n        }\n    }\n    return variables;\n}\n/**\n * Executes an operation from the given model intro schema against a client, returning\n * a fully instantiated model when relevant.\n *\n * @param client The client to operate `graphql()` calls through.\n * @param modelIntrospection The model intro schema to construct requests from.\n * @param operationType The high level graphql operation type.\n * @param operation The specific operation name, args, return type details.\n * @param args The arguments to provide to the operation as variables.\n * @param options Request options like headers, etc.\n * @param context SSR context if relevant.\n * @returns Result from the graphql request, model-instantiated when relevant.\n */\nasync function _op(client, modelIntrospection, operationType, operation, args, options, context) {\n    const { name: operationName } = operation;\n    const auth = authModeParams(client, options);\n    const headers = getCustomHeaders(client, options?.headers);\n    const outerArgsString = outerArguments(operation);\n    const innerArgsString = innerArguments(operation);\n    const selectionSet = operationSelectionSet(modelIntrospection, operation);\n    const returnTypeModelName = hasStringField(operation.type, 'model')\n        ? operation.type.model\n        : undefined;\n    const query = `\n\t\t${operationType.toLocaleLowerCase()}${outerArgsString} {\n\t\t\t${operationName}${innerArgsString} ${selectionSet}\n\t\t}\n\t`;\n    const variables = operationVariables(operation, args);\n    try {\n        const { data, extensions } = context\n            ? (await client.graphql(context, {\n                ...auth,\n                query,\n                variables,\n            }, headers))\n            : (await client.graphql({\n                ...auth,\n                query,\n                variables,\n            }, headers));\n        // flatten response\n        if (data) {\n            const [key] = Object.keys(data);\n            const flattenedResult = flattenItems(data)[key];\n            // TODO: custom selection set. current selection set is default selection set only\n            // custom selection set requires data-schema-type + runtime updates above.\n            const [initialized] = returnTypeModelName\n                ? initializeModel(client, returnTypeModelName, [flattenedResult], modelIntrospection, auth.authMode, auth.authToken, !!context)\n                : [flattenedResult];\n            return { data: initialized, extensions };\n        }\n        else {\n            return { data: null, extensions };\n        }\n    }\n    catch (error) {\n        if (error.errors) {\n            // graphql errors pass through\n            return error;\n        }\n        else {\n            // non-graphql errors re re-thrown\n            throw error;\n        }\n    }\n}\n/**\n * Executes an operation from the given model intro schema against a client, returning\n * a fully instantiated model when relevant.\n *\n * @param client The client to operate `graphql()` calls through.\n * @param modelIntrospection The model intro schema to construct requests from.\n * @param operation The specific operation name, args, return type details.\n * @param args The arguments to provide to the operation as variables.\n * @param options Request options like headers, etc.\n * @returns Result from the graphql request, model-instantiated when relevant.\n */\nfunction _opSubscription(client, modelIntrospection, operation, args, options) {\n    const operationType = 'subscription';\n    const { name: operationName } = operation;\n    const auth = authModeParams(client, options);\n    const headers = getCustomHeaders(client, options?.headers);\n    const outerArgsString = outerArguments(operation);\n    const innerArgsString = innerArguments(operation);\n    const selectionSet = operationSelectionSet(modelIntrospection, operation);\n    const returnTypeModelName = hasStringField(operation.type, 'model')\n        ? operation.type.model\n        : undefined;\n    const query = `\n\t\t${operationType.toLocaleLowerCase()}${outerArgsString} {\n\t\t\t${operationName}${innerArgsString} ${selectionSet}\n\t\t}\n\t`;\n    const variables = operationVariables(operation, args);\n    const observable = client.graphql({\n        ...auth,\n        query,\n        variables,\n    }, headers);\n    return observable.pipe(map(value => {\n        const [key] = Object.keys(value.data);\n        const data = value.data[key];\n        const [initialized] = returnTypeModelName\n            ? initializeModel(client, returnTypeModelName, [data], modelIntrospection, auth.authMode, auth.authToken)\n            : [data];\n        return initialized;\n    }));\n}\n"],"mappings":";;;AAEA;AACA;AACA;AACA,MAAMA,gBAAgB,GAAIC,GAAG,IAAK;EAAA,IAAAC,UAAA;EAC9B,OAAO,QAAOD,GAAG,aAAHA,GAAG,gBAAAC,UAAA,GAAHD,GAAG,CAAEE,KAAK,cAAAD,UAAA,uBAAVA,UAAA,CAAYE,KAAK,MAAK,QAAQ;AAChD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,eAAeA,CAACC,MAAM,EAAEC,kBAAkB,EAAEC,aAAa,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAClG;EACA;EACI,MAAMC,WAAW,GAAGF,SAAS,CAACG,SAAS,KAAKC,SAAS;EACrD,MAAMC,EAAE,GAAG,SAAAA,CAAA,EAAa;IAAA,IAAAC,IAAA;IAC5B;IACQ,MAAMC,OAAO,IAAAD,IAAA,GAAQH,SAAA,CAAKK,MAAM,GAAG,CAAC,EAAAF,IAAA,QAAAH,SAAA,CAAAK,MAAA,IAAAF,IAAA,GAAAF,SAAA,GAAAD,SAAA,CAAAG,IAAA,EAAC;IACrC,IAAIG,WAAW;IACf,IAAIjB,GAAG;IACP,IAAIS,UAAU,EAAE;MACZ,IAAIV,gBAAgB,CAAAY,SAAA,CAAAK,MAAA,QAAAJ,SAAA,GAAAD,SAAA,GAAQ,CAAC,EAAE;QAC3BM,WAAW,GAAAN,SAAA,CAAAK,MAAA,QAAAJ,SAAA,GAAAD,SAAA,GAAU;MACrC,CAAa,MACI;QACD,MAAM,IAAIO,KAAK,qCAAAC,MAAA,CAAqCX,SAAS,CAACY,IAAI,2BAAwB,CAAC;MAC3G;IACA;IACQ,IAAIV,WAAW,EAAE;MACb,IAAID,UAAU,EAAE;QACZT,GAAG,GAAAW,SAAA,CAAAK,MAAA,QAAAJ,SAAA,GAAAD,SAAA,GAAU;MAC7B,CAAa,MACI;QACDX,GAAG,GAAAW,SAAA,CAAAK,MAAA,QAAAJ,SAAA,GAAAD,SAAA,GAAU;MAC7B;IACA;IACQ,IAAIJ,aAAa,KAAK,cAAc,EAAE;MAClC,OAAOc,eAAe;MAClC;MACYhB,MAAM,EAAEC,kBAAkB,EAAEE,SAAS,EAAER,GAAG,EAAEe,OAAO,CAAC;IAChE;IACQ,OAAOO,GAAG,CAACjB,MAAM,EAAEC,kBAAkB,EAAEC,aAAa,EAAEC,SAAS,EAAER,GAAG,EAAEe,OAAO,EAAEE,WAAW,CAAC;EACnG,CAAK;EACD,OAAOJ,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,cAAcA,CAACC,CAAC,EAAEC,KAAK,EAAE;EAC9B,OAAO,OAAOD,CAAC,CAACC,KAAK,CAAC,KAAK,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAAClB,SAAS,EAAE;EAC/B,IAAIA,SAAS,CAACG,SAAS,KAAKC,SAAS,EAAE;IACnC,OAAO,EAAE;EACjB;EACI,MAAMe,IAAI,GAAGC,MAAM,CAACC,OAAO,CAACrB,SAAS,CAACG,SAAS,CAAC,CAC3CmB,GAAG,CAACC,KAAA,IAAY;IAAA,IAAX,CAACC,CAAC,EAAEC,CAAC,CAAC,GAAAF,KAAA;IACZ,MAAMG,QAAQ,GAAGD,CAAC,CAACE,IAAI,IAAIF,CAAC,CAACG,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC;IACnD,MAAMC,SAAS,GAAGJ,CAAC,CAACK,OAAO,OAAAnB,MAAA,CACjBe,QAAQ,OAAAf,MAAA,CAAIc,CAAC,CAACM,eAAe,GAAG,EAAE,GAAG,GAAG,IAC5CL,QAAQ;IACd,WAAAf,MAAA,CAAWa,CAAC,QAAAb,MAAA,CAAKkB,SAAS;EAClC,CAAK,CAAC,CACGG,IAAI,CAAC,IAAI,CAAC;EACf,OAAOb,IAAI,CAACX,MAAM,GAAG,CAAC,OAAAG,MAAA,CAAOQ,IAAI,SAAM,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,cAAcA,CAACjC,SAAS,EAAE;EAC/B,IAAIA,SAAS,CAACG,SAAS,KAAKC,SAAS,EAAE;IACnC,OAAO,EAAE;EACjB;EACI,MAAMe,IAAI,GAAGC,MAAM,CAACc,IAAI,CAAClC,SAAS,CAACG,SAAS,CAAC,CACxCmB,GAAG,CAACE,CAAC,OAAAb,MAAA,CAAOa,CAAC,SAAAb,MAAA,CAAMa,CAAC,CAAE,CAAC,CACvBQ,IAAI,CAAC,IAAI,CAAC;EACf,OAAOb,IAAI,CAACX,MAAM,GAAG,CAAC,OAAAG,MAAA,CAAOQ,IAAI,SAAM,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgB,qBAAqBA,CAACrC,kBAAkB,EAAEE,SAAS,EAAE;EAC1D,IAAIe,cAAc,CAACf,SAAS,EAAE,MAAM,CAAC,IACjCe,cAAc,CAACf,SAAS,CAAC2B,IAAI,EAAE,MAAM,CAAC,EAAE;IACxC,OAAO,EAAE;EACjB,CAAK,MACI,IAAIZ,cAAc,CAACf,SAAS,CAAC2B,IAAI,EAAE,UAAU,CAAC,EAAE;IACjD,MAAMS,QAAQ,GAAGtC,kBAAkB,CAACuC,SAAS,CAACrC,SAAS,CAAC2B,IAAI,CAACS,QAAQ,CAAC;IACtE,WAAAzB,MAAA,CAAW2B,sBAAsB,CAACC,oCAAoC,CAACH,QAAQ,EAAEtC,kBAAkB,CAAC,CAAC;EAC7G,CAAK,MACI,IAAIiB,cAAc,CAACf,SAAS,CAAC2B,IAAI,EAAE,OAAO,CAAC,EAAE;IAC9C,WAAAhB,MAAA,CAAW6B,oBAAoB,CAAC1C,kBAAkB,EAAEE,SAAS,CAAC2B,IAAI,CAACc,KAAK,CAAC;EACjF,CAAK,MACI;IACD,OAAO,EAAE;EACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAAC1C,SAAS,EAAa;EAAA,IAAXmB,IAAI,GAAAhB,SAAA,CAAAK,MAAA,QAAAL,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EAAE;EAC5C,MAAMwC,SAAS,GAAG,EAAE;EACpB,IAAI3C,SAAS,CAACG,SAAS,KAAKC,SAAS,EAAE;IACnC,OAAOuC,SAAS;EACxB;EACI,KAAK,MAAMC,MAAM,IAAIxB,MAAM,CAACyB,MAAM,CAAC7C,SAAS,CAACG,SAAS,CAAC,EAAE;IACrD,IAAI,OAAOgB,IAAI,CAACyB,MAAM,CAAChC,IAAI,CAAC,KAAK,WAAW,EAAE;MAC1C+B,SAAS,CAACC,MAAM,CAAChC,IAAI,CAAC,GAAGO,IAAI,CAACyB,MAAM,CAAChC,IAAI,CAAC;IACtD,CAAS,MACI,IAAIgC,MAAM,CAAChB,UAAU,EAAE;MACpC;MACA;MACY,MAAM,IAAIlB,KAAK,IAAAC,MAAA,CAAIX,SAAS,CAACY,IAAI,2BAAAD,MAAA,CAAwBiC,MAAM,CAAChC,IAAI,MAAG,CAAC;IACpF;EACA;EACI,OAAO+B,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe7B,GAAGA,CAACjB,MAAM,EAAEC,kBAAkB,EAAEC,aAAa,EAAEC,SAAS,EAAEmB,IAAI,EAAEZ,OAAO,EAAEuC,OAAO,EAAE;EAC7F,MAAM;IAAElC,IAAI,EAAEmC;EAAa,CAAE,GAAG/C,SAAS;EACzC,MAAMgD,IAAI,GAAGC,cAAc,CAACpD,MAAM,EAAEU,OAAO,CAAC;EAC5C,MAAM2C,OAAO,GAAGC,gBAAgB,CAACtD,MAAM,EAAEU,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE2C,OAAO,CAAC;EAC1D,MAAME,eAAe,GAAGlC,cAAc,CAAClB,SAAS,CAAC;EACjD,MAAMqD,eAAe,GAAGpB,cAAc,CAACjC,SAAS,CAAC;EACjD,MAAMsD,YAAY,GAAGnB,qBAAqB,CAACrC,kBAAkB,EAAEE,SAAS,CAAC;EACzE,MAAMuD,mBAAmB,GAAGxC,cAAc,CAACf,SAAS,CAAC2B,IAAI,EAAE,OAAO,CAAC,GAC7D3B,SAAS,CAAC2B,IAAI,CAACc,KAAK,GACpBrC,SAAS;EACf,MAAMoD,KAAK,YAAA7C,MAAA,CACXZ,aAAa,CAAC0D,iBAAiB,EAAE,EAAA9C,MAAA,CAAGyC,eAAe,gBAAAzC,MAAA,CAClDoC,aAAa,EAAApC,MAAA,CAAG0C,eAAe,OAAA1C,MAAA,CAAI2C,YAAY,gBAElD;EACE,MAAMX,SAAS,GAAGD,kBAAkB,CAAC1C,SAAS,EAAEmB,IAAI,CAAC;EACrD,IAAI;IACA,MAAM;MAAEuC,IAAI;MAAEC;IAAU,CAAE,GAAGb,OAAO,GAC7B,MAAMjD,MAAM,CAAC+D,OAAO,CAACd,OAAO,EAAE;MAC7B,GAAGE,IAAI;MACPQ,KAAK;MACLb;IAChB,CAAa,EAAEO,OAAO,CAAC,GACR,MAAMrD,MAAM,CAAC+D,OAAO,CAAC;MACpB,GAAGZ,IAAI;MACPQ,KAAK;MACLb;IAChB,CAAa,EAAEO,OAAO,CAAE;IACxB;IACQ,IAAIQ,IAAI,EAAE;MACN,MAAM,CAACG,GAAG,CAAC,GAAGzC,MAAM,CAACc,IAAI,CAACwB,IAAI,CAAC;MAC/B,MAAMI,eAAe,GAAGC,YAAY,CAACL,IAAI,CAAC,CAACG,GAAG,CAAC;MAC3D;MACA;MACY,MAAM,CAACG,WAAW,CAAC,GAAGT,mBAAmB,GACnCU,eAAe,CAACpE,MAAM,EAAE0D,mBAAmB,EAAE,CAACO,eAAe,CAAC,EAAEhE,kBAAkB,EAAEkD,IAAI,CAACkB,QAAQ,EAAElB,IAAI,CAACmB,SAAS,EAAE,CAAC,CAACrB,OAAO,CAAC,GAC7H,CAACgB,eAAe,CAAC;MACvB,OAAO;QAAEJ,IAAI,EAAEM,WAAW;QAAEL;MAAU,CAAE;IACpD,CAAS,MACI;MACD,OAAO;QAAED,IAAI,EAAE,IAAI;QAAEC;MAAU,CAAE;IAC7C;EACA,CAAK,CACD,OAAOS,KAAK,EAAE;IACV,IAAIA,KAAK,CAACC,MAAM,EAAE;MAC1B;MACY,OAAOD,KAAK;IACxB,CAAS,MACI;MACb;MACY,MAAMA,KAAK;IACvB;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvD,eAAeA,CAAChB,MAAM,EAAEC,kBAAkB,EAAEE,SAAS,EAAEmB,IAAI,EAAEZ,OAAO,EAAE;EAC3E,MAAMR,aAAa,GAAG,cAAc;EACpC,MAAM;IAAEa,IAAI,EAAEmC;EAAa,CAAE,GAAG/C,SAAS;EACzC,MAAMgD,IAAI,GAAGC,cAAc,CAACpD,MAAM,EAAEU,OAAO,CAAC;EAC5C,MAAM2C,OAAO,GAAGC,gBAAgB,CAACtD,MAAM,EAAEU,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE2C,OAAO,CAAC;EAC1D,MAAME,eAAe,GAAGlC,cAAc,CAAClB,SAAS,CAAC;EACjD,MAAMqD,eAAe,GAAGpB,cAAc,CAACjC,SAAS,CAAC;EACjD,MAAMsD,YAAY,GAAGnB,qBAAqB,CAACrC,kBAAkB,EAAEE,SAAS,CAAC;EACzE,MAAMuD,mBAAmB,GAAGxC,cAAc,CAACf,SAAS,CAAC2B,IAAI,EAAE,OAAO,CAAC,GAC7D3B,SAAS,CAAC2B,IAAI,CAACc,KAAK,GACpBrC,SAAS;EACf,MAAMoD,KAAK,YAAA7C,MAAA,CACXZ,aAAa,CAAC0D,iBAAiB,EAAE,EAAA9C,MAAA,CAAGyC,eAAe,gBAAAzC,MAAA,CAClDoC,aAAa,EAAApC,MAAA,CAAG0C,eAAe,OAAA1C,MAAA,CAAI2C,YAAY,gBAElD;EACE,MAAMX,SAAS,GAAGD,kBAAkB,CAAC1C,SAAS,EAAEmB,IAAI,CAAC;EACrD,MAAMmD,UAAU,GAAGzE,MAAM,CAAC+D,OAAO,CAAC;IAC9B,GAAGZ,IAAI;IACPQ,KAAK;IACLb;EACR,CAAK,EAAEO,OAAO,CAAC;EACX,OAAOoB,UAAU,CAACC,IAAI,CAACjD,GAAG,CAAC3B,KAAK,IAAI;IAChC,MAAM,CAACkE,GAAG,CAAC,GAAGzC,MAAM,CAACc,IAAI,CAACvC,KAAK,CAAC+D,IAAI,CAAC;IACrC,MAAMA,IAAI,GAAG/D,KAAK,CAAC+D,IAAI,CAACG,GAAG,CAAC;IAC5B,MAAM,CAACG,WAAW,CAAC,GAAGT,mBAAmB,GACnCU,eAAe,CAACpE,MAAM,EAAE0D,mBAAmB,EAAE,CAACG,IAAI,CAAC,EAAE5D,kBAAkB,EAAEkD,IAAI,CAACkB,QAAQ,EAAElB,IAAI,CAACmB,SAAS,CAAC,GACvG,CAACT,IAAI,CAAC;IACZ,OAAOM,WAAW;EAC1B,CAAK,CAAC,CAAC;AACP","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}