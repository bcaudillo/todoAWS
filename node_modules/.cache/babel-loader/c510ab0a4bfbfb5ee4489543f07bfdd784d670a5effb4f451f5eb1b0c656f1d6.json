{"ast":null,"code":"import { __awaiter, __generator, __spreadArray } from \"tslib\";\nimport { isThenable } from '../../lib/is-thenable';\nimport { version } from '../../generated/version';\nimport { getGlobalAnalytics } from '../../lib/global-analytics-helper';\nimport { isBufferedPageContext, getDefaultBufferedPageContext, createPageContext } from '../page';\nvar flushSyncAnalyticsCalls = function (name, analytics, buffer) {\n  buffer.getCalls(name).forEach(function (c) {\n    // While the underlying methods are synchronous, the callAnalyticsMethod returns a promise,\n    // which normalizes success and error states between async and non-async methods, with no perf penalty.\n    callAnalyticsMethod(analytics, c).catch(console.error);\n  });\n};\nexport var flushAddSourceMiddleware = function (analytics, buffer) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var _i, _a, c;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _i = 0, _a = buffer.getCalls('addSourceMiddleware');\n          _b.label = 1;\n        case 1:\n          if (!(_i < _a.length)) return [3 /*break*/, 4];\n          c = _a[_i];\n          return [4 /*yield*/, callAnalyticsMethod(analytics, c).catch(console.error)];\n        case 2:\n          _b.sent();\n          _b.label = 3;\n        case 3:\n          _i++;\n          return [3 /*break*/, 1];\n        case 4:\n          return [2 /*return*/];\n      }\n    });\n  });\n};\nexport var flushOn = flushSyncAnalyticsCalls.bind(this, 'on');\nexport var flushSetAnonymousID = flushSyncAnalyticsCalls.bind(this, 'setAnonymousId');\nexport var flushAnalyticsCallsInNewTask = function (analytics, buffer) {\n  buffer.toArray().forEach(function (m) {\n    setTimeout(function () {\n      callAnalyticsMethod(analytics, m).catch(console.error);\n    }, 0);\n  });\n};\nexport var popPageContext = function (args) {\n  if (hasBufferedPageContextAsLastArg(args)) {\n    var ctx = args.pop();\n    return createPageContext(ctx);\n  }\n};\nexport var hasBufferedPageContextAsLastArg = function (args) {\n  var lastArg = args[args.length - 1];\n  return isBufferedPageContext(lastArg);\n};\n/**\n *  Represents a buffered method call that occurred before initialization.\n */\nvar PreInitMethodCall = /** @class */function () {\n  function PreInitMethodCall(method, args, resolve, reject) {\n    if (resolve === void 0) {\n      resolve = function () {};\n    }\n    if (reject === void 0) {\n      reject = console.error;\n    }\n    this.method = method;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.called = false;\n    this.args = args;\n  }\n  return PreInitMethodCall;\n}();\nexport { PreInitMethodCall };\n/**\n *  Represents any and all the buffered method calls that occurred before initialization.\n */\nvar PreInitMethodCallBuffer = /** @class */function () {\n  function PreInitMethodCallBuffer() {\n    var calls = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      calls[_i] = arguments[_i];\n    }\n    this._callMap = {};\n    this.push.apply(this, calls);\n  }\n  Object.defineProperty(PreInitMethodCallBuffer.prototype, \"calls\", {\n    /**\n     * Pull any buffered method calls from the window object, and use them to hydrate the instance buffer.\n     */\n    get: function () {\n      this._pushSnippetWindowBuffer();\n      return this._callMap;\n    },\n    set: function (calls) {\n      this._callMap = calls;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  PreInitMethodCallBuffer.prototype.getCalls = function (methodName) {\n    var _a;\n    return (_a = this.calls[methodName]) !== null && _a !== void 0 ? _a : [];\n  };\n  PreInitMethodCallBuffer.prototype.push = function () {\n    var _this = this;\n    var calls = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      calls[_i] = arguments[_i];\n    }\n    calls.forEach(function (call) {\n      var eventsExpectingPageContext = ['track', 'screen', 'alias', 'group', 'page', 'identify'];\n      if (eventsExpectingPageContext.includes(call.method) && !hasBufferedPageContextAsLastArg(call.args)) {\n        call.args = __spreadArray(__spreadArray([], call.args, true), [getDefaultBufferedPageContext()], false);\n      }\n      if (_this.calls[call.method]) {\n        _this.calls[call.method].push(call);\n      } else {\n        _this.calls[call.method] = [call];\n      }\n    });\n  };\n  PreInitMethodCallBuffer.prototype.clear = function () {\n    // clear calls in the global snippet buffered array.\n    this._pushSnippetWindowBuffer();\n    // clear calls in this instance\n    this.calls = {};\n  };\n  PreInitMethodCallBuffer.prototype.toArray = function () {\n    var _a;\n    return (_a = []).concat.apply(_a, Object.values(this.calls));\n  };\n  /**\n   * Fetch the buffered method calls from the window object,\n   * normalize them, and use them to hydrate the buffer.\n   * This removes existing buffered calls from the window object.\n   */\n  PreInitMethodCallBuffer.prototype._pushSnippetWindowBuffer = function () {\n    var wa = getGlobalAnalytics();\n    if (!Array.isArray(wa)) return undefined;\n    var buffered = wa.splice(0, wa.length);\n    var calls = buffered.map(function (_a) {\n      var methodName = _a[0],\n        args = _a.slice(1);\n      return new PreInitMethodCall(methodName, args);\n    });\n    this.push.apply(this, calls);\n  };\n  return PreInitMethodCallBuffer;\n}();\nexport { PreInitMethodCallBuffer };\n/**\n *  Call method and mark as \"called\"\n *  This function should never throw an error\n */\nexport function callAnalyticsMethod(analytics, call) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, err_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 3,, 4]);\n          if (call.called) {\n            return [2 /*return*/, undefined];\n          }\n          call.called = true;\n          result = analytics[call.method].apply(analytics, call.args);\n          if (!isThenable(result)) return [3 /*break*/, 2];\n          // do not defer for non-async methods\n          return [4 /*yield*/, result];\n        case 1:\n          // do not defer for non-async methods\n          _a.sent();\n          _a.label = 2;\n        case 2:\n          call.resolve(result);\n          return [3 /*break*/, 4];\n        case 3:\n          err_1 = _a.sent();\n          call.reject(err_1);\n          return [3 /*break*/, 4];\n        case 4:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\nvar AnalyticsBuffered = /** @class */function () {\n  function AnalyticsBuffered(loader) {\n    var _this = this;\n    this.trackSubmit = this._createMethod('trackSubmit');\n    this.trackClick = this._createMethod('trackClick');\n    this.trackLink = this._createMethod('trackLink');\n    this.pageView = this._createMethod('pageview');\n    this.identify = this._createMethod('identify');\n    this.reset = this._createMethod('reset');\n    this.group = this._createMethod('group');\n    this.track = this._createMethod('track');\n    this.ready = this._createMethod('ready');\n    this.alias = this._createMethod('alias');\n    this.debug = this._createChainableMethod('debug');\n    this.page = this._createMethod('page');\n    this.once = this._createChainableMethod('once');\n    this.off = this._createChainableMethod('off');\n    this.on = this._createChainableMethod('on');\n    this.addSourceMiddleware = this._createMethod('addSourceMiddleware');\n    this.setAnonymousId = this._createMethod('setAnonymousId');\n    this.addDestinationMiddleware = this._createMethod('addDestinationMiddleware');\n    this.screen = this._createMethod('screen');\n    this.register = this._createMethod('register');\n    this.deregister = this._createMethod('deregister');\n    this.user = this._createMethod('user');\n    this.VERSION = version;\n    this._preInitBuffer = new PreInitMethodCallBuffer();\n    this._promise = loader(this._preInitBuffer);\n    this._promise.then(function (_a) {\n      var ajs = _a[0],\n        ctx = _a[1];\n      _this.instance = ajs;\n      _this.ctx = ctx;\n    }).catch(function () {\n      // intentionally do nothing...\n      // this result of this promise will be caught by the 'catch' block on this class.\n    });\n  }\n  AnalyticsBuffered.prototype.then = function () {\n    var _a;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return (_a = this._promise).then.apply(_a, args);\n  };\n  AnalyticsBuffered.prototype.catch = function () {\n    var _a;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return (_a = this._promise).catch.apply(_a, args);\n  };\n  AnalyticsBuffered.prototype.finally = function () {\n    var _a;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return (_a = this._promise).finally.apply(_a, args);\n  };\n  AnalyticsBuffered.prototype._createMethod = function (methodName) {\n    var _this = this;\n    return function () {\n      var _a;\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (_this.instance) {\n        var result = (_a = _this.instance)[methodName].apply(_a, args);\n        return Promise.resolve(result);\n      }\n      return new Promise(function (resolve, reject) {\n        _this._preInitBuffer.push(new PreInitMethodCall(methodName, args, resolve, reject));\n      });\n    };\n  };\n  /**\n   *  These are for methods that where determining when the method gets \"flushed\" is not important.\n   *  These methods will resolve when analytics is fully initialized, and return type (other than Analytics)will not be available.\n   */\n  AnalyticsBuffered.prototype._createChainableMethod = function (methodName) {\n    var _this = this;\n    return function () {\n      var _a;\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (_this.instance) {\n        void (_a = _this.instance)[methodName].apply(_a, args);\n        return _this;\n      } else {\n        _this._preInitBuffer.push(new PreInitMethodCall(methodName, args));\n      }\n      return _this;\n    };\n  };\n  return AnalyticsBuffered;\n}();\nexport { AnalyticsBuffered };","map":{"version":3,"names":["isThenable","version","getGlobalAnalytics","isBufferedPageContext","getDefaultBufferedPageContext","createPageContext","flushSyncAnalyticsCalls","name","analytics","buffer","getCalls","forEach","c","callAnalyticsMethod","catch","console","error","flushAddSourceMiddleware","__awaiter","_a","_i","length","_b","sent","flushOn","bind","flushSetAnonymousID","flushAnalyticsCallsInNewTask","toArray","m","setTimeout","popPageContext","args","hasBufferedPageContextAsLastArg","ctx","pop","lastArg","PreInitMethodCall","method","resolve","reject","called","PreInitMethodCallBuffer","calls","arguments","_callMap","push","apply","Object","defineProperty","prototype","get","_pushSnippetWindowBuffer","set","methodName","_this","call","eventsExpectingPageContext","includes","__spreadArray","clear","concat","values","wa","Array","isArray","undefined","buffered","splice","map","slice","result","err_1","AnalyticsBuffered","loader","trackSubmit","_createMethod","trackClick","trackLink","pageView","identify","reset","group","track","ready","alias","debug","_createChainableMethod","page","once","off","on","addSourceMiddleware","setAnonymousId","addDestinationMiddleware","screen","register","deregister","user","VERSION","_preInitBuffer","_promise","then","ajs","instance","finally","Promise"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/analytics-next/src/core/buffer/index.ts"],"sourcesContent":["import { Analytics } from '../analytics'\nimport { Context } from '../context'\nimport { isThenable } from '../../lib/is-thenable'\nimport { AnalyticsBrowserCore } from '../analytics/interfaces'\nimport { version } from '../../generated/version'\nimport { getGlobalAnalytics } from '../../lib/global-analytics-helper'\nimport {\n  isBufferedPageContext,\n  BufferedPageContext,\n  getDefaultBufferedPageContext,\n  createPageContext,\n  PageContext,\n} from '../page'\n\n/**\n * The names of any AnalyticsBrowser methods that also exist on Analytics\n */\nexport type PreInitMethodName =\n  | 'screen'\n  | 'register'\n  | 'deregister'\n  | 'user'\n  | 'trackSubmit'\n  | 'trackClick'\n  | 'trackLink'\n  | 'trackForm'\n  | 'pageview'\n  | 'identify'\n  | 'reset'\n  | 'group'\n  | 'track'\n  | 'ready'\n  | 'alias'\n  | 'debug'\n  | 'page'\n  | 'once'\n  | 'off'\n  | 'on'\n  | 'addSourceMiddleware'\n  | 'setAnonymousId'\n  | 'addDestinationMiddleware'\n\n// Union of all analytics methods that _do not_ return a Promise\ntype SyncPreInitMethodName = {\n  [MethodName in PreInitMethodName]: ReturnType<\n    Analytics[MethodName]\n  > extends Promise<any>\n    ? never\n    : MethodName\n}[PreInitMethodName]\n\nconst flushSyncAnalyticsCalls = (\n  name: SyncPreInitMethodName,\n  analytics: Analytics,\n  buffer: PreInitMethodCallBuffer\n): void => {\n  buffer.getCalls(name).forEach((c) => {\n    // While the underlying methods are synchronous, the callAnalyticsMethod returns a promise,\n    // which normalizes success and error states between async and non-async methods, with no perf penalty.\n    callAnalyticsMethod(analytics, c).catch(console.error)\n  })\n}\n\nexport const flushAddSourceMiddleware = async (\n  analytics: Analytics,\n  buffer: PreInitMethodCallBuffer\n) => {\n  for (const c of buffer.getCalls('addSourceMiddleware')) {\n    await callAnalyticsMethod(analytics, c).catch(console.error)\n  }\n}\n\nexport const flushOn = flushSyncAnalyticsCalls.bind(this, 'on')\n\nexport const flushSetAnonymousID = flushSyncAnalyticsCalls.bind(\n  this,\n  'setAnonymousId'\n)\n\nexport const flushAnalyticsCallsInNewTask = (\n  analytics: Analytics,\n  buffer: PreInitMethodCallBuffer\n): void => {\n  buffer.toArray().forEach((m) => {\n    setTimeout(() => {\n      callAnalyticsMethod(analytics, m).catch(console.error)\n    }, 0)\n  })\n}\n\nexport const popPageContext = (args: unknown[]): PageContext | undefined => {\n  if (hasBufferedPageContextAsLastArg(args)) {\n    const ctx = args.pop() as BufferedPageContext\n    return createPageContext(ctx)\n  }\n}\n\nexport const hasBufferedPageContextAsLastArg = (\n  args: unknown[]\n): args is [...unknown[], BufferedPageContext] | [BufferedPageContext] => {\n  const lastArg = args[args.length - 1]\n  return isBufferedPageContext(lastArg)\n}\n\n/**\n *  Represents a buffered method call that occurred before initialization.\n */\nexport class PreInitMethodCall<\n  MethodName extends PreInitMethodName = PreInitMethodName\n> {\n  method: MethodName\n  args: PreInitMethodParams<MethodName>\n  called: boolean\n  resolve: (v: ReturnType<Analytics[MethodName]>) => void\n  reject: (reason: any) => void\n  constructor(\n    method: PreInitMethodCall<MethodName>['method'],\n    args: PreInitMethodParams<MethodName>,\n    resolve: PreInitMethodCall<MethodName>['resolve'] = () => {},\n    reject: PreInitMethodCall<MethodName>['reject'] = console.error\n  ) {\n    this.method = method\n    this.resolve = resolve\n    this.reject = reject\n    this.called = false\n    this.args = args\n  }\n}\n\nexport type PreInitMethodParams<MethodName extends PreInitMethodName> =\n  | [...Parameters<Analytics[MethodName]>, BufferedPageContext]\n  | Parameters<Analytics[MethodName]>\n\n/**\n * Infer return type; if return type is promise, unwrap it.\n */\ntype ReturnTypeUnwrap<Fn> = Fn extends (...args: any[]) => infer ReturnT\n  ? ReturnT extends PromiseLike<infer Unwrapped>\n    ? Unwrapped\n    : ReturnT\n  : never\n\ntype MethodCallMap = Partial<Record<PreInitMethodName, PreInitMethodCall[]>>\n\ntype SnippetWindowBufferedMethodCall<\n  MethodName extends PreInitMethodName = PreInitMethodName\n> = [MethodName, ...PreInitMethodParams<MethodName>]\n\n/**\n * A list of the method calls before initialization for snippet users\n * For example, [[\"track\", \"foo\", {bar: 123}], [\"page\"], [\"on\", \"ready\", function(){..}]\n */\ntype SnippetBuffer = SnippetWindowBufferedMethodCall[]\n\n/**\n *  Represents any and all the buffered method calls that occurred before initialization.\n */\nexport class PreInitMethodCallBuffer {\n  private _callMap: MethodCallMap = {}\n\n  constructor(...calls: PreInitMethodCall[]) {\n    this.push(...calls)\n  }\n\n  /**\n   * Pull any buffered method calls from the window object, and use them to hydrate the instance buffer.\n   */\n  private get calls() {\n    this._pushSnippetWindowBuffer()\n    return this._callMap\n  }\n\n  private set calls(calls: MethodCallMap) {\n    this._callMap = calls\n  }\n\n  getCalls<T extends PreInitMethodName>(methodName: T): PreInitMethodCall<T>[] {\n    return (this.calls[methodName] ?? []) as PreInitMethodCall<T>[]\n  }\n\n  push(...calls: PreInitMethodCall[]): void {\n    calls.forEach((call) => {\n      const eventsExpectingPageContext: PreInitMethodName[] = [\n        'track',\n        'screen',\n        'alias',\n        'group',\n        'page',\n        'identify',\n      ]\n      if (\n        eventsExpectingPageContext.includes(call.method) &&\n        !hasBufferedPageContextAsLastArg(call.args)\n      ) {\n        call.args = [...call.args, getDefaultBufferedPageContext()]\n      }\n\n      if (this.calls[call.method]) {\n        this.calls[call.method]!.push(call)\n      } else {\n        this.calls[call.method] = [call]\n      }\n    })\n  }\n\n  clear(): void {\n    // clear calls in the global snippet buffered array.\n    this._pushSnippetWindowBuffer()\n    // clear calls in this instance\n    this.calls = {}\n  }\n\n  toArray(): PreInitMethodCall[] {\n    return ([] as PreInitMethodCall[]).concat(...Object.values(this.calls))\n  }\n\n  /**\n   * Fetch the buffered method calls from the window object,\n   * normalize them, and use them to hydrate the buffer.\n   * This removes existing buffered calls from the window object.\n   */\n  private _pushSnippetWindowBuffer(): void {\n    const wa = getGlobalAnalytics()\n    if (!Array.isArray(wa)) return undefined\n    const buffered: SnippetBuffer = wa.splice(0, wa.length)\n    const calls = buffered.map(\n      ([methodName, ...args]) => new PreInitMethodCall(methodName, args)\n    )\n    this.push(...calls)\n  }\n}\n\n/**\n *  Call method and mark as \"called\"\n *  This function should never throw an error\n */\nexport async function callAnalyticsMethod<T extends PreInitMethodName>(\n  analytics: Analytics,\n  call: PreInitMethodCall<T>\n): Promise<void> {\n  try {\n    if (call.called) {\n      return undefined\n    }\n    call.called = true\n\n    const result: ReturnType<Analytics[T]> = (\n      analytics[call.method] as Function\n    )(...call.args)\n\n    if (isThenable(result)) {\n      // do not defer for non-async methods\n      await result\n    }\n\n    call.resolve(result)\n  } catch (err) {\n    call.reject(err)\n  }\n}\n\nexport type AnalyticsLoader = (\n  preInitBuffer: PreInitMethodCallBuffer\n) => Promise<[Analytics, Context]>\n\nexport class AnalyticsBuffered\n  implements PromiseLike<[Analytics, Context]>, AnalyticsBrowserCore\n{\n  instance?: Analytics\n  ctx?: Context\n  private _preInitBuffer: PreInitMethodCallBuffer\n  private _promise: Promise<[Analytics, Context]>\n  constructor(loader: AnalyticsLoader) {\n    this._preInitBuffer = new PreInitMethodCallBuffer()\n    this._promise = loader(this._preInitBuffer)\n    this._promise\n      .then(([ajs, ctx]) => {\n        this.instance = ajs\n        this.ctx = ctx\n      })\n      .catch(() => {\n        // intentionally do nothing...\n        // this result of this promise will be caught by the 'catch' block on this class.\n      })\n  }\n\n  then<T1, T2 = never>(\n    ...args: [\n      onfulfilled:\n        | ((instance: [Analytics, Context]) => T1 | PromiseLike<T1>)\n        | null\n        | undefined,\n      onrejected?: (reason: unknown) => T2 | PromiseLike<T2>\n    ]\n  ) {\n    return this._promise.then(...args)\n  }\n\n  catch<TResult = never>(\n    ...args: [\n      onrejected?:\n        | ((reason: any) => TResult | PromiseLike<TResult>)\n        | undefined\n        | null\n    ]\n  ) {\n    return this._promise.catch(...args)\n  }\n\n  finally(...args: [onfinally?: (() => void) | undefined | null]) {\n    return this._promise.finally(...args)\n  }\n\n  trackSubmit = this._createMethod('trackSubmit')\n  trackClick = this._createMethod('trackClick')\n  trackLink = this._createMethod('trackLink')\n  pageView = this._createMethod('pageview')\n  identify = this._createMethod('identify')\n  reset = this._createMethod('reset')\n  group = this._createMethod('group') as AnalyticsBrowserCore['group']\n  track = this._createMethod('track')\n  ready = this._createMethod('ready')\n  alias = this._createMethod('alias')\n  debug = this._createChainableMethod('debug')\n  page = this._createMethod('page')\n  once = this._createChainableMethod('once')\n  off = this._createChainableMethod('off')\n  on = this._createChainableMethod('on')\n  addSourceMiddleware = this._createMethod('addSourceMiddleware')\n  setAnonymousId = this._createMethod('setAnonymousId')\n  addDestinationMiddleware = this._createMethod('addDestinationMiddleware')\n\n  screen = this._createMethod('screen')\n  register = this._createMethod('register')\n  deregister = this._createMethod('deregister')\n  user = this._createMethod('user')\n  readonly VERSION = version\n\n  private _createMethod<T extends PreInitMethodName>(methodName: T) {\n    return (\n      ...args: Parameters<Analytics[T]>\n    ): Promise<ReturnTypeUnwrap<Analytics[T]>> => {\n      if (this.instance) {\n        const result = (this.instance[methodName] as Function)(...args)\n        return Promise.resolve(result)\n      }\n      return new Promise((resolve, reject) => {\n        this._preInitBuffer.push(\n          new PreInitMethodCall(methodName, args, resolve as any, reject)\n        )\n      })\n    }\n  }\n\n  /**\n   *  These are for methods that where determining when the method gets \"flushed\" is not important.\n   *  These methods will resolve when analytics is fully initialized, and return type (other than Analytics)will not be available.\n   */\n  private _createChainableMethod<T extends PreInitMethodName>(methodName: T) {\n    return (...args: Parameters<Analytics[T]>): AnalyticsBuffered => {\n      if (this.instance) {\n        void (this.instance[methodName] as Function)(...args)\n        return this\n      } else {\n        this._preInitBuffer.push(new PreInitMethodCall(methodName, args))\n      }\n\n      return this\n    }\n  }\n}\n"],"mappings":";AAEA,SAASA,UAAU,QAAQ,uBAAuB;AAElD,SAASC,OAAO,QAAQ,yBAAyB;AACjD,SAASC,kBAAkB,QAAQ,mCAAmC;AACtE,SACEC,qBAAqB,EAErBC,6BAA6B,EAC7BC,iBAAiB,QAEZ,SAAS;AAuChB,IAAMC,uBAAuB,GAAG,SAAAA,CAC9BC,IAA2B,EAC3BC,SAAoB,EACpBC,MAA+B;EAE/BA,MAAM,CAACC,QAAQ,CAACH,IAAI,CAAC,CAACI,OAAO,CAAC,UAACC,CAAC;IAC9B;IACA;IACAC,mBAAmB,CAACL,SAAS,EAAEI,CAAC,CAAC,CAACE,KAAK,CAACC,OAAO,CAACC,KAAK,CAAC;EACxD,CAAC,CAAC;AACJ,CAAC;AAED,OAAO,IAAMC,wBAAwB,GAAG,SAAAA,CACtCT,SAAoB,EACpBC,MAA+B;EAAA,OAAAS,SAAA;;;;;gBAEuB,EAAtCC,EAAA,GAAAV,MAAM,CAACC,QAAQ,CAAC,qBAAqB,CAAC;;;gBAAtCU,EAAA,GAAAD,EAAA,CAAAE,MAAsC;UAA3CT,CAAC,GAAAO,EAAA,CAAAC,EAAA;UACV,qBAAMP,mBAAmB,CAACL,SAAS,EAAEI,CAAC,CAAC,CAACE,KAAK,CAACC,OAAO,CAACC,KAAK,CAAC;;UAA5DM,EAAA,CAAAC,IAAA,EAA4D;;;UAD9CH,EAAA,EAAsC;;;;;;;CAGvD;AAED,OAAO,IAAMI,OAAO,GAAGlB,uBAAuB,CAACmB,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;AAE/D,OAAO,IAAMC,mBAAmB,GAAGpB,uBAAuB,CAACmB,IAAI,CAC7D,IAAI,EACJ,gBAAgB,CACjB;AAED,OAAO,IAAME,4BAA4B,GAAG,SAAAA,CAC1CnB,SAAoB,EACpBC,MAA+B;EAE/BA,MAAM,CAACmB,OAAO,EAAE,CAACjB,OAAO,CAAC,UAACkB,CAAC;IACzBC,UAAU,CAAC;MACTjB,mBAAmB,CAACL,SAAS,EAAEqB,CAAC,CAAC,CAACf,KAAK,CAACC,OAAO,CAACC,KAAK,CAAC;IACxD,CAAC,EAAE,CAAC,CAAC;EACP,CAAC,CAAC;AACJ,CAAC;AAED,OAAO,IAAMe,cAAc,GAAG,SAAAA,CAACC,IAAe;EAC5C,IAAIC,+BAA+B,CAACD,IAAI,CAAC,EAAE;IACzC,IAAME,GAAG,GAAGF,IAAI,CAACG,GAAG,EAAyB;IAC7C,OAAO9B,iBAAiB,CAAC6B,GAAG,CAAC;;AAEjC,CAAC;AAED,OAAO,IAAMD,+BAA+B,GAAG,SAAAA,CAC7CD,IAAe;EAEf,IAAMI,OAAO,GAAGJ,IAAI,CAACA,IAAI,CAACX,MAAM,GAAG,CAAC,CAAC;EACrC,OAAOlB,qBAAqB,CAACiC,OAAO,CAAC;AACvC,CAAC;AAED;;;AAGA,IAAAC,iBAAA;EAQE,SAAAA,kBACEC,MAA+C,EAC/CN,IAAqC,EACrCO,OAA4D,EAC5DC,MAA+D;IAD/D,IAAAD,OAAA;MAAAA,OAAA,YAAAA,CAAA,GAA2D,CAAC;IAAA;IAC5D,IAAAC,MAAA;MAAAA,MAAA,GAAkDzB,OAAO,CAACC,KAAK;IAAA;IAE/D,IAAI,CAACsB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACT,IAAI,GAAGA,IAAI;EAClB;EACF,OAAAK,iBAAC;AAAD,CAAC,CApBD;;AA+CA;;;AAGA,IAAAK,uBAAA;EAGE,SAAAA,wBAAA;IAAY,IAAAC,KAAA;SAAA,IAAAvB,EAAA,IAA6B,EAA7BA,EAAA,GAAAwB,SAAA,CAAAvB,MAA6B,EAA7BD,EAAA,EAA6B;MAA7BuB,KAAA,CAAAvB,EAAA,IAAAwB,SAAA,CAAAxB,EAAA;;IAFJ,KAAAyB,QAAQ,GAAkB,EAAE;IAGlC,IAAI,CAACC,IAAI,CAAAC,KAAA,CAAT,IAAI,EAASJ,KAAK;EACpB;EAKAK,MAAA,CAAAC,cAAA,CAAYP,uBAAA,CAAAQ,SAAA,SAAK;IAHjB;;;SAGA,SAAAC,CAAA;MACE,IAAI,CAACC,wBAAwB,EAAE;MAC/B,OAAO,IAAI,CAACP,QAAQ;IACtB,CAAC;SAED,SAAAQ,CAAkBV,KAAoB;MACpC,IAAI,CAACE,QAAQ,GAAGF,KAAK;IACvB,CAAC;;;;EAEDD,uBAAA,CAAAQ,SAAA,CAAAxC,QAAQ,GAAR,UAAsC4C,UAAa;;IACjD,OAAQ,CAAAnC,EAAA,OAAI,CAACwB,KAAK,CAACW,UAAU,CAAC,cAAAnC,EAAA,cAAAA,EAAA,GAAI,EAAE;EACtC,CAAC;EAEDuB,uBAAA,CAAAQ,SAAA,CAAAJ,IAAI,GAAJ;IAAA,IAAAS,KAAA;IAAK,IAAAZ,KAAA;SAAA,IAAAvB,EAAA,IAA6B,EAA7BA,EAAA,GAAAwB,SAAA,CAAAvB,MAA6B,EAA7BD,EAAA,EAA6B;MAA7BuB,KAAA,CAAAvB,EAAA,IAAAwB,SAAA,CAAAxB,EAAA;;IACHuB,KAAK,CAAChC,OAAO,CAAC,UAAC6C,IAAI;MACjB,IAAMC,0BAA0B,GAAwB,CACtD,OAAO,EACP,QAAQ,EACR,OAAO,EACP,OAAO,EACP,MAAM,EACN,UAAU,CACX;MACD,IACEA,0BAA0B,CAACC,QAAQ,CAACF,IAAI,CAAClB,MAAM,CAAC,IAChD,CAACL,+BAA+B,CAACuB,IAAI,CAACxB,IAAI,CAAC,EAC3C;QACAwB,IAAI,CAACxB,IAAI,GAAA2B,aAAA,CAAAA,aAAA,KAAOH,IAAI,CAACxB,IAAI,UAAE5B,6BAA6B,EAAE,SAAC;;MAG7D,IAAImD,KAAI,CAACZ,KAAK,CAACa,IAAI,CAAClB,MAAM,CAAC,EAAE;QAC3BiB,KAAI,CAACZ,KAAK,CAACa,IAAI,CAAClB,MAAM,CAAE,CAACQ,IAAI,CAACU,IAAI,CAAC;OACpC,MAAM;QACLD,KAAI,CAACZ,KAAK,CAACa,IAAI,CAAClB,MAAM,CAAC,GAAG,CAACkB,IAAI,CAAC;;IAEpC,CAAC,CAAC;EACJ,CAAC;EAEDd,uBAAA,CAAAQ,SAAA,CAAAU,KAAK,GAAL;IACE;IACA,IAAI,CAACR,wBAAwB,EAAE;IAC/B;IACA,IAAI,CAACT,KAAK,GAAG,EAAE;EACjB,CAAC;EAEDD,uBAAA,CAAAQ,SAAA,CAAAtB,OAAO,GAAP;;IACE,OAAO,CAAAT,EAAA,GAAC,EAA0B,EAAC0C,MAAM,CAAAd,KAAA,CAAA5B,EAAA,EAAI6B,MAAM,CAACc,MAAM,CAAC,IAAI,CAACnB,KAAK,CAAC;EACxE,CAAC;EAED;;;;;EAKQD,uBAAA,CAAAQ,SAAA,CAAAE,wBAAwB,GAAhC;IACE,IAAMW,EAAE,GAAG7D,kBAAkB,EAAE;IAC/B,IAAI,CAAC8D,KAAK,CAACC,OAAO,CAACF,EAAE,CAAC,EAAE,OAAOG,SAAS;IACxC,IAAMC,QAAQ,GAAkBJ,EAAE,CAACK,MAAM,CAAC,CAAC,EAAEL,EAAE,CAAC1C,MAAM,CAAC;IACvD,IAAMsB,KAAK,GAAGwB,QAAQ,CAACE,GAAG,CACxB,UAAClD,EAAqB;UAApBmC,UAAU,GAAAnC,EAAA;QAAKa,IAAI,GAAAb,EAAA,CAAAmD,KAAA;MAAM,WAAIjC,iBAAiB,CAACiB,UAAU,EAAEtB,IAAI,CAAC;IAAvC,CAAuC,CACnE;IACD,IAAI,CAACc,IAAI,CAAAC,KAAA,CAAT,IAAI,EAASJ,KAAK;EACpB,CAAC;EACH,OAAAD,uBAAC;AAAD,CAAC,CAzED;;AA2EA;;;;AAIA,OAAM,SAAgB7B,mBAAmBA,CACvCL,SAAoB,EACpBgD,IAA0B;;;;;;;UAGxB,IAAIA,IAAI,CAACf,MAAM,EAAE;YACf,sBAAOyB,SAAS;;UAElBV,IAAI,CAACf,MAAM,GAAG,IAAI;UAEZ8B,MAAM,GACV/D,SAAS,CAACgD,IAAI,CAAClB,MAAM,CAAC,CAAAS,KAAA,CAAtBvC,SAAS,EACNgD,IAAI,CAACxB,IAAI,CAAC;eAEXhC,UAAU,CAACuE,MAAM,CAAC,EAAlB;UACF;UACA,qBAAMA,MAAM;;UADZ;UACApD,EAAA,CAAAI,IAAA,EAAY;;;UAGdiC,IAAI,CAACjB,OAAO,CAACgC,MAAM,CAAC;;;;UAEpBf,IAAI,CAAChB,MAAM,CAACgC,KAAG,CAAC;;;;;;;;AAQpB,IAAAC,iBAAA;EAOE,SAAAA,kBAAYC,MAAuB;IAAnC,IAAAnB,KAAA;IAyCA,KAAAoB,WAAW,GAAG,IAAI,CAACC,aAAa,CAAC,aAAa,CAAC;IAC/C,KAAAC,UAAU,GAAG,IAAI,CAACD,aAAa,CAAC,YAAY,CAAC;IAC7C,KAAAE,SAAS,GAAG,IAAI,CAACF,aAAa,CAAC,WAAW,CAAC;IAC3C,KAAAG,QAAQ,GAAG,IAAI,CAACH,aAAa,CAAC,UAAU,CAAC;IACzC,KAAAI,QAAQ,GAAG,IAAI,CAACJ,aAAa,CAAC,UAAU,CAAC;IACzC,KAAAK,KAAK,GAAG,IAAI,CAACL,aAAa,CAAC,OAAO,CAAC;IACnC,KAAAM,KAAK,GAAG,IAAI,CAACN,aAAa,CAAC,OAAO,CAAkC;IACpE,KAAAO,KAAK,GAAG,IAAI,CAACP,aAAa,CAAC,OAAO,CAAC;IACnC,KAAAQ,KAAK,GAAG,IAAI,CAACR,aAAa,CAAC,OAAO,CAAC;IACnC,KAAAS,KAAK,GAAG,IAAI,CAACT,aAAa,CAAC,OAAO,CAAC;IACnC,KAAAU,KAAK,GAAG,IAAI,CAACC,sBAAsB,CAAC,OAAO,CAAC;IAC5C,KAAAC,IAAI,GAAG,IAAI,CAACZ,aAAa,CAAC,MAAM,CAAC;IACjC,KAAAa,IAAI,GAAG,IAAI,CAACF,sBAAsB,CAAC,MAAM,CAAC;IAC1C,KAAAG,GAAG,GAAG,IAAI,CAACH,sBAAsB,CAAC,KAAK,CAAC;IACxC,KAAAI,EAAE,GAAG,IAAI,CAACJ,sBAAsB,CAAC,IAAI,CAAC;IACtC,KAAAK,mBAAmB,GAAG,IAAI,CAAChB,aAAa,CAAC,qBAAqB,CAAC;IAC/D,KAAAiB,cAAc,GAAG,IAAI,CAACjB,aAAa,CAAC,gBAAgB,CAAC;IACrD,KAAAkB,wBAAwB,GAAG,IAAI,CAAClB,aAAa,CAAC,0BAA0B,CAAC;IAEzE,KAAAmB,MAAM,GAAG,IAAI,CAACnB,aAAa,CAAC,QAAQ,CAAC;IACrC,KAAAoB,QAAQ,GAAG,IAAI,CAACpB,aAAa,CAAC,UAAU,CAAC;IACzC,KAAAqB,UAAU,GAAG,IAAI,CAACrB,aAAa,CAAC,YAAY,CAAC;IAC7C,KAAAsB,IAAI,GAAG,IAAI,CAACtB,aAAa,CAAC,MAAM,CAAC;IACxB,KAAAuB,OAAO,GAAGlG,OAAO;IA/DxB,IAAI,CAACmG,cAAc,GAAG,IAAI1D,uBAAuB,EAAE;IACnD,IAAI,CAAC2D,QAAQ,GAAG3B,MAAM,CAAC,IAAI,CAAC0B,cAAc,CAAC;IAC3C,IAAI,CAACC,QAAQ,CACVC,IAAI,CAAC,UAACnF,EAAU;UAAToF,GAAG,GAAApF,EAAA;QAAEe,GAAG,GAAAf,EAAA;MACdoC,KAAI,CAACiD,QAAQ,GAAGD,GAAG;MACnBhD,KAAI,CAACrB,GAAG,GAAGA,GAAG;IAChB,CAAC,CAAC,CACDpB,KAAK,CAAC;MACL;MACA;IAAA,CACD,CAAC;EACN;EAEA2D,iBAAA,CAAAvB,SAAA,CAAAoD,IAAI,GAAJ;;IACE,IAAAtE,IAAA;SAAA,IAAAZ,EAAA,IAMC,EANDA,EAAA,GAAAwB,SAAA,CAAAvB,MAMC,EANDD,EAAA,EAMC;MANDY,IAAA,CAAAZ,EAAA,IAAAwB,SAAA,CAAAxB,EAAA;;IAQA,OAAO,CAAAD,EAAA,OAAI,CAACkF,QAAQ,EAACC,IAAI,CAAAvD,KAAA,CAAA5B,EAAA,EAAIa,IAAI;EACnC,CAAC;EAEDyC,iBAAA,CAAAvB,SAAA,CAAApC,KAAK,GAAL;;IACE,IAAAkB,IAAA;SAAA,IAAAZ,EAAA,IAKC,EALDA,EAAA,GAAAwB,SAAA,CAAAvB,MAKC,EALDD,EAAA,EAKC;MALDY,IAAA,CAAAZ,EAAA,IAAAwB,SAAA,CAAAxB,EAAA;;IAOA,OAAO,CAAAD,EAAA,OAAI,CAACkF,QAAQ,EAACvF,KAAK,CAAAiC,KAAA,CAAA5B,EAAA,EAAIa,IAAI;EACpC,CAAC;EAEDyC,iBAAA,CAAAvB,SAAA,CAAAuD,OAAO,GAAP;;IAAQ,IAAAzE,IAAA;SAAA,IAAAZ,EAAA,IAAsD,EAAtDA,EAAA,GAAAwB,SAAA,CAAAvB,MAAsD,EAAtDD,EAAA,EAAsD;MAAtDY,IAAA,CAAAZ,EAAA,IAAAwB,SAAA,CAAAxB,EAAA;;IACN,OAAO,CAAAD,EAAA,OAAI,CAACkF,QAAQ,EAACI,OAAO,CAAA1D,KAAA,CAAA5B,EAAA,EAAIa,IAAI;EACtC,CAAC;EA2BOyC,iBAAA,CAAAvB,SAAA,CAAA0B,aAAa,GAArB,UAAmDtB,UAAa;IAAhE,IAAAC,KAAA;IACE,OAAO;;MACL,IAAAvB,IAAA;WAAA,IAAAZ,EAAA,IAAiC,EAAjCA,EAAA,GAAAwB,SAAA,CAAAvB,MAAiC,EAAjCD,EAAA,EAAiC;QAAjCY,IAAA,CAAAZ,EAAA,IAAAwB,SAAA,CAAAxB,EAAA;;MAEA,IAAImC,KAAI,CAACiD,QAAQ,EAAE;QACjB,IAAMjC,MAAM,GAAI,CAAApD,EAAA,GAAAoC,KAAI,CAACiD,QAAQ,EAAClD,UAAU,CAAC,CAAAP,KAAA,CAAA5B,EAAA,EAAiBa,IAAI,CAAC;QAC/D,OAAO0E,OAAO,CAACnE,OAAO,CAACgC,MAAM,CAAC;;MAEhC,OAAO,IAAImC,OAAO,CAAC,UAACnE,OAAO,EAAEC,MAAM;QACjCe,KAAI,CAAC6C,cAAc,CAACtD,IAAI,CACtB,IAAIT,iBAAiB,CAACiB,UAAU,EAAEtB,IAAI,EAAEO,OAAc,EAAEC,MAAM,CAAC,CAChE;MACH,CAAC,CAAC;IACJ,CAAC;EACH,CAAC;EAED;;;;EAIQiC,iBAAA,CAAAvB,SAAA,CAAAqC,sBAAsB,GAA9B,UAA4DjC,UAAa;IAAzE,IAAAC,KAAA;IACE,OAAO;;MAAC,IAAAvB,IAAA;WAAA,IAAAZ,EAAA,IAAiC,EAAjCA,EAAA,GAAAwB,SAAA,CAAAvB,MAAiC,EAAjCD,EAAA,EAAiC;QAAjCY,IAAA,CAAAZ,EAAA,IAAAwB,SAAA,CAAAxB,EAAA;;MACN,IAAImC,KAAI,CAACiD,QAAQ,EAAE;QACjB,KAAM,CAAArF,EAAA,GAAAoC,KAAI,CAACiD,QAAQ,EAAClD,UAAU,CAAC,CAAAP,KAAA,CAAA5B,EAAA,EAAiBa,IAAI,CAAC;QACrD,OAAOuB,KAAI;OACZ,MAAM;QACLA,KAAI,CAAC6C,cAAc,CAACtD,IAAI,CAAC,IAAIT,iBAAiB,CAACiB,UAAU,EAAEtB,IAAI,CAAC,CAAC;;MAGnE,OAAOuB,KAAI;IACb,CAAC;EACH,CAAC;EACH,OAAAkB,iBAAC;AAAD,CAAC,CAzGD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}