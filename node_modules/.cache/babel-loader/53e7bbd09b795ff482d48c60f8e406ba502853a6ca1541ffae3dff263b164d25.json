{"ast":null,"code":"var identity = function (_) {\n  return _;\n};\n\n/**\n * Module exports, export\n */\n\nmodule.exports = multiple(find);\nmodule.exports.find = module.exports;\n\n/**\n * Export the replacement function, return the modified object\n */\n\nmodule.exports.replace = function (obj, key, val, options) {\n  multiple(replace).call(this, obj, key, val, options);\n  return obj;\n};\n\n/**\n * Export the delete function, return the modified object\n */\n\nmodule.exports.del = function (obj, key, options) {\n  multiple(del).call(this, obj, key, null, options);\n  return obj;\n};\n\n/**\n * Compose applying the function to a nested key\n */\n\nfunction multiple(fn) {\n  return function (obj, path, val, options) {\n    var normalize = options && isFunction(options.normalizer) ? options.normalizer : defaultNormalize;\n    path = normalize(path);\n    var key;\n    var finished = false;\n    while (!finished) loop();\n    function loop() {\n      for (key in obj) {\n        var normalizedKey = normalize(key);\n        if (0 === path.indexOf(normalizedKey)) {\n          var temp = path.substr(normalizedKey.length);\n          if (temp.charAt(0) === '.' || temp.length === 0) {\n            path = temp.substr(1);\n            var child = obj[key];\n\n            // we're at the end and there is nothing.\n            if (null == child) {\n              finished = true;\n              return;\n            }\n\n            // we're at the end and there is something.\n            if (!path.length) {\n              finished = true;\n              return;\n            }\n\n            // step into child\n            obj = child;\n\n            // but we're done here\n            return;\n          }\n        }\n      }\n      key = undefined;\n      // if we found no matching properties\n      // on the current object, there's no match.\n      finished = true;\n    }\n    if (!key) return;\n    if (null == obj) return obj;\n\n    // the `obj` and `key` is one above the leaf object and key, so\n    // start object: { a: { 'b.c': 10 } }\n    // end object: { 'b.c': 10 }\n    // end key: 'b.c'\n    // this way, you can do `obj[key]` and get `10`.\n    return fn(obj, key, val);\n  };\n}\n\n/**\n * Find an object by its key\n *\n * find({ first_name : 'Calvin' }, 'firstName')\n */\n\nfunction find(obj, key) {\n  if (obj.hasOwnProperty(key)) return obj[key];\n}\n\n/**\n * Delete a value for a given key\n *\n * del({ a : 'b', x : 'y' }, 'X' }) -> { a : 'b' }\n */\n\nfunction del(obj, key) {\n  if (obj.hasOwnProperty(key)) delete obj[key];\n  return obj;\n}\n\n/**\n * Replace an objects existing value with a new one\n *\n * replace({ a : 'b' }, 'a', 'c') -> { a : 'c' }\n */\n\nfunction replace(obj, key, val) {\n  if (obj.hasOwnProperty(key)) obj[key] = val;\n  return obj;\n}\n\n/**\n * Normalize a `dot.separated.path`.\n *\n * A.HELL(!*&#(!)O_WOR   LD.bar => ahelloworldbar\n *\n * @param {String} path\n * @return {String}\n */\n\nfunction defaultNormalize(path) {\n  return path.replace(/[^a-zA-Z0-9\\.]+/g, '').toLowerCase();\n}\n\n/**\n * Check if a value is a function.\n *\n * @param {*} val\n * @return {boolean} Returns `true` if `val` is a function, otherwise `false`.\n */\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}","map":{"version":3,"names":["identity","_","module","exports","multiple","find","replace","obj","key","val","options","call","del","fn","path","normalize","isFunction","normalizer","defaultNormalize","finished","loop","normalizedKey","indexOf","temp","substr","length","charAt","child","undefined","hasOwnProperty","toLowerCase"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/obj-case/index.js"],"sourcesContent":["\nvar identity = function(_){ return _; };\n\n\n/**\n * Module exports, export\n */\n\nmodule.exports = multiple(find);\nmodule.exports.find = module.exports;\n\n\n/**\n * Export the replacement function, return the modified object\n */\n\nmodule.exports.replace = function (obj, key, val, options) {\n  multiple(replace).call(this, obj, key, val, options);\n  return obj;\n};\n\n\n/**\n * Export the delete function, return the modified object\n */\n\nmodule.exports.del = function (obj, key, options) {\n  multiple(del).call(this, obj, key, null, options);\n  return obj;\n};\n\n\n/**\n * Compose applying the function to a nested key\n */\n\nfunction multiple (fn) {\n  return function (obj, path, val, options) {\n    var normalize = options && isFunction(options.normalizer) ? options.normalizer : defaultNormalize;\n    path = normalize(path);\n\n    var key;\n    var finished = false;\n\n    while (!finished) loop();\n\n    function loop() {\n      for (key in obj) {\n        var normalizedKey = normalize(key);\n        if (0 === path.indexOf(normalizedKey)) {\n          var temp = path.substr(normalizedKey.length);\n          if (temp.charAt(0) === '.' || temp.length === 0) {\n            path = temp.substr(1);\n            var child = obj[key];\n\n            // we're at the end and there is nothing.\n            if (null == child) {\n              finished = true;\n              return;\n            }\n\n            // we're at the end and there is something.\n            if (!path.length) {\n              finished = true;\n              return;\n            }\n\n            // step into child\n            obj = child;\n\n            // but we're done here\n            return;\n          }\n        }\n      }\n\n      key = undefined;\n      // if we found no matching properties\n      // on the current object, there's no match.\n      finished = true;\n    }\n\n    if (!key) return;\n    if (null == obj) return obj;\n\n    // the `obj` and `key` is one above the leaf object and key, so\n    // start object: { a: { 'b.c': 10 } }\n    // end object: { 'b.c': 10 }\n    // end key: 'b.c'\n    // this way, you can do `obj[key]` and get `10`.\n    return fn(obj, key, val);\n  };\n}\n\n\n/**\n * Find an object by its key\n *\n * find({ first_name : 'Calvin' }, 'firstName')\n */\n\nfunction find (obj, key) {\n  if (obj.hasOwnProperty(key)) return obj[key];\n}\n\n\n/**\n * Delete a value for a given key\n *\n * del({ a : 'b', x : 'y' }, 'X' }) -> { a : 'b' }\n */\n\nfunction del (obj, key) {\n  if (obj.hasOwnProperty(key)) delete obj[key];\n  return obj;\n}\n\n\n/**\n * Replace an objects existing value with a new one\n *\n * replace({ a : 'b' }, 'a', 'c') -> { a : 'c' }\n */\n\nfunction replace (obj, key, val) {\n  if (obj.hasOwnProperty(key)) obj[key] = val;\n  return obj;\n}\n\n/**\n * Normalize a `dot.separated.path`.\n *\n * A.HELL(!*&#(!)O_WOR   LD.bar => ahelloworldbar\n *\n * @param {String} path\n * @return {String}\n */\n\nfunction defaultNormalize(path) {\n  return path.replace(/[^a-zA-Z0-9\\.]+/g, '').toLowerCase();\n}\n\n/**\n * Check if a value is a function.\n *\n * @param {*} val\n * @return {boolean} Returns `true` if `val` is a function, otherwise `false`.\n */\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}