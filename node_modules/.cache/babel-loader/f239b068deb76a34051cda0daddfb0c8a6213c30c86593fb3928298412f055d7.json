{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Facade = void 0;\nvar address_1 = __importDefault(require(\"./address\"));\nvar clone_1 = require(\"./clone\");\nvar is_enabled_1 = __importDefault(require(\"./is-enabled\"));\nvar new_date_1 = __importDefault(require(\"new-date\"));\nvar obj_case_1 = __importDefault(require(\"obj-case\"));\nvar isodate_traverse_1 = __importDefault(require(\"@segment/isodate-traverse\"));\nfunction Facade(obj, opts) {\n  opts = opts || {};\n  this.raw = clone_1.clone(obj);\n  if (!(\"clone\" in opts)) opts.clone = true;\n  if (opts.clone) obj = clone_1.clone(obj);\n  if (!(\"traverse\" in opts)) opts.traverse = true;\n  if (!(\"timestamp\" in obj)) obj.timestamp = new Date();else obj.timestamp = new_date_1.default(obj.timestamp);\n  if (opts.traverse) isodate_traverse_1.default(obj);\n  this.opts = opts;\n  this.obj = obj;\n}\nexports.Facade = Facade;\nvar f = Facade.prototype;\nf.proxy = function (field) {\n  var fields = field.split(\".\");\n  field = fields.shift();\n  var obj = this[field] || this.obj[field];\n  if (!obj) return obj;\n  if (typeof obj === \"function\") obj = obj.call(this) || {};\n  if (fields.length === 0) return this.opts.clone ? transform(obj) : obj;\n  obj = obj_case_1.default(obj, fields.join(\".\"));\n  return this.opts.clone ? transform(obj) : obj;\n};\nf.field = function (field) {\n  var obj = this.obj[field];\n  return this.opts.clone ? transform(obj) : obj;\n};\nFacade.proxy = function (field) {\n  return function () {\n    return this.proxy(field);\n  };\n};\nFacade.field = function (field) {\n  return function () {\n    return this.field(field);\n  };\n};\nFacade.multi = function (path) {\n  return function () {\n    var multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi;\n    var one = this.proxy(path);\n    if (one) one = [this.opts.clone ? clone_1.clone(one) : one];\n    return one || [];\n  };\n};\nFacade.one = function (path) {\n  return function () {\n    var one = this.proxy(path);\n    if (one) return one;\n    var multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi[0];\n  };\n};\nf.json = function () {\n  var ret = this.opts.clone ? clone_1.clone(this.obj) : this.obj;\n  if (this.type) ret.type = this.type();\n  return ret;\n};\nf.rawEvent = function () {\n  return this.raw;\n};\nf.options = function (integration) {\n  var obj = this.obj.options || this.obj.context || {};\n  var options = this.opts.clone ? clone_1.clone(obj) : obj;\n  if (!integration) return options;\n  if (!this.enabled(integration)) return;\n  var integrations = this.integrations();\n  var value = integrations[integration] || obj_case_1.default(integrations, integration);\n  if (typeof value !== \"object\") value = obj_case_1.default(this.options(), integration);\n  return typeof value === \"object\" ? value : {};\n};\nf.context = f.options;\nf.enabled = function (integration) {\n  var allEnabled = this.proxy(\"options.providers.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = this.proxy(\"options.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = this.proxy(\"integrations.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = true;\n  var enabled = allEnabled && is_enabled_1.default(integration);\n  var options = this.integrations();\n  if (options.providers && options.providers.hasOwnProperty(integration)) {\n    enabled = options.providers[integration];\n  }\n  if (options.hasOwnProperty(integration)) {\n    var settings = options[integration];\n    if (typeof settings === \"boolean\") {\n      enabled = settings;\n    } else {\n      enabled = true;\n    }\n  }\n  return !!enabled;\n};\nf.integrations = function () {\n  return this.obj.integrations || this.proxy(\"options.providers\") || this.options();\n};\nf.active = function () {\n  var active = this.proxy(\"options.active\");\n  if (active === null || active === undefined) active = true;\n  return active;\n};\nf.anonymousId = function () {\n  return this.field(\"anonymousId\") || this.field(\"sessionId\");\n};\nf.sessionId = f.anonymousId;\nf.groupId = Facade.proxy(\"options.groupId\");\nf.traits = function (aliases) {\n  var ret = this.proxy(\"options.traits\") || {};\n  var id = this.userId();\n  aliases = aliases || {};\n  if (id) ret.id = id;\n  for (var alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      var value = this[alias] == null ? this.proxy(\"options.traits.\" + alias) : this[alias]();\n      if (value == null) continue;\n      ret[aliases[alias]] = value;\n      delete ret[alias];\n    }\n  }\n  return ret;\n};\nf.library = function () {\n  var library = this.proxy(\"options.library\");\n  if (!library) return {\n    name: \"unknown\",\n    version: null\n  };\n  if (typeof library === \"string\") return {\n    name: library,\n    version: null\n  };\n  return library;\n};\nf.device = function () {\n  var device = this.proxy(\"context.device\");\n  if (typeof device !== \"object\" || device === null) {\n    device = {};\n  }\n  var library = this.library().name;\n  if (device.type) return device;\n  if (library.indexOf(\"ios\") > -1) device.type = \"ios\";\n  if (library.indexOf(\"android\") > -1) device.type = \"android\";\n  return device;\n};\nf.userAgent = Facade.proxy(\"context.userAgent\");\nf.timezone = Facade.proxy(\"context.timezone\");\nf.timestamp = Facade.field(\"timestamp\");\nf.channel = Facade.field(\"channel\");\nf.ip = Facade.proxy(\"context.ip\");\nf.userId = Facade.field(\"userId\");\naddress_1.default(f);\nfunction transform(obj) {\n  return clone_1.clone(obj);\n}","map":{"version":3,"names":["address_1","__importDefault","require","clone_1","is_enabled_1","new_date_1","obj_case_1","isodate_traverse_1","Facade","obj","opts","raw","clone","traverse","timestamp","Date","default","exports","f","prototype","proxy","field","fields","split","shift","call","length","transform","join","multi","path","Array","isArray","one","json","ret","type","rawEvent","options","integration","context","enabled","integrations","value","allEnabled","providers","hasOwnProperty","settings","active","undefined","anonymousId","sessionId","groupId","traits","aliases","id","userId","alias","Object","library","name","version","device","indexOf","userAgent","timezone","channel","ip"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/facade/lib/facade.js"],"sourcesContent":["\"use strict\";\n\nimport address from \"./address\";\nimport { clone } from \"./clone\";\nimport isEnabled from \"./is-enabled\";\nimport newDate from \"new-date\";\nimport objCase from \"obj-case\";\nimport traverse from \"@segment/isodate-traverse\";\n\n/**\n * A *Facade* is an object meant for creating convience wrappers around\n * objects. When developing integrations, you probably want to look at its\n * subclasses, such as {@link Track} or {@link Identify}, rather than this\n * general-purpose class.\n *\n * This letructor will initialize a new `Facade` with an `obj` of arguments.\n *\n * If the inputted `obj` doesn't have a `timestamp` property, one will be added\n * with the value `new Date()`. Otherwise, the `timestamp` property will be\n * converted to a Date using the `new-date` package.\n *\n * By default, the inputted object will be defensively copied, and all ISO\n * strings present in the string will be converted into Dates.\n *\n * @param {Object} obj - The object to wrap.\n * @param {Object} opts - Options about what kind of Facade to create.\n * @param {boolean} [opts.clone=true] - Whether to make defensive clones. If enabled,\n * the inputted object will be cloned, and any objects derived from this facade\n * will be cloned before being returned.\n * @param {boolean} [opts.traverse=true] - Whether to perform ISODate-Traverse\n * on the inputted object.\n *\n * @see {@link https://github.com/segmentio/new-date|new-date}\n * @see {@link https://github.com/segmentio/isodate-traverse|isodate-traverse}\n */\nexport function Facade (obj, opts) {\n  opts = opts || {};\n  this.raw = clone(obj);\n  if (!(\"clone\" in opts)) opts.clone = true;\n  if (opts.clone) obj = clone(obj);\n  if (!(\"traverse\" in opts)) opts.traverse = true;\n  if (!(\"timestamp\" in obj)) obj.timestamp = new Date();\n  else obj.timestamp = newDate(obj.timestamp);\n  if (opts.traverse) traverse(obj);\n  this.opts = opts;\n  this.obj = obj;\n}\n\nconst f = Facade.prototype;\n\n/**\n * Get a potentially-nested field in this facade. `field` should be a\n * period-separated sequence of properties.\n *\n * If the first field passed in points to a function (e.g. the `field` passed\n * in is `a.b.c` and this facade's `obj.a` is a function), then that function\n * will be called, and then the deeper fields will be fetched (using obj-case)\n * from what that function returns. If the first field isn't a function, then\n * this function works just like obj-case.\n *\n * Because this function uses obj-case, the camel- or snake-case of the input\n * is irrelevant.\n *\n * @example\n * YourClass.prototype.height = function() {\n *   return this.proxy('getDimensions.height') ||\n *     this.proxy('props.size.side_length');\n * }\n * @param {string} field - A sequence of properties, joined by periods (`.`).\n * @return {*} - A property of the inputted object.\n * @see {@link https://github.com/segmentio/obj-case|obj-case}\n */\nf.proxy = function(field) {\n  let fields = field.split(\".\");\n  field = fields.shift();\n\n  // Call a function at the beginning to take advantage of facaded fields\n  let obj = this[field] || this.obj[field];\n  if (!obj) return obj;\n  if (typeof obj === \"function\") obj = obj.call(this) || {};\n  if (fields.length === 0) return this.opts.clone ? transform(obj) : obj;\n\n  obj = objCase(obj, fields.join(\".\"));\n  return this.opts.clone ? transform(obj) : obj;\n};\n\n/**\n * Directly access a specific `field` from the underlying object. Only\n * \"top-level\" fields will work with this function. \"Nested\" fields *will not\n * work* with this function.\n *\n * @param {string} field\n * @return {*}\n */\nf.field = function(field) {\n  let obj = this.obj[field];\n  return this.opts.clone ? transform(obj) : obj;\n};\n\n/**\n * Utility method to always proxy a particular `field`. In other words, it\n * returns a function that will always return `this.proxy(field)`.\n *\n * @example\n * MyClass.prototype.height = Facade.proxy('options.dimensions.height');\n *\n * @param {string} field\n * @return {Function}\n */\nFacade.proxy = function(field) {\n  return function() {\n    return this.proxy(field);\n  };\n};\n\n/**\n * Utility method to always access a `field`. In other words, it returns a\n * function that will always return `this.field(field)`.\n *\n * @param {string} field\n * @return {Function}\n */\nFacade.field = function(field) {\n  return function() {\n    return this.field(field);\n  };\n};\n\n/**\n * Create a helper function for fetching a \"plural\" thing.\n *\n * The generated method will take the inputted `path` and append an \"s\" to it\n * and calls `this.proxy` with this \"pluralized\" path. If that produces an\n * array, that will be returned. Otherwise, a one-element array containing\n * `this.proxy(path)` will be returned.\n *\n * @example\n * MyClass.prototype.birds = Facade.multi('animals.bird');\n *\n * @param {string} path\n * @return {Function}\n */\nFacade.multi = function(path) {\n  return function() {\n    let multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi;\n    let one = this.proxy(path);\n    if (one) one = [this.opts.clone ? clone(one) : one];\n    return one || [];\n  };\n};\n\n/**\n * Create a helper function for getting a \"singular\" thing.\n *\n * The generated method will take the inputted path and call\n * `this.proxy(path)`. If a truthy thing is produced, it will be returned.\n * Otherwise, `this.proxy(path + 's')` will be called, and if that produces an\n * array the first element of that array will be returned. Otherwise,\n * `undefined` is returned.\n *\n * @example\n * MyClass.prototype.bird = Facade.one('animals.bird');\n *\n * @param {string} path\n * @return {Function}\n */\nFacade.one = function(path) {\n  return function() {\n    let one = this.proxy(path);\n    if (one) return one;\n    let multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi[0];\n  };\n};\n\n/**\n * Gets the underlying object this facade wraps around.\n *\n * If this facade has a property `type`, it will be invoked as a function and\n * will be assigned as the property `type` of the outputted object.\n *\n * @return {Object}\n */\nf.json = function() {\n  let ret = this.opts.clone ? clone(this.obj) : this.obj;\n  if (this.type) ret.type = this.type();\n  return ret;\n};\n\n/**\n * Gets a copy of the unmodified input object this facade wraps around.\n * \n * Unlike the `json` method which does make some subtle modifications \n * to datetime values and the `type` property. This method returns a copy of \n * the unmodified input object\n * \n * @return {Object}\n */\nf.rawEvent = function() {\n  return this.raw;\n};\n\n/**\n * Get the options of a call. If an integration is passed, only the options for\n * that integration are included. If the integration is not enabled, then\n * `undefined` is returned.\n *\n * Options are taken from the `options` property of the underlying object,\n * falling back to the object's `context` or simply `{}`.\n *\n * @param {string} integration - The name of the integration to get settings\n * for. Casing does not matter.\n * @return {Object|undefined}\n */\nf.options = function(integration) {\n  let obj = this.obj.options || this.obj.context || {};\n  let options = this.opts.clone ? clone(obj) : obj;\n  if (!integration) return options;\n  if (!this.enabled(integration)) return;\n  let integrations = this.integrations();\n  let value = integrations[integration] || objCase(integrations, integration);\n  if (typeof value !== \"object\") value = objCase(this.options(), integration);\n  return typeof value === \"object\" ? value : {};\n};\n\n/**\n * An alias for {@link Facade#options}.\n */\nf.context = f.options;\n\n/**\n * Check whether an integration is enabled.\n *\n * Basically, this method checks whether this integration is explicitly\n * enabled. If it isn'texplicitly mentioned, it checks whether it has been\n * enabled at the global level. Some integrations (e.g. Salesforce), cannot\n * enabled by these global event settings.\n *\n * More concretely, the deciding factors here are:\n *\n * 1. If `this.integrations()` has the integration set to `true`, return `true`.\n * 2. If `this.integrations().providers` has the integration set to `true`, return `true`.\n * 3. If integrations are set to default-disabled via global parameters (i.e.\n * `options.providers.all`, `options.all`, or `integrations.all`), then return\n * false.\n * 4. If the integration is one of the special default-deny integrations\n * (currently, only Salesforce), then return false.\n * 5. Else, return true.\n *\n * @param {string} integration\n * @return {boolean}\n */\nf.enabled = function(integration) {\n  let allEnabled = this.proxy(\"options.providers.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = this.proxy(\"options.all\");\n  if (typeof allEnabled !== \"boolean\")\n    allEnabled = this.proxy(\"integrations.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = true;\n\n  let enabled = allEnabled && isEnabled(integration);\n  let options = this.integrations();\n\n  // If the integration is explicitly enabled or disabled, use that\n  // First, check options.providers for backwards compatibility\n  if (options.providers && options.providers.hasOwnProperty(integration)) {\n    enabled = options.providers[integration];\n  }\n\n  // Next, check for the integration's existence in 'options' to enable it.\n  // If the settings are a boolean, use that, otherwise it should be enabled.\n  if (options.hasOwnProperty(integration)) {\n    let settings = options[integration];\n    if (typeof settings === \"boolean\") {\n      enabled = settings;\n    } else {\n      enabled = true;\n    }\n  }\n\n  return !!enabled;\n};\n\n/**\n * Get all `integration` options.\n *\n * @ignore\n * @param {string} integration\n * @return {Object}\n */\nf.integrations = function() {\n  return (\n    this.obj.integrations || this.proxy(\"options.providers\") || this.options()\n  );\n};\n\n/**\n * Check whether the user is active.\n *\n * @return {boolean}\n */\nf.active = function() {\n  let active = this.proxy(\"options.active\");\n  if (active === null || active === undefined) active = true;\n  return active;\n};\n\n/**\n * Get `sessionId / anonymousId`.\n *\n * @return {*}\n */\nf.anonymousId = function() {\n  return this.field(\"anonymousId\") || this.field(\"sessionId\");\n};\n\n/**\n * An alias for {@link Facade#anonymousId}.\n *\n * @function\n * @return {string}\n */\nf.sessionId = f.anonymousId;\n\n/**\n * Get `groupId` from `context.groupId`.\n *\n * @function\n * @return {string}\n */\nf.groupId = Facade.proxy(\"options.groupId\");\n\n/**\n * Get the call's \"traits\". All event types can pass in traits, though {@link\n * Identify} and {@link Group} override this implementation.\n *\n * Traits are gotten from `options.traits`, augmented with a property `id` with\n * the event's `userId`.\n *\n * The parameter `aliases` is meant to transform keys in `options.traits` into\n * new keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx`\n * in the traits, and move it to `yyy`. If `xxx` is a method of this facade,\n * it'll be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { options: { traits: { foo: \"bar\" } }, anonymousId: \"xxx\" }\n * let facade = new Facade(obj)\n *\n * facade.traits() // { \"foo\": \"bar\" }\n * facade.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * facade.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\nf.traits = function(aliases) {\n  let ret = this.proxy(\"options.traits\") || {};\n  let id = this.userId();\n  aliases = aliases || {};\n\n  if (id) ret.id = id;\n\n  for (const alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      const value = this[alias] == null\n        ? this.proxy(\"options.traits.\" + alias)\n        : this[alias]();\n      if (value == null) continue;\n      ret[aliases[alias]] = value;\n      delete ret[alias];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * The library and version of the client used to produce the message.\n *\n * If the library name cannot be determined, it is set to `\"unknown\"`. If the\n * version cannot be determined, it is set to `null`.\n *\n * @return {{name: string, version: string}}\n */\nf.library = function() {\n  let library = this.proxy(\"options.library\");\n  if (!library) return { name: \"unknown\", version: null };\n  if (typeof library === \"string\") return { name: library, version: null };\n  return library;\n};\n\n/**\n * Return the device information, falling back to an empty object.\n *\n * Interesting values of `type` are `\"ios\"` and `\"android\"`, but other values\n * are possible if the client is doing something unusual with `context.device`.\n *\n * @return {{type: string}}\n */\nf.device = function() {\n  let device = this.proxy(\"context.device\");\n  if (typeof device !== \"object\" || device === null) {\n    device = {};\n  }\n  let library = this.library().name;\n  if (device.type) return device;\n\n  if (library.indexOf(\"ios\") > -1) device.type = \"ios\";\n  if (library.indexOf(\"android\") > -1) device.type = \"android\";\n  return device;\n};\n\n/**\n * Get the User-Agent from `context.userAgent`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.userAgent = Facade.proxy(\"context.userAgent\");\n\n/**\n * Get the timezone from `context.timezone`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.timezone = Facade.proxy(\"context.timezone\");\n\n/**\n * Get the timestamp from `context.timestamp`.\n *\n * @function\n * @return string\n */\nf.timestamp = Facade.field(\"timestamp\");\n\n/**\n * Get the channel from `channel`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.channel = Facade.field(\"channel\");\n\n/**\n * Get the IP address from `context.ip`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.ip = Facade.proxy(\"context.ip\");\n\n/**\n * Get the user ID from `userId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.userId = Facade.field(\"userId\");\n\n/**\n * Get the ZIP/Postal code from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name zip\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the country from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name country\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the street from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name street\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the state from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name state\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the city from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name city\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the region from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name region\n * @function\n * @memberof f\n * @return {string}\n */\n\naddress(f);\n\n/**\n * Return the cloned and traversed object\n *\n * @ignore\n * @param {*} obj\n * @return {*}\n */\nfunction transform (obj) {\n  return clone(obj);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}