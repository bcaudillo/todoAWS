{"ast":null,"code":"import { isPlainObject } from '@segment/analytics-core';\nexport var BufferedPageContextDiscriminant = 'bpc';\n/**\n * `BufferedPageContext` object builder\n */\nexport var createBufferedPageContext = function (url, canonicalUrl, search, path, title, referrer) {\n  return {\n    __t: BufferedPageContextDiscriminant,\n    c: canonicalUrl,\n    p: path,\n    u: url,\n    s: search,\n    t: title,\n    r: referrer\n  };\n};\n// my clever/dubious way of making sure this type guard does not get out sync with the type definition\nvar BUFFERED_PAGE_CONTEXT_KEYS = Object.keys(createBufferedPageContext('', '', '', '', '', ''));\nexport function isBufferedPageContext(bufferedPageCtx) {\n  if (!isPlainObject(bufferedPageCtx)) return false;\n  if (bufferedPageCtx.__t !== BufferedPageContextDiscriminant) return false;\n  // ensure obj has all the keys we expect, and none we don't.\n  for (var k in bufferedPageCtx) {\n    if (!BUFFERED_PAGE_CONTEXT_KEYS.includes(k)) {\n      return false;\n    }\n  }\n  return true;\n}\n//  Legacy logic: we are we appending search parameters to the canonical URL -- I guess the canonical URL is  \"not canonical enough\" (lol)\nvar createCanonicalURL = function (canonicalUrl, searchParams) {\n  return canonicalUrl.indexOf('?') > -1 ? canonicalUrl : canonicalUrl + searchParams;\n};\n/**\n * Strips hash from URL.\n * http://www.segment.local#test -> http://www.segment.local\n */\nvar removeHash = function (href) {\n  var hashIdx = href.indexOf('#');\n  return hashIdx === -1 ? href : href.slice(0, hashIdx);\n};\nvar parseCanonicalPath = function (canonicalUrl) {\n  try {\n    return new URL(canonicalUrl).pathname;\n  } catch (_e) {\n    // this is classic behavior -- we assume that if the canonical URL is invalid, it's a raw path.\n    return canonicalUrl[0] === '/' ? canonicalUrl : '/' + canonicalUrl;\n  }\n};\n/**\n * Create a `PageContext` from a `BufferedPageContext`.\n * `BufferedPageContext` keys are minified to save bytes in the snippet.\n */\nexport var createPageContext = function (_a) {\n  var canonicalUrl = _a.c,\n    pathname = _a.p,\n    search = _a.s,\n    url = _a.u,\n    referrer = _a.r,\n    title = _a.t;\n  var newPath = canonicalUrl ? parseCanonicalPath(canonicalUrl) : pathname;\n  var newUrl = canonicalUrl ? createCanonicalURL(canonicalUrl, search) : removeHash(url);\n  return {\n    path: newPath,\n    referrer: referrer,\n    search: search,\n    title: title,\n    url: newUrl\n  };\n};\n/**\n * Get page properties from the browser window/document.\n */\nexport var getDefaultBufferedPageContext = function () {\n  var c = document.querySelector(\"link[rel='canonical']\");\n  return createBufferedPageContext(location.href, c && c.getAttribute('href') || undefined, location.search, location.pathname, document.title, document.referrer);\n};\n/**\n * Get page properties from the browser window/document.\n */\nexport var getDefaultPageContext = function () {\n  return createPageContext(getDefaultBufferedPageContext());\n};","map":{"version":3,"names":["isPlainObject","BufferedPageContextDiscriminant","createBufferedPageContext","url","canonicalUrl","search","path","title","referrer","__t","c","p","u","s","t","r","BUFFERED_PAGE_CONTEXT_KEYS","Object","keys","isBufferedPageContext","bufferedPageCtx","k","includes","createCanonicalURL","searchParams","indexOf","removeHash","href","hashIdx","slice","parseCanonicalPath","URL","pathname","_e","createPageContext","_a","newPath","newUrl","getDefaultBufferedPageContext","document","querySelector","location","getAttribute","undefined","getDefaultPageContext"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/analytics-next/src/core/page/get-page-context.ts"],"sourcesContent":["import { isPlainObject } from '@segment/analytics-core'\n\n/**\n * Final Page Context object expected in the Segment Event context\n */\nexport interface PageContext {\n  path: string\n  referrer: string\n  search: string\n  title: string\n  url: string\n}\n\ntype CanonicalUrl = string | undefined\n\nexport const BufferedPageContextDiscriminant = 'bpc' as const\n/**\n * Page Context expected to be built by the snippet.\n * Note: The key names are super short because we want to keep the strings in the html snippet short to save bytes.\n */\nexport interface BufferedPageContext {\n  __t: typeof BufferedPageContextDiscriminant // for extra uniqeness\n  c: CanonicalUrl\n  p: PageContext['path']\n  u: PageContext['url']\n  s: PageContext['search']\n  t: PageContext['title']\n  r: PageContext['referrer']\n}\n\n/**\n * `BufferedPageContext` object builder\n */\nexport const createBufferedPageContext = (\n  url: string,\n  canonicalUrl: CanonicalUrl,\n  search: string,\n  path: string,\n  title: string,\n  referrer: string\n): BufferedPageContext => ({\n  __t: BufferedPageContextDiscriminant,\n  c: canonicalUrl,\n  p: path,\n  u: url,\n  s: search,\n  t: title,\n  r: referrer,\n})\n\n// my clever/dubious way of making sure this type guard does not get out sync with the type definition\nconst BUFFERED_PAGE_CONTEXT_KEYS = Object.keys(\n  createBufferedPageContext('', '', '', '', '', '')\n) as (keyof BufferedPageContext)[]\n\nexport function isBufferedPageContext(\n  bufferedPageCtx: unknown\n): bufferedPageCtx is BufferedPageContext {\n  if (!isPlainObject(bufferedPageCtx)) return false\n  if (bufferedPageCtx.__t !== BufferedPageContextDiscriminant) return false\n\n  // ensure obj has all the keys we expect, and none we don't.\n  for (const k in bufferedPageCtx) {\n    if (!BUFFERED_PAGE_CONTEXT_KEYS.includes(k as keyof BufferedPageContext)) {\n      return false\n    }\n  }\n  return true\n}\n\n//  Legacy logic: we are we appending search parameters to the canonical URL -- I guess the canonical URL is  \"not canonical enough\" (lol)\nconst createCanonicalURL = (canonicalUrl: string, searchParams: string) => {\n  return canonicalUrl.indexOf('?') > -1\n    ? canonicalUrl\n    : canonicalUrl + searchParams\n}\n\n/**\n * Strips hash from URL.\n * http://www.segment.local#test -> http://www.segment.local\n */\nconst removeHash = (href: string) => {\n  const hashIdx = href.indexOf('#')\n  return hashIdx === -1 ? href : href.slice(0, hashIdx)\n}\n\nconst parseCanonicalPath = (canonicalUrl: string): string => {\n  try {\n    return new URL(canonicalUrl).pathname\n  } catch (_e) {\n    // this is classic behavior -- we assume that if the canonical URL is invalid, it's a raw path.\n    return canonicalUrl[0] === '/' ? canonicalUrl : '/' + canonicalUrl\n  }\n}\n\n/**\n * Create a `PageContext` from a `BufferedPageContext`.\n * `BufferedPageContext` keys are minified to save bytes in the snippet.\n */\nexport const createPageContext = ({\n  c: canonicalUrl,\n  p: pathname,\n  s: search,\n  u: url,\n  r: referrer,\n  t: title,\n}: BufferedPageContext): PageContext => {\n  const newPath = canonicalUrl ? parseCanonicalPath(canonicalUrl) : pathname\n  const newUrl = canonicalUrl\n    ? createCanonicalURL(canonicalUrl, search)\n    : removeHash(url)\n  return {\n    path: newPath,\n    referrer,\n    search,\n    title,\n    url: newUrl,\n  }\n}\n\n/**\n * Get page properties from the browser window/document.\n */\nexport const getDefaultBufferedPageContext = (): BufferedPageContext => {\n  const c = document.querySelector(\"link[rel='canonical']\")\n  return createBufferedPageContext(\n    location.href,\n    (c && c.getAttribute('href')) || undefined,\n    location.search,\n    location.pathname,\n    document.title,\n    document.referrer\n  )\n}\n\n/**\n * Get page properties from the browser window/document.\n */\nexport const getDefaultPageContext = (): PageContext =>\n  createPageContext(getDefaultBufferedPageContext())\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}