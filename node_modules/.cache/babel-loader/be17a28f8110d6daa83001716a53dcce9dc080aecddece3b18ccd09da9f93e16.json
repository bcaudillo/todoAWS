{"ast":null,"code":"/**\n * Given an introspection schema model, returns all owner fields.\n *\n * @param model Model from an introspection schema\n * @returns List of owner field names\n */\nfunction resolveOwnerFields(model) {\n  const ownerFields = new Set();\n  for (const attr of model.attributes || []) {\n    if (isAuthAttribute(attr)) {\n      for (const rule of attr.properties.rules) {\n        if (rule.allow === 'owner') {\n          ownerFields.add(rule.ownerField || 'owner');\n        } else if (rule.allow === 'groups' && rule.groupsField !== undefined) {\n          // only valid for dynamic group(s)\n          // static group auth will have an array of predefined groups in the attribute, groups: string[]\n          // but `groupsField` will be undefined\n          ownerFields.add(rule.groupsField);\n        }\n      }\n    }\n  }\n  return Array.from(ownerFields);\n}\n/**\n * Type guard that identifies an auth attribute with an attached rules list that\n * specifies an `allow` attribute at a minimum.\n *\n * @param attribute Any object. Ideally a model introspection schema model attribute\n * @returns True if given object is an auth attribute\n */\nfunction isAuthAttribute(attribute) {\n  if ((attribute === null || attribute === void 0 ? void 0 : attribute.type) === 'auth') {\n    if (typeof (attribute === null || attribute === void 0 ? void 0 : attribute.properties) === 'object') {\n      var _attribute$properties;\n      if (Array.isArray(attribute === null || attribute === void 0 || (_attribute$properties = attribute.properties) === null || _attribute$properties === void 0 ? void 0 : _attribute$properties.rules)) {\n        var _attribute$properties2;\n        return (attribute === null || attribute === void 0 || (_attribute$properties2 = attribute.properties) === null || _attribute$properties2 === void 0 ? void 0 : _attribute$properties2.rules).every(rule => !!rule.allow);\n      }\n    }\n  }\n  return false;\n}\nexport { resolveOwnerFields };","map":{"version":3,"names":["resolveOwnerFields","model","ownerFields","Set","attr","attributes","isAuthAttribute","rule","properties","rules","allow","add","ownerField","groupsField","undefined","Array","from","attribute","type","_attribute$properties","isArray","_attribute$properties2","every"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@aws-amplify/api-graphql/src/utils/resolveOwnerFields.ts"],"sourcesContent":["/**\n * Given an introspection schema model, returns all owner fields.\n *\n * @param model Model from an introspection schema\n * @returns List of owner field names\n */\nexport function resolveOwnerFields(model) {\n    const ownerFields = new Set();\n    for (const attr of model.attributes || []) {\n        if (isAuthAttribute(attr)) {\n            for (const rule of attr.properties.rules) {\n                if (rule.allow === 'owner') {\n                    ownerFields.add(rule.ownerField || 'owner');\n                }\n                else if (rule.allow === 'groups' && rule.groupsField !== undefined) {\n                    // only valid for dynamic group(s)\n                    // static group auth will have an array of predefined groups in the attribute, groups: string[]\n                    // but `groupsField` will be undefined\n                    ownerFields.add(rule.groupsField);\n                }\n            }\n        }\n    }\n    return Array.from(ownerFields);\n}\n/**\n * Type guard that identifies an auth attribute with an attached rules list that\n * specifies an `allow` attribute at a minimum.\n *\n * @param attribute Any object. Ideally a model introspection schema model attribute\n * @returns True if given object is an auth attribute\n */\nfunction isAuthAttribute(attribute) {\n    if (attribute?.type === 'auth') {\n        if (typeof attribute?.properties === 'object') {\n            if (Array.isArray(attribute?.properties?.rules)) {\n                return (attribute?.properties?.rules).every(rule => !!rule.allow);\n            }\n        }\n    }\n    return false;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,kBAAkBA,CAACC,KAAK,EAAE;EACtC,MAAMC,WAAW,GAAG,IAAIC,GAAG,EAAE;EAC7B,KAAK,MAAMC,IAAI,IAAIH,KAAK,CAACI,UAAU,IAAI,EAAE,EAAE;IACvC,IAAIC,eAAe,CAACF,IAAI,CAAC,EAAE;MACvB,KAAK,MAAMG,IAAI,IAAIH,IAAI,CAACI,UAAU,CAACC,KAAK,EAAE;QACtC,IAAIF,IAAI,CAACG,KAAK,KAAK,OAAO,EAAE;UACxBR,WAAW,CAACS,GAAG,CAACJ,IAAI,CAACK,UAAU,IAAI,OAAO,CAAC;QAC/D,CAAiB,MACI,IAAIL,IAAI,CAACG,KAAK,KAAK,QAAQ,IAAIH,IAAI,CAACM,WAAW,KAAKC,SAAS,EAAE;UACpF;UACA;UACA;UACoBZ,WAAW,CAACS,GAAG,CAACJ,IAAI,CAACM,WAAW,CAAC;QACrD;MACA;IACA;EACA;EACI,OAAOE,KAAK,CAACC,IAAI,CAACd,WAAW,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,eAAeA,CAACW,SAAS,EAAE;EAChC,IAAI,CAAAA,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEC,IAAI,MAAK,MAAM,EAAE;IAC5B,IAAI,QAAOD,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAET,UAAU,MAAK,QAAQ,EAAE;MAAA,IAAAW,qBAAA;MAC3C,IAAIJ,KAAK,CAACK,OAAO,CAACH,SAAS,aAATA,SAAS,gBAAAE,qBAAA,GAATF,SAAS,CAAET,UAAU,cAAAW,qBAAA,uBAArBA,qBAAA,CAAuBV,KAAK,CAAC,EAAE;QAAA,IAAAY,sBAAA;QAC7C,OAAO,CAACJ,SAAS,aAATA,SAAS,gBAAAI,sBAAA,GAATJ,SAAS,CAAET,UAAU,cAAAa,sBAAA,uBAArBA,sBAAA,CAAuBZ,KAAK,EAAEa,KAAK,CAACf,IAAI,IAAI,CAAC,CAACA,IAAI,CAACG,KAAK,CAAC;MACjF;IACA;EACA;EACI,OAAO,KAAK;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}