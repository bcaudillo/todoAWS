{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { groupBy } from '../utils/group-by';\nimport { ON_REMOVE_FROM_FUTURE } from '../priority-queue';\nimport { CoreContext, ContextCancelation } from '../context';\nimport { Emitter } from '@segment/analytics-generic-utils';\nimport { createTaskGroup } from '../task/task-group';\nimport { attempt, ensure } from './delivery';\nvar CoreEventQueue = /** @class */function (_super) {\n  __extends(CoreEventQueue, _super);\n  function CoreEventQueue(priorityQueue) {\n    var _this = _super.call(this) || this;\n    /**\n     * All event deliveries get suspended until all the tasks in this task group are complete.\n     * For example: a middleware that augments the event object should be loaded safely as a\n     * critical task, this way, event queue will wait for it to be ready before sending events.\n     *\n     * This applies to all the events already in the queue, and the upcoming ones\n     */\n    _this.criticalTasks = createTaskGroup();\n    _this.plugins = [];\n    _this.failedInitializations = [];\n    _this.flushing = false;\n    _this.queue = priorityQueue;\n    _this.queue.on(ON_REMOVE_FROM_FUTURE, function () {\n      _this.scheduleFlush(0);\n    });\n    return _this;\n  }\n  CoreEventQueue.prototype.register = function (ctx, plugin, instance) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(plugin.type === 'destination' && plugin.name !== 'Segment.io')) return [3 /*break*/, 1];\n            plugin.load(ctx, instance).catch(function (err) {\n              _this.failedInitializations.push(plugin.name);\n              _this.emit('initialization_failure', plugin);\n              console.warn(plugin.name, err);\n              ctx.log('warn', 'Failed to load destination', {\n                plugin: plugin.name,\n                error: err\n              });\n              _this.plugins = _this.plugins.filter(function (p) {\n                return p === plugin;\n              });\n            });\n            return [3 /*break*/, 3];\n          case 1:\n            return [4 /*yield*/, plugin.load(ctx, instance)];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            this.plugins.push(plugin);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  CoreEventQueue.prototype.deregister = function (ctx, plugin, instance) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n            if (!plugin.unload) return [3 /*break*/, 2];\n            return [4 /*yield*/, Promise.resolve(plugin.unload(ctx, instance))];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            this.plugins = this.plugins.filter(function (p) {\n              return p.name !== plugin.name;\n            });\n            return [3 /*break*/, 4];\n          case 3:\n            e_1 = _a.sent();\n            ctx.log('warn', 'Failed to unload destination', {\n              plugin: plugin.name,\n              error: e_1\n            });\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  CoreEventQueue.prototype.dispatch = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var willDeliver;\n      return __generator(this, function (_a) {\n        ctx.log('debug', 'Dispatching');\n        ctx.stats.increment('message_dispatched');\n        this.queue.push(ctx);\n        willDeliver = this.subscribeToDelivery(ctx);\n        this.scheduleFlush(0);\n        return [2 /*return*/, willDeliver];\n      });\n    });\n  };\n  CoreEventQueue.prototype.subscribeToDelivery = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve) {\n          var onDeliver = function (flushed, delivered) {\n            if (flushed.isSame(ctx)) {\n              _this.off('flush', onDeliver);\n              if (delivered) {\n                resolve(flushed);\n              } else {\n                resolve(flushed);\n              }\n            }\n          };\n          _this.on('flush', onDeliver);\n        })];\n      });\n    });\n  };\n  CoreEventQueue.prototype.dispatchSingle = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        ctx.log('debug', 'Dispatching');\n        ctx.stats.increment('message_dispatched');\n        this.queue.updateAttempts(ctx);\n        ctx.attempts = 1;\n        return [2 /*return*/, this.deliver(ctx).catch(function (err) {\n          var accepted = _this.enqueuRetry(err, ctx);\n          if (!accepted) {\n            ctx.setFailedDelivery({\n              reason: err\n            });\n            return ctx;\n          }\n          return _this.subscribeToDelivery(ctx);\n        })];\n      });\n    });\n  };\n  CoreEventQueue.prototype.isEmpty = function () {\n    return this.queue.length === 0;\n  };\n  CoreEventQueue.prototype.scheduleFlush = function (timeout) {\n    var _this = this;\n    if (timeout === void 0) {\n      timeout = 500;\n    }\n    if (this.flushing) {\n      return;\n    }\n    this.flushing = true;\n    setTimeout(function () {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _this.flush().then(function () {\n        setTimeout(function () {\n          _this.flushing = false;\n          if (_this.queue.length) {\n            _this.scheduleFlush(0);\n          }\n        }, 0);\n      });\n    }, timeout);\n  };\n  CoreEventQueue.prototype.deliver = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var start, done, err_1, error;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.criticalTasks.done()];\n          case 1:\n            _a.sent();\n            start = Date.now();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.flushOne(ctx)];\n          case 3:\n            ctx = _a.sent();\n            done = Date.now() - start;\n            this.emit('delivery_success', ctx);\n            ctx.stats.gauge('delivered', done);\n            ctx.log('debug', 'Delivered', ctx.event);\n            return [2 /*return*/, ctx];\n          case 4:\n            err_1 = _a.sent();\n            error = err_1;\n            ctx.log('error', 'Failed to deliver', error);\n            this.emit('delivery_failure', ctx, error);\n            ctx.stats.increment('delivery_failed');\n            throw err_1;\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  CoreEventQueue.prototype.enqueuRetry = function (err, ctx) {\n    var retriable = !(err instanceof ContextCancelation) || err.retry;\n    if (!retriable) {\n      return false;\n    }\n    return this.queue.pushWithBackoff(ctx);\n  };\n  CoreEventQueue.prototype.flush = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ctx, err_2, accepted;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.queue.length === 0) {\n              return [2 /*return*/, []];\n            }\n            ctx = this.queue.pop();\n            if (!ctx) {\n              return [2 /*return*/, []];\n            }\n            ctx.attempts = this.queue.getAttempts(ctx);\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.deliver(ctx)];\n          case 2:\n            ctx = _a.sent();\n            this.emit('flush', ctx, true);\n            return [3 /*break*/, 4];\n          case 3:\n            err_2 = _a.sent();\n            accepted = this.enqueuRetry(err_2, ctx);\n            if (!accepted) {\n              ctx.setFailedDelivery({\n                reason: err_2\n              });\n              this.emit('flush', ctx, false);\n            }\n            return [2 /*return*/, []];\n          case 4:\n            return [2 /*return*/, [ctx]];\n        }\n      });\n    });\n  };\n  CoreEventQueue.prototype.isReady = function () {\n    // return this.plugins.every((p) => p.isLoaded())\n    // should we wait for every plugin to load?\n    return true;\n  };\n  CoreEventQueue.prototype.availableExtensions = function (denyList) {\n    var available = this.plugins.filter(function (p) {\n      var _a, _b, _c;\n      // Only filter out destination plugins or the Segment.io plugin\n      if (p.type !== 'destination' && p.name !== 'Segment.io') {\n        return true;\n      }\n      var alternativeNameMatch = undefined;\n      (_a = p.alternativeNames) === null || _a === void 0 ? void 0 : _a.forEach(function (name) {\n        if (denyList[name] !== undefined) {\n          alternativeNameMatch = denyList[name];\n        }\n      });\n      // Explicit integration option takes precedence, `All: false` does not apply to Segment.io\n      return (_c = (_b = denyList[p.name]) !== null && _b !== void 0 ? _b : alternativeNameMatch) !== null && _c !== void 0 ? _c : (p.name === 'Segment.io' ? true : denyList.All) !== false;\n    });\n    var _a = groupBy(available, 'type'),\n      _b = _a.before,\n      before = _b === void 0 ? [] : _b,\n      _c = _a.enrichment,\n      enrichment = _c === void 0 ? [] : _c,\n      _d = _a.destination,\n      destination = _d === void 0 ? [] : _d,\n      _e = _a.after,\n      after = _e === void 0 ? [] : _e;\n    return {\n      before: before,\n      enrichment: enrichment,\n      destinations: destination,\n      after: after\n    };\n  };\n  CoreEventQueue.prototype.flushOne = function (ctx) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var _c, before, enrichment, _i, before_1, beforeWare, temp, _d, enrichment_1, enrichmentWare, temp, _e, destinations, after, afterCalls;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            if (!this.isReady()) {\n              throw new Error('Not ready');\n            }\n            if (ctx.attempts > 1) {\n              this.emit('delivery_retry', ctx);\n            }\n            _c = this.availableExtensions((_a = ctx.event.integrations) !== null && _a !== void 0 ? _a : {}), before = _c.before, enrichment = _c.enrichment;\n            _i = 0, before_1 = before;\n            _f.label = 1;\n          case 1:\n            if (!(_i < before_1.length)) return [3 /*break*/, 4];\n            beforeWare = before_1[_i];\n            return [4 /*yield*/, ensure(ctx, beforeWare)];\n          case 2:\n            temp = _f.sent();\n            if (temp instanceof CoreContext) {\n              ctx = temp;\n            }\n            this.emit('message_enriched', ctx, beforeWare);\n            _f.label = 3;\n          case 3:\n            _i++;\n            return [3 /*break*/, 1];\n          case 4:\n            _d = 0, enrichment_1 = enrichment;\n            _f.label = 5;\n          case 5:\n            if (!(_d < enrichment_1.length)) return [3 /*break*/, 8];\n            enrichmentWare = enrichment_1[_d];\n            return [4 /*yield*/, attempt(ctx, enrichmentWare)];\n          case 6:\n            temp = _f.sent();\n            if (temp instanceof CoreContext) {\n              ctx = temp;\n            }\n            this.emit('message_enriched', ctx, enrichmentWare);\n            _f.label = 7;\n          case 7:\n            _d++;\n            return [3 /*break*/, 5];\n          case 8:\n            _e = this.availableExtensions((_b = ctx.event.integrations) !== null && _b !== void 0 ? _b : {}), destinations = _e.destinations, after = _e.after;\n            return [4 /*yield*/, new Promise(function (resolve, reject) {\n              setTimeout(function () {\n                var attempts = destinations.map(function (destination) {\n                  return attempt(ctx, destination);\n                });\n                Promise.all(attempts).then(resolve).catch(reject);\n              }, 0);\n            })];\n          case 9:\n            _f.sent();\n            ctx.stats.increment('message_delivered');\n            this.emit('message_delivered', ctx);\n            afterCalls = after.map(function (after) {\n              return attempt(ctx, after);\n            });\n            return [4 /*yield*/, Promise.all(afterCalls)];\n          case 10:\n            _f.sent();\n            return [2 /*return*/, ctx];\n        }\n      });\n    });\n  };\n  return CoreEventQueue;\n}(Emitter);\nexport { CoreEventQueue };","map":{"version":3,"names":["groupBy","ON_REMOVE_FROM_FUTURE","CoreContext","ContextCancelation","Emitter","createTaskGroup","attempt","ensure","CoreEventQueue","_super","__extends","priorityQueue","_this","call","criticalTasks","plugins","failedInitializations","flushing","queue","on","scheduleFlush","prototype","register","ctx","plugin","instance","type","name","load","catch","err","push","emit","console","warn","log","error","filter","p","_a","sent","deregister","unload","Promise","resolve","e_1","dispatch","stats","increment","willDeliver","subscribeToDelivery","onDeliver","flushed","delivered","isSame","off","dispatchSingle","updateAttempts","attempts","deliver","accepted","enqueuRetry","setFailedDelivery","reason","isEmpty","length","timeout","setTimeout","flush","then","done","start","Date","now","flushOne","gauge","event","err_1","retriable","retry","pushWithBackoff","pop","getAttempts","err_2","isReady","availableExtensions","denyList","available","alternativeNameMatch","undefined","alternativeNames","forEach","_c","_b","All","before","enrichment","_d","destination","_e","after","destinations","Error","integrations","before_1","_i","beforeWare","temp","_f","enrichment_1","enrichmentWare","reject","map","all","afterCalls"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/analytics-core/src/queue/event-queue.ts"],"sourcesContent":["import { CoreAnalytics } from '../analytics'\nimport { groupBy } from '../utils/group-by'\nimport { ON_REMOVE_FROM_FUTURE, PriorityQueue } from '../priority-queue'\n\nimport { CoreContext, ContextCancelation } from '../context'\nimport { Emitter } from '@segment/analytics-generic-utils'\nimport { Integrations, JSONObject } from '../events/interfaces'\nimport { CorePlugin } from '../plugins'\nimport { createTaskGroup, TaskGroup } from '../task/task-group'\nimport { attempt, ensure } from './delivery'\n\nexport type EventQueueEmitterContract<Ctx extends CoreContext> = {\n  message_delivered: [ctx: Ctx]\n  message_enriched: [ctx: Ctx, plugin: CorePlugin<Ctx>]\n  delivery_success: [ctx: Ctx]\n  delivery_retry: [ctx: Ctx]\n  delivery_failure: [ctx: Ctx, err: Ctx | Error | ContextCancelation]\n  flush: [ctx: Ctx, delivered: boolean]\n  initialization_failure: [CorePlugin<Ctx>]\n}\n\nexport abstract class CoreEventQueue<\n  Ctx extends CoreContext = CoreContext,\n  Plugin extends CorePlugin<Ctx> = CorePlugin<Ctx>\n> extends Emitter<EventQueueEmitterContract<Ctx>> {\n  /**\n   * All event deliveries get suspended until all the tasks in this task group are complete.\n   * For example: a middleware that augments the event object should be loaded safely as a\n   * critical task, this way, event queue will wait for it to be ready before sending events.\n   *\n   * This applies to all the events already in the queue, and the upcoming ones\n   */\n  criticalTasks: TaskGroup = createTaskGroup()\n  queue: PriorityQueue<Ctx>\n  plugins: Plugin[] = []\n  failedInitializations: string[] = []\n  private flushing = false\n\n  constructor(priorityQueue: PriorityQueue<Ctx>) {\n    super()\n\n    this.queue = priorityQueue\n    this.queue.on(ON_REMOVE_FROM_FUTURE, () => {\n      this.scheduleFlush(0)\n    })\n  }\n\n  async register(\n    ctx: Ctx,\n    plugin: Plugin,\n    instance: CoreAnalytics\n  ): Promise<void> {\n    if (plugin.type === 'destination' && plugin.name !== 'Segment.io') {\n      plugin.load(ctx, instance).catch((err) => {\n        this.failedInitializations.push(plugin.name)\n        this.emit('initialization_failure', plugin)\n        console.warn(plugin.name, err)\n\n        ctx.log('warn', 'Failed to load destination', {\n          plugin: plugin.name,\n          error: err,\n        })\n\n        this.plugins = this.plugins.filter((p) => p === plugin)\n      })\n    } else {\n      await plugin.load(ctx, instance)\n    }\n\n    this.plugins.push(plugin)\n  }\n\n  async deregister(\n    ctx: Ctx,\n    plugin: CorePlugin<Ctx>,\n    instance: CoreAnalytics\n  ): Promise<void> {\n    try {\n      if (plugin.unload) {\n        await Promise.resolve(plugin.unload(ctx, instance))\n      }\n\n      this.plugins = this.plugins.filter((p) => p.name !== plugin.name)\n    } catch (e) {\n      ctx.log('warn', 'Failed to unload destination', {\n        plugin: plugin.name,\n        error: e,\n      })\n    }\n  }\n\n  async dispatch(ctx: Ctx): Promise<Ctx> {\n    ctx.log('debug', 'Dispatching')\n    ctx.stats.increment('message_dispatched')\n\n    this.queue.push(ctx)\n    const willDeliver = this.subscribeToDelivery(ctx)\n    this.scheduleFlush(0)\n    return willDeliver\n  }\n\n  private async subscribeToDelivery(ctx: Ctx): Promise<Ctx> {\n    return new Promise((resolve) => {\n      const onDeliver = (flushed: Ctx, delivered: boolean): void => {\n        if (flushed.isSame(ctx)) {\n          this.off('flush', onDeliver)\n          if (delivered) {\n            resolve(flushed)\n          } else {\n            resolve(flushed)\n          }\n        }\n      }\n\n      this.on('flush', onDeliver)\n    })\n  }\n\n  async dispatchSingle(ctx: Ctx): Promise<Ctx> {\n    ctx.log('debug', 'Dispatching')\n    ctx.stats.increment('message_dispatched')\n\n    this.queue.updateAttempts(ctx)\n    ctx.attempts = 1\n\n    return this.deliver(ctx).catch((err) => {\n      const accepted = this.enqueuRetry(err, ctx)\n      if (!accepted) {\n        ctx.setFailedDelivery({ reason: err })\n        return ctx\n      }\n\n      return this.subscribeToDelivery(ctx)\n    })\n  }\n\n  isEmpty(): boolean {\n    return this.queue.length === 0\n  }\n\n  private scheduleFlush(timeout = 500): void {\n    if (this.flushing) {\n      return\n    }\n\n    this.flushing = true\n\n    setTimeout(() => {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.flush().then(() => {\n        setTimeout(() => {\n          this.flushing = false\n\n          if (this.queue.length) {\n            this.scheduleFlush(0)\n          }\n        }, 0)\n      })\n    }, timeout)\n  }\n\n  private async deliver(ctx: Ctx): Promise<Ctx> {\n    await this.criticalTasks.done()\n\n    const start = Date.now()\n    try {\n      ctx = await this.flushOne(ctx)\n      const done = Date.now() - start\n      this.emit('delivery_success', ctx)\n      ctx.stats.gauge('delivered', done)\n      ctx.log('debug', 'Delivered', ctx.event)\n      return ctx\n    } catch (err: any) {\n      const error = err as Ctx | Error | ContextCancelation\n      ctx.log('error', 'Failed to deliver', error)\n      this.emit('delivery_failure', ctx, error)\n      ctx.stats.increment('delivery_failed')\n      throw err\n    }\n  }\n\n  private enqueuRetry(err: Error, ctx: Ctx): boolean {\n    const retriable = !(err instanceof ContextCancelation) || err.retry\n    if (!retriable) {\n      return false\n    }\n\n    return this.queue.pushWithBackoff(ctx)\n  }\n\n  async flush(): Promise<Ctx[]> {\n    if (this.queue.length === 0) {\n      return []\n    }\n\n    let ctx = this.queue.pop()\n    if (!ctx) {\n      return []\n    }\n\n    ctx.attempts = this.queue.getAttempts(ctx)\n\n    try {\n      ctx = await this.deliver(ctx)\n      this.emit('flush', ctx, true)\n    } catch (err: any) {\n      const accepted = this.enqueuRetry(err, ctx)\n\n      if (!accepted) {\n        ctx.setFailedDelivery({ reason: err })\n        this.emit('flush', ctx, false)\n      }\n\n      return []\n    }\n\n    return [ctx]\n  }\n\n  private isReady(): boolean {\n    // return this.plugins.every((p) => p.isLoaded())\n    // should we wait for every plugin to load?\n    return true\n  }\n\n  private availableExtensions(denyList: Integrations) {\n    const available = this.plugins.filter((p) => {\n      // Only filter out destination plugins or the Segment.io plugin\n      if (p.type !== 'destination' && p.name !== 'Segment.io') {\n        return true\n      }\n\n      let alternativeNameMatch: boolean | JSONObject | undefined = undefined\n      p.alternativeNames?.forEach((name) => {\n        if (denyList[name] !== undefined) {\n          alternativeNameMatch = denyList[name]\n        }\n      })\n\n      // Explicit integration option takes precedence, `All: false` does not apply to Segment.io\n      return (\n        denyList[p.name] ??\n        alternativeNameMatch ??\n        (p.name === 'Segment.io' ? true : denyList.All) !== false\n      )\n    })\n\n    const {\n      before = [],\n      enrichment = [],\n      destination = [],\n      after = [],\n    } = groupBy(available, 'type')\n\n    return {\n      before,\n      enrichment,\n      destinations: destination,\n      after,\n    }\n  }\n\n  private async flushOne(ctx: Ctx): Promise<Ctx> {\n    if (!this.isReady()) {\n      throw new Error('Not ready')\n    }\n\n    if (ctx.attempts > 1) {\n      this.emit('delivery_retry', ctx)\n    }\n\n    const { before, enrichment } = this.availableExtensions(\n      ctx.event.integrations ?? {}\n    )\n\n    for (const beforeWare of before) {\n      const temp = await ensure(ctx, beforeWare)\n      if (temp instanceof CoreContext) {\n        ctx = temp\n      }\n\n      this.emit('message_enriched', ctx, beforeWare)\n    }\n\n    for (const enrichmentWare of enrichment) {\n      const temp = await attempt(ctx, enrichmentWare)\n      if (temp instanceof CoreContext) {\n        ctx = temp\n      }\n\n      this.emit('message_enriched', ctx, enrichmentWare)\n    }\n\n    // Enrichment and before plugins can re-arrange the deny list dynamically\n    // so we need to pluck them at the end\n    const { destinations, after } = this.availableExtensions(\n      ctx.event.integrations ?? {}\n    )\n\n    await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        const attempts = destinations.map((destination) =>\n          attempt(ctx, destination)\n        )\n        Promise.all(attempts).then(resolve).catch(reject)\n      }, 0)\n    })\n\n    ctx.stats.increment('message_delivered')\n\n    this.emit('message_delivered', ctx)\n\n    const afterCalls = after.map((after) => attempt(ctx, after))\n    await Promise.all(afterCalls)\n\n    return ctx\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}