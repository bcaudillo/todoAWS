{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nexport * from './interfaces';\nimport { dset } from 'dset';\nimport { pickBy } from '../utils/pick';\nimport { validateEvent } from '../validation/assertions';\n/**\n * This is currently only used by node.js, but the original idea was to have something that could be shared between browser and node.\n * Unfortunately, there are some differences in the way the two environments handle events, so this is not currently shared.\n */\nvar EventFactory = /** @class */function () {\n  function EventFactory(settings) {\n    this.user = settings.user;\n    this.createMessageId = settings.createMessageId;\n  }\n  EventFactory.prototype.track = function (event, properties, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      event: event,\n      type: 'track',\n      properties: properties !== null && properties !== void 0 ? properties : {},\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    }));\n  };\n  EventFactory.prototype.page = function (category, page, properties, options, globalIntegrations) {\n    var _a;\n    var event = {\n      type: 'page',\n      properties: __assign({}, properties),\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n    if (category !== null) {\n      event.category = category;\n      event.properties = (_a = event.properties) !== null && _a !== void 0 ? _a : {};\n      event.properties.category = category;\n    }\n    if (page !== null) {\n      event.name = page;\n    }\n    return this.normalize(__assign(__assign({}, this.baseEvent()), event));\n  };\n  EventFactory.prototype.screen = function (category, screen, properties, options, globalIntegrations) {\n    var event = {\n      type: 'screen',\n      properties: __assign({}, properties),\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n    if (category !== null) {\n      event.category = category;\n    }\n    if (screen !== null) {\n      event.name = screen;\n    }\n    return this.normalize(__assign(__assign({}, this.baseEvent()), event));\n  };\n  EventFactory.prototype.identify = function (userId, traits, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      type: 'identify',\n      userId: userId,\n      traits: traits !== null && traits !== void 0 ? traits : {},\n      options: __assign({}, options),\n      integrations: globalIntegrations\n    }));\n  };\n  EventFactory.prototype.group = function (groupId, traits, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      type: 'group',\n      traits: traits !== null && traits !== void 0 ? traits : {},\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations),\n      //\n      groupId: groupId\n    }));\n  };\n  EventFactory.prototype.alias = function (to, from,\n  // TODO: can we make this undefined?\n  options, globalIntegrations) {\n    var base = {\n      userId: to,\n      type: 'alias',\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n    if (from !== null) {\n      base.previousId = from;\n    }\n    if (to === undefined) {\n      return this.normalize(__assign(__assign({}, base), this.baseEvent()));\n    }\n    return this.normalize(__assign(__assign({}, this.baseEvent()), base));\n  };\n  EventFactory.prototype.baseEvent = function () {\n    var base = {\n      integrations: {},\n      options: {}\n    };\n    if (!this.user) return base;\n    var user = this.user;\n    if (user.id()) {\n      base.userId = user.id();\n    }\n    if (user.anonymousId()) {\n      base.anonymousId = user.anonymousId();\n    }\n    return base;\n  };\n  /**\n   * Builds the context part of an event based on \"foreign\" keys that\n   * are provided in the `Options` parameter for an Event\n   */\n  EventFactory.prototype.context = function (options) {\n    var _a;\n    /**\n     * If the event options are known keys from this list, we move them to the top level of the event.\n     * Any other options are moved to context.\n     */\n    var eventOverrideKeys = ['userId', 'anonymousId', 'timestamp', 'messageId'];\n    delete options['integrations'];\n    var providedOptionsKeys = Object.keys(options);\n    var context = (_a = options.context) !== null && _a !== void 0 ? _a : {};\n    var eventOverrides = {};\n    providedOptionsKeys.forEach(function (key) {\n      if (key === 'context') {\n        return;\n      }\n      if (eventOverrideKeys.includes(key)) {\n        dset(eventOverrides, key, options[key]);\n      } else {\n        dset(context, key, options[key]);\n      }\n    });\n    return [context, eventOverrides];\n  };\n  EventFactory.prototype.normalize = function (event) {\n    var _a, _b;\n    var integrationBooleans = Object.keys((_a = event.integrations) !== null && _a !== void 0 ? _a : {}).reduce(function (integrationNames, name) {\n      var _a;\n      var _b;\n      return __assign(__assign({}, integrationNames), (_a = {}, _a[name] = Boolean((_b = event.integrations) === null || _b === void 0 ? void 0 : _b[name]), _a));\n    }, {});\n    // filter out any undefined options\n    event.options = pickBy(event.options || {}, function (_, value) {\n      return value !== undefined;\n    });\n    // This is pretty trippy, but here's what's going on:\n    // - a) We don't pass initial integration options as part of the event, only if they're true or false\n    // - b) We do accept per integration overrides (like integrations.Amplitude.sessionId) at the event level\n    // Hence the need to convert base integration options to booleans, but maintain per event integration overrides\n    var allIntegrations = __assign(__assign({}, integrationBooleans), (_b = event.options) === null || _b === void 0 ? void 0 : _b.integrations);\n    var _c = event.options ? this.context(event.options) : [],\n      context = _c[0],\n      overrides = _c[1];\n    var options = event.options,\n      rest = __rest(event, [\"options\"]);\n    var body = __assign(__assign(__assign({\n      timestamp: new Date()\n    }, rest), {\n      integrations: allIntegrations,\n      context: context\n    }), overrides);\n    var evt = __assign(__assign({}, body), {\n      messageId: options.messageId || this.createMessageId()\n    });\n    validateEvent(evt);\n    return evt;\n  };\n  return EventFactory;\n}();\nexport { EventFactory };","map":{"version":3,"names":["dset","pickBy","validateEvent","EventFactory","settings","user","createMessageId","prototype","track","event","properties","options","globalIntegrations","normalize","__assign","baseEvent","type","integrations","page","category","_a","name","screen","identify","userId","traits","group","groupId","alias","to","from","base","previousId","undefined","id","anonymousId","context","eventOverrideKeys","providedOptionsKeys","Object","keys","eventOverrides","forEach","key","includes","integrationBooleans","reduce","integrationNames","Boolean","_b","_","value","allIntegrations","_c","overrides","rest","__rest","body","timestamp","Date","evt","messageId"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/analytics-core/src/events/index.ts"],"sourcesContent":["export * from './interfaces'\nimport { dset } from 'dset'\nimport { ID, User } from '../user'\nimport {\n  Integrations,\n  EventProperties,\n  CoreSegmentEvent,\n  CoreOptions,\n  CoreExtraContext,\n  UserTraits,\n  GroupTraits,\n} from './interfaces'\nimport { pickBy } from '../utils/pick'\nimport { validateEvent } from '../validation/assertions'\nimport type { RemoveIndexSignature } from '../utils/ts-helpers'\n\ninterface EventFactorySettings {\n  createMessageId: () => string\n  user?: User\n}\n\n/**\n * This is currently only used by node.js, but the original idea was to have something that could be shared between browser and node.\n * Unfortunately, there are some differences in the way the two environments handle events, so this is not currently shared.\n */\nexport class EventFactory {\n  createMessageId: EventFactorySettings['createMessageId']\n  user?: User\n\n  constructor(settings: EventFactorySettings) {\n    this.user = settings.user\n    this.createMessageId = settings.createMessageId\n  }\n\n  track(\n    event: string,\n    properties?: EventProperties,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ) {\n    return this.normalize({\n      ...this.baseEvent(),\n      event,\n      type: 'track',\n      properties: properties ?? {}, // TODO: why is this not a shallow copy like everywhere else?\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    })\n  }\n\n  page(\n    category: string | null,\n    page: string | null,\n    properties?: EventProperties,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    const event: CoreSegmentEvent = {\n      type: 'page',\n      properties: { ...properties },\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (category !== null) {\n      event.category = category\n      event.properties = event.properties ?? {}\n      event.properties.category = category\n    }\n\n    if (page !== null) {\n      event.name = page\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...event,\n    })\n  }\n\n  screen(\n    category: string | null,\n    screen: string | null,\n    properties?: EventProperties,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    const event: CoreSegmentEvent = {\n      type: 'screen',\n      properties: { ...properties },\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (category !== null) {\n      event.category = category\n    }\n\n    if (screen !== null) {\n      event.name = screen\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...event,\n    })\n  }\n\n  identify(\n    userId: ID,\n    traits?: UserTraits,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    return this.normalize({\n      ...this.baseEvent(),\n      type: 'identify',\n      userId,\n      traits: traits ?? {},\n      options: { ...options },\n      integrations: globalIntegrations,\n    })\n  }\n\n  group(\n    groupId: ID,\n    traits?: GroupTraits,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    return this.normalize({\n      ...this.baseEvent(),\n      type: 'group',\n      traits: traits ?? {},\n      options: { ...options }, // this spreading is intentional\n      integrations: { ...globalIntegrations }, //\n      groupId,\n    })\n  }\n\n  alias(\n    to: string,\n    from: string | null, // TODO: can we make this undefined?\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    const base: CoreSegmentEvent = {\n      userId: to,\n      type: 'alias',\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (from !== null) {\n      base.previousId = from\n    }\n\n    if (to === undefined) {\n      return this.normalize({\n        ...base,\n        ...this.baseEvent(),\n      })\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...base,\n    })\n  }\n\n  private baseEvent(): Partial<CoreSegmentEvent> {\n    const base: Partial<CoreSegmentEvent> = {\n      integrations: {},\n      options: {},\n    }\n\n    if (!this.user) return base\n\n    const user = this.user\n\n    if (user.id()) {\n      base.userId = user.id()\n    }\n\n    if (user.anonymousId()) {\n      base.anonymousId = user.anonymousId()\n    }\n\n    return base\n  }\n\n  /**\n   * Builds the context part of an event based on \"foreign\" keys that\n   * are provided in the `Options` parameter for an Event\n   */\n  private context(\n    options: CoreOptions\n  ): [CoreExtraContext, Partial<CoreSegmentEvent>] {\n    type CoreOptionKeys = keyof RemoveIndexSignature<CoreOptions>\n    /**\n     * If the event options are known keys from this list, we move them to the top level of the event.\n     * Any other options are moved to context.\n     */\n    const eventOverrideKeys: CoreOptionKeys[] = [\n      'userId',\n      'anonymousId',\n      'timestamp',\n      'messageId',\n    ]\n\n    delete options['integrations']\n    const providedOptionsKeys = Object.keys(options) as Exclude<\n      CoreOptionKeys,\n      'integrations'\n    >[]\n\n    const context = options.context ?? {}\n    const eventOverrides = {}\n\n    providedOptionsKeys.forEach((key) => {\n      if (key === 'context') {\n        return\n      }\n\n      if (eventOverrideKeys.includes(key)) {\n        dset(eventOverrides, key, options[key])\n      } else {\n        dset(context, key, options[key])\n      }\n    })\n\n    return [context, eventOverrides]\n  }\n\n  public normalize(event: CoreSegmentEvent): CoreSegmentEvent {\n    const integrationBooleans = Object.keys(event.integrations ?? {}).reduce(\n      (integrationNames, name) => {\n        return {\n          ...integrationNames,\n          [name]: Boolean(event.integrations?.[name]),\n        }\n      },\n      {} as Record<string, boolean>\n    )\n\n    // filter out any undefined options\n    event.options = pickBy(event.options || {}, (_, value) => {\n      return value !== undefined\n    })\n\n    // This is pretty trippy, but here's what's going on:\n    // - a) We don't pass initial integration options as part of the event, only if they're true or false\n    // - b) We do accept per integration overrides (like integrations.Amplitude.sessionId) at the event level\n    // Hence the need to convert base integration options to booleans, but maintain per event integration overrides\n    const allIntegrations = {\n      // Base config integrations object as booleans\n      ...integrationBooleans,\n\n      // Per event overrides, for things like amplitude sessionId, for example\n      ...event.options?.integrations,\n    }\n\n    const [context, overrides] = event.options\n      ? this.context(event.options)\n      : []\n\n    const { options, ...rest } = event\n\n    const body = {\n      timestamp: new Date(),\n      ...rest,\n      integrations: allIntegrations,\n      context,\n      ...overrides,\n    }\n\n    const evt: CoreSegmentEvent = {\n      ...body,\n      messageId: options.messageId || this.createMessageId(),\n    }\n\n    validateEvent(evt)\n    return evt\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}