{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { invokeCallback } from '../callback';\n/* The amount of time in ms to wait before invoking the callback. */\nexport var getDelay = function (startTimeInEpochMS, timeoutInMS) {\n  var elapsedTime = Date.now() - startTimeInEpochMS;\n  // increasing the timeout increases the delay by almost the same amount -- this is weird legacy behavior.\n  return Math.max((timeoutInMS !== null && timeoutInMS !== void 0 ? timeoutInMS : 300) - elapsedTime, 0);\n};\n/**\n * Push an event into the dispatch queue and invoke any callbacks.\n *\n * @param event - Segment event to enqueue.\n * @param queue - Queue to dispatch against.\n * @param emitter - This is typically an instance of \"Analytics\" -- used for metrics / progress information.\n * @param options\n */\nexport function dispatch(ctx, queue, emitter, options) {\n  return __awaiter(this, void 0, void 0, function () {\n    var startTime, dispatched;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          emitter.emit('dispatch_start', ctx);\n          startTime = Date.now();\n          if (!queue.isEmpty()) return [3 /*break*/, 2];\n          return [4 /*yield*/, queue.dispatchSingle(ctx)];\n        case 1:\n          dispatched = _a.sent();\n          return [3 /*break*/, 4];\n        case 2:\n          return [4 /*yield*/, queue.dispatch(ctx)];\n        case 3:\n          dispatched = _a.sent();\n          _a.label = 4;\n        case 4:\n          if (!(options === null || options === void 0 ? void 0 : options.callback)) return [3 /*break*/, 6];\n          return [4 /*yield*/, invokeCallback(dispatched, options.callback, getDelay(startTime, options.timeout))];\n        case 5:\n          dispatched = _a.sent();\n          _a.label = 6;\n        case 6:\n          if (options === null || options === void 0 ? void 0 : options.debug) {\n            dispatched.flush();\n          }\n          return [2 /*return*/, dispatched];\n      }\n    });\n  });\n}","map":{"version":3,"names":["invokeCallback","getDelay","startTimeInEpochMS","timeoutInMS","elapsedTime","Date","now","Math","max","dispatch","ctx","queue","emitter","options","emit","startTime","isEmpty","dispatchSingle","dispatched","_a","sent","callback","timeout","debug","flush"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/analytics-core/src/analytics/dispatch.ts"],"sourcesContent":["import { CoreContext } from '../context'\nimport { Callback } from '../events/interfaces'\nimport { CoreEventQueue } from '../queue/event-queue'\nimport { invokeCallback } from '../callback'\nimport { Emitter } from '@segment/analytics-generic-utils'\n\nexport type DispatchOptions<Ctx extends CoreContext = CoreContext> = {\n  timeout?: number\n  debug?: boolean\n  callback?: Callback<Ctx>\n}\n\n/* The amount of time in ms to wait before invoking the callback. */\nexport const getDelay = (startTimeInEpochMS: number, timeoutInMS?: number) => {\n  const elapsedTime = Date.now() - startTimeInEpochMS\n  // increasing the timeout increases the delay by almost the same amount -- this is weird legacy behavior.\n  return Math.max((timeoutInMS ?? 300) - elapsedTime, 0)\n}\n/**\n * Push an event into the dispatch queue and invoke any callbacks.\n *\n * @param event - Segment event to enqueue.\n * @param queue - Queue to dispatch against.\n * @param emitter - This is typically an instance of \"Analytics\" -- used for metrics / progress information.\n * @param options\n */\nexport async function dispatch<\n  Ctx extends CoreContext,\n  EQ extends CoreEventQueue<Ctx>\n>(\n  ctx: Ctx,\n  queue: EQ,\n  emitter: Emitter,\n  options?: DispatchOptions<Ctx>\n): Promise<Ctx> {\n  emitter.emit('dispatch_start', ctx)\n\n  const startTime = Date.now()\n  let dispatched: Ctx\n  if (queue.isEmpty()) {\n    dispatched = await queue.dispatchSingle(ctx)\n  } else {\n    dispatched = await queue.dispatch(ctx)\n  }\n\n  if (options?.callback) {\n    dispatched = await invokeCallback(\n      dispatched,\n      options.callback,\n      getDelay(startTime, options.timeout)\n    )\n  }\n  if (options?.debug) {\n    dispatched.flush()\n  }\n\n  return dispatched\n}\n"],"mappings":";AAGA,SAASA,cAAc,QAAQ,aAAa;AAS5C;AACA,OAAO,IAAMC,QAAQ,GAAG,SAAAA,CAACC,kBAA0B,EAAEC,WAAoB;EACvE,IAAMC,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE,GAAGJ,kBAAkB;EACnD;EACA,OAAOK,IAAI,CAACC,GAAG,CAAC,CAACL,WAAW,aAAXA,WAAW,cAAXA,WAAW,GAAI,GAAG,IAAIC,WAAW,EAAE,CAAC,CAAC;AACxD,CAAC;AACD;;;;;;;;AAQA,OAAM,SAAgBK,QAAQA,CAI5BC,GAAQ,EACRC,KAAS,EACTC,OAAgB,EAChBC,OAA8B;;;;;;UAE9BD,OAAO,CAACE,IAAI,CAAC,gBAAgB,EAAEJ,GAAG,CAAC;UAE7BK,SAAS,GAAGV,IAAI,CAACC,GAAG,EAAE;eAExBK,KAAK,CAACK,OAAO,EAAE,EAAf;UACW,qBAAML,KAAK,CAACM,cAAc,CAACP,GAAG,CAAC;;UAA5CQ,UAAU,GAAGC,EAAA,CAAAC,IAAA,EAA+B;;;UAE/B,qBAAMT,KAAK,CAACF,QAAQ,CAACC,GAAG,CAAC;;UAAtCQ,UAAU,GAAGC,EAAA,CAAAC,IAAA,EAAyB;;;gBAGpCP,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEQ,QAAQ,GAAjB;UACW,qBAAMrB,cAAc,CAC/BkB,UAAU,EACVL,OAAO,CAACQ,QAAQ,EAChBpB,QAAQ,CAACc,SAAS,EAAEF,OAAO,CAACS,OAAO,CAAC,CACrC;;UAJDJ,UAAU,GAAGC,EAAA,CAAAC,IAAA,EAIZ;;;UAEH,IAAIP,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEU,KAAK,EAAE;YAClBL,UAAU,CAACM,KAAK,EAAE;;UAGpB,sBAAON,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}