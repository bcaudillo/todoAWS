{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isOffline } from '../../core/connection';\nimport { Context } from '../../core/context';\nimport { attempt } from '@segment/analytics-core';\nimport { pWhile } from '../../lib/p-while';\nfunction flushQueue(xt, queue) {\n  return __awaiter(this, void 0, void 0, function () {\n    var failedQueue;\n    var _this = this;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          failedQueue = [];\n          if (isOffline()) {\n            return [2 /*return*/, queue];\n          }\n          return [4 /*yield*/, pWhile(function () {\n            return queue.length > 0 && !isOffline();\n          }, function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var ctx, result, success;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    ctx = queue.pop();\n                    if (!ctx) {\n                      return [2 /*return*/];\n                    }\n                    return [4 /*yield*/, attempt(ctx, xt)];\n                  case 1:\n                    result = _a.sent();\n                    success = result instanceof Context;\n                    if (!success) {\n                      failedQueue.push(ctx);\n                    }\n                    return [2 /*return*/];\n                }\n              });\n            });\n          })\n          // re-add failed tasks\n          ];\n        case 1:\n          _a.sent();\n          // re-add failed tasks\n          failedQueue.map(function (failed) {\n            return queue.pushWithBackoff(failed);\n          });\n          return [2 /*return*/, queue];\n      }\n    });\n  });\n}\nexport function scheduleFlush(flushing, buffer, xt, scheduleFlush) {\n  var _this = this;\n  if (flushing) {\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  setTimeout(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var isFlushing, newBuffer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            isFlushing = true;\n            return [4 /*yield*/, flushQueue(xt, buffer)];\n          case 1:\n            newBuffer = _a.sent();\n            isFlushing = false;\n            if (buffer.todo > 0) {\n              scheduleFlush(isFlushing, newBuffer, xt, scheduleFlush);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, Math.random() * 5000);\n}","map":{"version":3,"names":["isOffline","Context","attempt","pWhile","flushQueue","xt","queue","failedQueue","length","__awaiter","_this","ctx","pop","result","_a","sent","success","push","map","failed","pushWithBackoff","scheduleFlush","flushing","buffer","setTimeout","isFlushing","newBuffer","todo","Math","random"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/analytics-next/src/plugins/segmentio/schedule-flush.ts"],"sourcesContent":["import { isOffline } from '../../core/connection'\nimport { Context } from '../../core/context'\nimport { Plugin } from '../../core/plugin'\nimport { attempt } from '@segment/analytics-core'\nimport { pWhile } from '../../lib/p-while'\nimport { PriorityQueue } from '../../lib/priority-queue'\n\nasync function flushQueue(\n  xt: Plugin,\n  queue: PriorityQueue<Context>\n): Promise<PriorityQueue<Context>> {\n  const failedQueue: Context[] = []\n  if (isOffline()) {\n    return queue\n  }\n\n  await pWhile(\n    () => queue.length > 0 && !isOffline(),\n    async () => {\n      const ctx = queue.pop()\n      if (!ctx) {\n        return\n      }\n\n      const result = await attempt(ctx, xt)\n      const success = result instanceof Context\n      if (!success) {\n        failedQueue.push(ctx)\n      }\n    }\n  )\n  // re-add failed tasks\n  failedQueue.map((failed) => queue.pushWithBackoff(failed))\n  return queue\n}\n\nexport function scheduleFlush(\n  flushing: boolean,\n  buffer: PriorityQueue<Context>,\n  xt: Plugin,\n  scheduleFlush: Function\n): void {\n  if (flushing) {\n    return\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  setTimeout(async () => {\n    let isFlushing = true\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const newBuffer = await flushQueue(xt, buffer)\n    isFlushing = false\n\n    if (buffer.todo > 0) {\n      scheduleFlush(isFlushing, newBuffer, xt, scheduleFlush)\n    }\n  }, Math.random() * 5000)\n}\n"],"mappings":";AAAA,SAASA,SAAS,QAAQ,uBAAuB;AACjD,SAASC,OAAO,QAAQ,oBAAoB;AAE5C,SAASC,OAAO,QAAQ,yBAAyB;AACjD,SAASC,MAAM,QAAQ,mBAAmB;AAG1C,SAAeC,UAAUA,CACvBC,EAAU,EACVC,KAA6B;;;;;;;UAEvBC,WAAW,GAAc,EAAE;UACjC,IAAIP,SAAS,EAAE,EAAE;YACf,sBAAOM,KAAK;;UAGd,qBAAMH,MAAM,CACV;YAAM,OAAAG,KAAK,CAACE,MAAM,GAAG,CAAC,IAAI,CAACR,SAAS,EAAE;UAAhC,CAAgC,EACtC;YAAA,OAAAS,SAAA,CAAAC,KAAA;;;;;oBACQC,GAAG,GAAGL,KAAK,CAACM,GAAG,EAAE;oBACvB,IAAI,CAACD,GAAG,EAAE;sBACR;;oBAGa,qBAAMT,OAAO,CAACS,GAAG,EAAEN,EAAE,CAAC;;oBAA/BQ,MAAM,GAAGC,EAAA,CAAAC,IAAA,EAAsB;oBAC/BC,OAAO,GAAGH,MAAM,YAAYZ,OAAO;oBACzC,IAAI,CAACe,OAAO,EAAE;sBACZT,WAAW,CAACU,IAAI,CAACN,GAAG,CAAC;;;;;;WAExB;UAEH;UAAA,C;;UAfAG,EAAA,CAAAC,IAAA,EAcC;UACD;UACAR,WAAW,CAACW,GAAG,CAAC,UAACC,MAAM;YAAK,OAAAb,KAAK,CAACc,eAAe,CAACD,MAAM,CAAC;UAA7B,CAA6B,CAAC;UAC1D,sBAAOb,KAAK;;;;;AAGd,OAAM,SAAUe,aAAaA,CAC3BC,QAAiB,EACjBC,MAA8B,EAC9BlB,EAAU,EACVgB,aAAuB;EAJzB,IAAAX,KAAA;EAME,IAAIY,QAAQ,EAAE;IACZ;;EAGF;EACAE,UAAU,CAAC;IAAA,OAAAf,SAAA,CAAAC,KAAA;;;;;YACLe,UAAU,GAAG,IAAI;YAEH,qBAAMrB,UAAU,CAACC,EAAE,EAAEkB,MAAM,CAAC;;YAAxCG,SAAS,GAAGZ,EAAA,CAAAC,IAAA,EAA4B;YAC9CU,UAAU,GAAG,KAAK;YAElB,IAAIF,MAAM,CAACI,IAAI,GAAG,CAAC,EAAE;cACnBN,aAAa,CAACI,UAAU,EAAEC,SAAS,EAAErB,EAAE,EAAEgB,aAAa,CAAC;;;;;;GAE1D,EAAEO,IAAI,CAACC,MAAM,EAAE,GAAG,IAAI,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}