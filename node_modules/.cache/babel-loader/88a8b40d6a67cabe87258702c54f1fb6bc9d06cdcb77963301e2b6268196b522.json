{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { loadScript } from '../../lib/load-script';\nimport { getCDN } from '../../lib/parse-cdn';\nimport { applyDestinationMiddleware } from '../middleware';\nimport { Context, ContextCancelation } from '../../core/context';\nimport { recordIntegrationMetric } from '../../core/stats/metric-helpers';\nimport { createDeferred } from '@segment/analytics-generic-utils';\nvar ActionDestination = /** @class */function () {\n  function ActionDestination(name, action) {\n    this.version = '1.0.0';\n    this.alternativeNames = [];\n    this.loadPromise = createDeferred();\n    this.middleware = [];\n    this.alias = this._createMethod('alias');\n    this.group = this._createMethod('group');\n    this.identify = this._createMethod('identify');\n    this.page = this._createMethod('page');\n    this.screen = this._createMethod('screen');\n    this.track = this._createMethod('track');\n    this.action = action;\n    this.name = name;\n    this.type = action.type;\n    this.alternativeNames.push(action.name);\n  }\n  ActionDestination.prototype.addMiddleware = function () {\n    var _a;\n    var fn = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fn[_i] = arguments[_i];\n    }\n    /** Make sure we only apply destination filters to actions of the \"destination\" type to avoid causing issues for hybrid destinations */\n    if (this.type === 'destination') {\n      (_a = this.middleware).push.apply(_a, fn);\n    }\n  };\n  ActionDestination.prototype.transform = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modifiedEvent;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, applyDestinationMiddleware(this.name, ctx.event, this.middleware)];\n          case 1:\n            modifiedEvent = _a.sent();\n            if (modifiedEvent === null) {\n              ctx.cancel(new ContextCancelation({\n                retry: false,\n                reason: 'dropped by destination middleware'\n              }));\n            }\n            return [2 /*return*/, new Context(modifiedEvent)];\n        }\n      });\n    });\n  };\n  ActionDestination.prototype._createMethod = function (methodName) {\n    var _this = this;\n    return function (ctx) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var transformedContext, error_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!this.action[methodName]) return [2 /*return*/, ctx];\n              transformedContext = ctx;\n              if (!(this.type === 'destination')) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.transform(ctx)];\n            case 1:\n              transformedContext = _a.sent();\n              _a.label = 2;\n            case 2:\n              _a.trys.push([2, 5,, 6]);\n              return [4 /*yield*/, this.ready()];\n            case 3:\n              if (!_a.sent()) {\n                throw new Error('Something prevented the destination from getting ready');\n              }\n              recordIntegrationMetric(ctx, {\n                integrationName: this.action.name,\n                methodName: methodName,\n                type: 'action'\n              });\n              return [4 /*yield*/, this.action[methodName](transformedContext)];\n            case 4:\n              _a.sent();\n              return [3 /*break*/, 6];\n            case 5:\n              error_1 = _a.sent();\n              recordIntegrationMetric(ctx, {\n                integrationName: this.action.name,\n                methodName: methodName,\n                type: 'action',\n                didError: true\n              });\n              throw error_1;\n            case 6:\n              return [2 /*return*/, ctx];\n          }\n        });\n      });\n    };\n  };\n  /* --- PASSTHROUGH METHODS --- */\n  ActionDestination.prototype.isLoaded = function () {\n    return this.action.isLoaded();\n  };\n  ActionDestination.prototype.ready = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _b.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.loadPromise.promise];\n          case 1:\n            _b.sent();\n            return [2 /*return*/, true];\n          case 2:\n            _a = _b.sent();\n            return [2 /*return*/, false];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  ActionDestination.prototype.load = function (ctx, analytics) {\n    return __awaiter(this, void 0, void 0, function () {\n      var loadP, _a, _b, error_2;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (this.loadPromise.isSettled()) {\n              return [2 /*return*/, this.loadPromise.promise];\n            }\n            _c.label = 1;\n          case 1:\n            _c.trys.push([1, 3,, 4]);\n            recordIntegrationMetric(ctx, {\n              integrationName: this.action.name,\n              methodName: 'load',\n              type: 'action'\n            });\n            loadP = this.action.load(ctx, analytics);\n            _b = (_a = this.loadPromise).resolve;\n            return [4 /*yield*/, loadP];\n          case 2:\n            _b.apply(_a, [_c.sent()]);\n            return [2 /*return*/, loadP];\n          case 3:\n            error_2 = _c.sent();\n            recordIntegrationMetric(ctx, {\n              integrationName: this.action.name,\n              methodName: 'load',\n              type: 'action',\n              didError: true\n            });\n            this.loadPromise.reject(error_2);\n            throw error_2;\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  ActionDestination.prototype.unload = function (ctx, analytics) {\n    var _a, _b;\n    return (_b = (_a = this.action).unload) === null || _b === void 0 ? void 0 : _b.call(_a, ctx, analytics);\n  };\n  return ActionDestination;\n}();\nexport { ActionDestination };\nfunction validate(pluginLike) {\n  if (!Array.isArray(pluginLike)) {\n    throw new Error('Not a valid list of plugins');\n  }\n  var required = ['load', 'isLoaded', 'name', 'version', 'type'];\n  pluginLike.forEach(function (plugin) {\n    required.forEach(function (method) {\n      var _a;\n      if (plugin[method] === undefined) {\n        throw new Error(\"Plugin: \".concat((_a = plugin.name) !== null && _a !== void 0 ? _a : 'unknown', \" missing required function \").concat(method));\n      }\n    });\n  });\n  return true;\n}\nfunction isPluginDisabled(userIntegrations, remotePlugin) {\n  var creationNameEnabled = userIntegrations[remotePlugin.creationName];\n  var currentNameEnabled = userIntegrations[remotePlugin.name];\n  // Check that the plugin isn't explicitly enabled when All: false\n  if (userIntegrations.All === false && !creationNameEnabled && !currentNameEnabled) {\n    return true;\n  }\n  // Check that the plugin isn't explicitly disabled\n  if (creationNameEnabled === false || currentNameEnabled === false) {\n    return true;\n  }\n  return false;\n}\nfunction loadPluginFactory(remotePlugin, obfuscate) {\n  return __awaiter(this, void 0, void 0, function () {\n    var defaultCdn, cdn, urlSplit, name_1, obfuscatedURL, error_3;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          defaultCdn = new RegExp('https://cdn.segment.(com|build)');\n          cdn = getCDN();\n          if (!obfuscate) return [3 /*break*/, 6];\n          urlSplit = remotePlugin.url.split('/');\n          name_1 = urlSplit[urlSplit.length - 2];\n          obfuscatedURL = remotePlugin.url.replace(name_1, btoa(name_1).replace(/=/g, ''));\n          _a.label = 1;\n        case 1:\n          _a.trys.push([1, 3,, 5]);\n          return [4 /*yield*/, loadScript(obfuscatedURL.replace(defaultCdn, cdn))];\n        case 2:\n          _a.sent();\n          return [3 /*break*/, 5];\n        case 3:\n          error_3 = _a.sent();\n          // Due to syncing concerns it is possible that the obfuscated action destination (or requested version) might not exist.\n          // We should use the unobfuscated version as a fallback.\n          return [4 /*yield*/, loadScript(remotePlugin.url.replace(defaultCdn, cdn))];\n        case 4:\n          // Due to syncing concerns it is possible that the obfuscated action destination (or requested version) might not exist.\n          // We should use the unobfuscated version as a fallback.\n          _a.sent();\n          return [3 /*break*/, 5];\n        case 5:\n          return [3 /*break*/, 8];\n        case 6:\n          return [4 /*yield*/, loadScript(remotePlugin.url.replace(defaultCdn, cdn))];\n        case 7:\n          _a.sent();\n          _a.label = 8;\n        case 8:\n          // @ts-expect-error\n          if (typeof window[remotePlugin.libraryName] === 'function') {\n            // @ts-expect-error\n            return [2 /*return*/, window[remotePlugin.libraryName]];\n          }\n          return [2 /*return*/];\n      }\n    });\n  });\n}\nexport function remoteLoader(settings, userIntegrations, mergedIntegrations, options, routingMiddleware, pluginSources) {\n  var _a, _b, _c;\n  return __awaiter(this, void 0, void 0, function () {\n    var allPlugins, routingRules, pluginPromises;\n    var _this = this;\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          allPlugins = [];\n          routingRules = (_b = (_a = settings.middlewareSettings) === null || _a === void 0 ? void 0 : _a.routingRules) !== null && _b !== void 0 ? _b : [];\n          pluginPromises = ((_c = settings.remotePlugins) !== null && _c !== void 0 ? _c : []).map(function (remotePlugin) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var pluginFactory, _a, plugin, plugins, routing_1, error_4;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    if (isPluginDisabled(userIntegrations, remotePlugin)) return [2 /*return*/];\n                    _b.label = 1;\n                  case 1:\n                    _b.trys.push([1, 6,, 7]);\n                    _a = pluginSources === null || pluginSources === void 0 ? void 0 : pluginSources.find(function (_a) {\n                      var pluginName = _a.pluginName;\n                      return pluginName === remotePlugin.name;\n                    });\n                    if (_a) return [3 /*break*/, 3];\n                    return [4 /*yield*/, loadPluginFactory(remotePlugin, options === null || options === void 0 ? void 0 : options.obfuscate)];\n                  case 2:\n                    _a = _b.sent();\n                    _b.label = 3;\n                  case 3:\n                    pluginFactory = _a;\n                    if (!pluginFactory) return [3 /*break*/, 5];\n                    return [4 /*yield*/, pluginFactory(__assign(__assign({}, remotePlugin.settings), mergedIntegrations[remotePlugin.name]))];\n                  case 4:\n                    plugin = _b.sent();\n                    plugins = Array.isArray(plugin) ? plugin : [plugin];\n                    validate(plugins);\n                    routing_1 = routingRules.filter(function (rule) {\n                      return rule.destinationName === remotePlugin.creationName;\n                    });\n                    plugins.forEach(function (plugin) {\n                      var wrapper = new ActionDestination(remotePlugin.creationName, plugin);\n                      if (routing_1.length && routingMiddleware) {\n                        wrapper.addMiddleware(routingMiddleware);\n                      }\n                      allPlugins.push(wrapper);\n                    });\n                    _b.label = 5;\n                  case 5:\n                    return [3 /*break*/, 7];\n                  case 6:\n                    error_4 = _b.sent();\n                    console.warn('Failed to load Remote Plugin', error_4);\n                    return [3 /*break*/, 7];\n                  case 7:\n                    return [2 /*return*/];\n                }\n              });\n            });\n          });\n          return [4 /*yield*/, Promise.all(pluginPromises)];\n        case 1:\n          _d.sent();\n          return [2 /*return*/, allPlugins.filter(Boolean)];\n      }\n    });\n  });\n}","map":{"version":3,"names":["loadScript","getCDN","applyDestinationMiddleware","Context","ContextCancelation","recordIntegrationMetric","createDeferred","ActionDestination","name","action","version","alternativeNames","loadPromise","middleware","alias","_createMethod","group","identify","page","screen","track","type","push","prototype","addMiddleware","fn","_i","arguments","length","_a","apply","transform","ctx","event","modifiedEvent","sent","cancel","retry","reason","methodName","_this","__awaiter","transformedContext","ready","Error","integrationName","didError","error_1","isLoaded","promise","_b","load","analytics","isSettled","loadP","resolve","_c","reject","error_2","unload","call","validate","pluginLike","Array","isArray","required","forEach","plugin","method","undefined","concat","isPluginDisabled","userIntegrations","remotePlugin","creationNameEnabled","creationName","currentNameEnabled","All","loadPluginFactory","obfuscate","defaultCdn","RegExp","cdn","urlSplit","url","split","name_1","obfuscatedURL","replace","btoa","window","libraryName","remoteLoader","settings","mergedIntegrations","options","routingMiddleware","pluginSources","allPlugins","routingRules","middlewareSettings","pluginPromises","remotePlugins","map","find","pluginName","pluginFactory","__assign","plugins","routing_1","filter","rule","destinationName","wrapper","console","warn","error_4","Promise","all","_d","Boolean"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/analytics-next/src/plugins/remote-loader/index.ts"],"sourcesContent":["import type { Integrations } from '../../core/events/interfaces'\nimport { LegacySettings } from '../../browser'\nimport { JSONObject, JSONValue } from '../../core/events'\nimport { Plugin, InternalPluginWithAddMiddleware } from '../../core/plugin'\nimport { loadScript } from '../../lib/load-script'\nimport { getCDN } from '../../lib/parse-cdn'\nimport {\n  applyDestinationMiddleware,\n  DestinationMiddlewareFunction,\n} from '../middleware'\nimport { Context, ContextCancelation } from '../../core/context'\nimport { recordIntegrationMetric } from '../../core/stats/metric-helpers'\nimport { Analytics, InitOptions } from '../../core/analytics'\nimport { createDeferred } from '@segment/analytics-generic-utils'\n\nexport interface RemotePlugin {\n  /** The name of the remote plugin */\n  name: string\n  /** The creation name of the remote plugin */\n  creationName: string\n  /** The url of the javascript file to load */\n  url: string\n  /** The UMD/global name the plugin uses. Plugins are expected to exist here with the `PluginFactory` method signature */\n  libraryName: string\n  /** The settings related to this plugin. */\n  settings: JSONObject\n}\n\nexport class ActionDestination implements InternalPluginWithAddMiddleware {\n  name: string // destination name\n  version = '1.0.0'\n  /**\n   * The lifecycle name of the wrapped plugin.\n   * This does not need to be 'destination', and can be 'enrichment', etc.\n   */\n  type: Plugin['type']\n\n  alternativeNames: string[] = []\n\n  private loadPromise = createDeferred<unknown>()\n\n  middleware: DestinationMiddlewareFunction[] = []\n\n  action: Plugin\n\n  constructor(name: string, action: Plugin) {\n    this.action = action\n    this.name = name\n    this.type = action.type\n    this.alternativeNames.push(action.name)\n  }\n\n  addMiddleware(...fn: DestinationMiddlewareFunction[]): void {\n    /** Make sure we only apply destination filters to actions of the \"destination\" type to avoid causing issues for hybrid destinations */\n    if (this.type === 'destination') {\n      this.middleware.push(...fn)\n    }\n  }\n\n  private async transform(ctx: Context): Promise<Context> {\n    const modifiedEvent = await applyDestinationMiddleware(\n      this.name,\n      ctx.event,\n      this.middleware\n    )\n\n    if (modifiedEvent === null) {\n      ctx.cancel(\n        new ContextCancelation({\n          retry: false,\n          reason: 'dropped by destination middleware',\n        })\n      )\n    }\n\n    return new Context(modifiedEvent!)\n  }\n\n  private _createMethod(\n    methodName: 'track' | 'page' | 'identify' | 'alias' | 'group' | 'screen'\n  ) {\n    return async (ctx: Context): Promise<Context> => {\n      if (!this.action[methodName]) return ctx\n\n      let transformedContext: Context = ctx\n      // Transformations only allowed for destination plugins. Other plugin types support mutating events.\n      if (this.type === 'destination') {\n        transformedContext = await this.transform(ctx)\n      }\n\n      try {\n        if (!(await this.ready())) {\n          throw new Error(\n            'Something prevented the destination from getting ready'\n          )\n        }\n\n        recordIntegrationMetric(ctx, {\n          integrationName: this.action.name,\n          methodName,\n          type: 'action',\n        })\n\n        await this.action[methodName]!(transformedContext)\n      } catch (error) {\n        recordIntegrationMetric(ctx, {\n          integrationName: this.action.name,\n          methodName,\n          type: 'action',\n          didError: true,\n        })\n        throw error\n      }\n\n      return ctx\n    }\n  }\n\n  alias = this._createMethod('alias')\n  group = this._createMethod('group')\n  identify = this._createMethod('identify')\n  page = this._createMethod('page')\n  screen = this._createMethod('screen')\n  track = this._createMethod('track')\n\n  /* --- PASSTHROUGH METHODS --- */\n  isLoaded(): boolean {\n    return this.action.isLoaded()\n  }\n\n  async ready(): Promise<boolean> {\n    try {\n      await this.loadPromise.promise\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async load(ctx: Context, analytics: Analytics): Promise<unknown> {\n    if (this.loadPromise.isSettled()) {\n      return this.loadPromise.promise\n    }\n\n    try {\n      recordIntegrationMetric(ctx, {\n        integrationName: this.action.name,\n        methodName: 'load',\n        type: 'action',\n      })\n\n      const loadP = this.action.load(ctx, analytics)\n\n      this.loadPromise.resolve(await loadP)\n      return loadP\n    } catch (error) {\n      recordIntegrationMetric(ctx, {\n        integrationName: this.action.name,\n        methodName: 'load',\n        type: 'action',\n        didError: true,\n      })\n\n      this.loadPromise.reject(error)\n      throw error\n    }\n  }\n\n  unload(ctx: Context, analytics: Analytics): Promise<unknown> | unknown {\n    return this.action.unload?.(ctx, analytics)\n  }\n}\n\nexport type PluginFactory = {\n  (settings: JSONValue): Plugin | Plugin[] | Promise<Plugin | Plugin[]>\n  pluginName: string\n}\n\nfunction validate(pluginLike: unknown): pluginLike is Plugin[] {\n  if (!Array.isArray(pluginLike)) {\n    throw new Error('Not a valid list of plugins')\n  }\n\n  const required = ['load', 'isLoaded', 'name', 'version', 'type']\n  pluginLike.forEach((plugin) => {\n    required.forEach((method) => {\n      if (plugin[method] === undefined) {\n        throw new Error(\n          `Plugin: ${\n            plugin.name ?? 'unknown'\n          } missing required function ${method}`\n        )\n      }\n    })\n  })\n\n  return true\n}\n\nfunction isPluginDisabled(\n  userIntegrations: Integrations,\n  remotePlugin: RemotePlugin\n) {\n  const creationNameEnabled = userIntegrations[remotePlugin.creationName]\n  const currentNameEnabled = userIntegrations[remotePlugin.name]\n\n  // Check that the plugin isn't explicitly enabled when All: false\n  if (\n    userIntegrations.All === false &&\n    !creationNameEnabled &&\n    !currentNameEnabled\n  ) {\n    return true\n  }\n\n  // Check that the plugin isn't explicitly disabled\n  if (creationNameEnabled === false || currentNameEnabled === false) {\n    return true\n  }\n\n  return false\n}\n\nasync function loadPluginFactory(\n  remotePlugin: RemotePlugin,\n  obfuscate?: boolean\n): Promise<void | PluginFactory> {\n  const defaultCdn = new RegExp('https://cdn.segment.(com|build)')\n  const cdn = getCDN()\n\n  if (obfuscate) {\n    const urlSplit = remotePlugin.url.split('/')\n    const name = urlSplit[urlSplit.length - 2]\n    const obfuscatedURL = remotePlugin.url.replace(\n      name,\n      btoa(name).replace(/=/g, '')\n    )\n    try {\n      await loadScript(obfuscatedURL.replace(defaultCdn, cdn))\n    } catch (error) {\n      // Due to syncing concerns it is possible that the obfuscated action destination (or requested version) might not exist.\n      // We should use the unobfuscated version as a fallback.\n      await loadScript(remotePlugin.url.replace(defaultCdn, cdn))\n    }\n  } else {\n    await loadScript(remotePlugin.url.replace(defaultCdn, cdn))\n  }\n\n  // @ts-expect-error\n  if (typeof window[remotePlugin.libraryName] === 'function') {\n    // @ts-expect-error\n    return window[remotePlugin.libraryName] as PluginFactory\n  }\n}\n\nexport async function remoteLoader(\n  settings: LegacySettings,\n  userIntegrations: Integrations,\n  mergedIntegrations: Record<string, JSONObject>,\n  options?: InitOptions,\n  routingMiddleware?: DestinationMiddlewareFunction,\n  pluginSources?: PluginFactory[]\n): Promise<Plugin[]> {\n  const allPlugins: Plugin[] = []\n\n  const routingRules = settings.middlewareSettings?.routingRules ?? []\n\n  const pluginPromises = (settings.remotePlugins ?? []).map(\n    async (remotePlugin) => {\n      if (isPluginDisabled(userIntegrations, remotePlugin)) return\n\n      try {\n        const pluginFactory =\n          pluginSources?.find(\n            ({ pluginName }) => pluginName === remotePlugin.name\n          ) || (await loadPluginFactory(remotePlugin, options?.obfuscate))\n\n        if (pluginFactory) {\n          const plugin = await pluginFactory({\n            ...remotePlugin.settings,\n            ...mergedIntegrations[remotePlugin.name],\n          })\n          const plugins = Array.isArray(plugin) ? plugin : [plugin]\n\n          validate(plugins)\n\n          const routing = routingRules.filter(\n            (rule) => rule.destinationName === remotePlugin.creationName\n          )\n\n          plugins.forEach((plugin) => {\n            const wrapper = new ActionDestination(\n              remotePlugin.creationName,\n              plugin\n            )\n\n            if (routing.length && routingMiddleware) {\n              wrapper.addMiddleware(routingMiddleware)\n            }\n\n            allPlugins.push(wrapper)\n          })\n        }\n      } catch (error) {\n        console.warn('Failed to load Remote Plugin', error)\n      }\n    }\n  )\n\n  await Promise.all(pluginPromises)\n  return allPlugins.filter(Boolean)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}