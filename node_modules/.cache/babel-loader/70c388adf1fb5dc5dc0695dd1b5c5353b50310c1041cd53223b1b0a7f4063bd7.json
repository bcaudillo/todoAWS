{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Page = void 0;\nvar inherits_1 = __importDefault(require(\"inherits\"));\nvar facade_1 = require(\"./facade\");\nvar track_1 = require(\"./track\");\nvar is_email_1 = __importDefault(require(\"./is-email\"));\nfunction Page(dictionary, opts) {\n  facade_1.Facade.call(this, dictionary, opts);\n}\nexports.Page = Page;\ninherits_1.default(Page, facade_1.Facade);\nvar p = Page.prototype;\np.action = function () {\n  return \"page\";\n};\np.type = p.action;\np.category = facade_1.Facade.field(\"category\");\np.name = facade_1.Facade.field(\"name\");\np.title = facade_1.Facade.proxy(\"properties.title\");\np.path = facade_1.Facade.proxy(\"properties.path\");\np.url = facade_1.Facade.proxy(\"properties.url\");\np.referrer = function () {\n  return this.proxy(\"context.referrer.url\") || this.proxy(\"context.page.referrer\") || this.proxy(\"properties.referrer\");\n};\np.properties = function (aliases) {\n  var props = this.field(\"properties\") || {};\n  var category = this.category();\n  var name = this.name();\n  aliases = aliases || {};\n  if (category) props.category = category;\n  if (name) props.name = name;\n  for (var alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      var value = this[alias] == null ? this.proxy(\"properties.\" + alias) : this[alias]();\n      if (value == null) continue;\n      props[aliases[alias]] = value;\n      if (alias !== aliases[alias]) delete props[alias];\n    }\n  }\n  return props;\n};\np.email = function () {\n  var email = this.proxy(\"context.traits.email\") || this.proxy(\"properties.email\");\n  if (email) return email;\n  var userId = this.userId();\n  if (is_email_1.default(userId)) return userId;\n};\np.fullName = function () {\n  var category = this.category();\n  var name = this.name();\n  return name && category ? category + \" \" + name : name;\n};\np.event = function (name) {\n  return name ? \"Viewed \" + name + \" Page\" : \"Loaded a Page\";\n};\np.track = function (name) {\n  var json = this.json();\n  json.event = this.event(name);\n  json.timestamp = this.timestamp();\n  json.properties = this.properties();\n  return new track_1.Track(json, this.opts);\n};","map":{"version":3,"names":["inherits_1","__importDefault","require","facade_1","track_1","is_email_1","Page","dictionary","opts","Facade","call","exports","default","p","prototype","action","type","category","field","name","title","proxy","path","url","referrer","properties","aliases","props","alias","Object","hasOwnProperty","value","email","userId","fullName","event","track","json","timestamp","Track"],"sources":["/Users/bcaudillo/Desktop/Projects/todo/node_modules/@segment/facade/lib/page.js"],"sourcesContent":["\"use strict\";\n\nimport inherit from \"inherits\";\nimport { Facade } from \"./facade\";\nimport { Track } from \"./track\";\nimport isEmail from \"./is-email\";\n\n/**\n * Initialize a new `Page` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.category] - The page category.\n * @param {string} [dictionary.name] - The page name.\n * @param {string} [dictionary.properties] - The page properties.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Page(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Page, Facade);\n\nconst p = Page.prototype;\n\n/**\n * Return the type of facade this is. This will always return `\"page\"`.\n *\n * @return {string}\n */\np.action = function () {\n  return \"page\";\n};\n\n/**\n * An alias for {@link Page#action}.\n *\n * @function\n * @return {string}\n */\np.type = p.action;\n\n/**\n * Get the page category from `category`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.category = Facade.field(\"category\");\n\n/**\n * Get the page name from `name`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.name = Facade.field(\"name\");\n\n/**\n * Get the page title from `properties.title`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.title = Facade.proxy(\"properties.title\");\n\n/**\n * Get the page path from `properties.path`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.path = Facade.proxy(\"properties.path\");\n\n/**\n * Get the page URL from `properties.url`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.url = Facade.proxy(\"properties.url\");\n\n/**\n * Get the HTTP referrer from `context.referrer.url`, `context.page.referrer`,\n * or `properties.referrer`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.referrer = function () {\n  return (\n    this.proxy(\"context.referrer.url\") ||\n    this.proxy(\"context.page.referrer\") ||\n    this.proxy(\"properties.referrer\")\n  );\n};\n\n/**\n * Get the page's properties. This is identical to how {@link Facade#traits}\n * works, except it looks at `properties.*` instead of `options.traits.*`.\n *\n * Properties are gotten from `properties`, augmented with the page's `name`\n * and `category`.\n *\n * The parameter `aliases` is meant to transform keys in `properties` into new\n * keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx` in\n * the traits, and move it to `yyy`. If `xxx` is a method of this facade, it'll\n * be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { properties: { foo: \"bar\" }, anonymousId: \"xxx\" }\n * let page = new Page(obj)\n *\n * page.traits() // { \"foo\": \"bar\" }\n * page.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * page.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\np.properties = function (aliases) {\n  let props = this.field(\"properties\") || {};\n  let category = this.category();\n  let name = this.name();\n  aliases = aliases || {};\n\n  if (category) props.category = category;\n  if (name) props.name = name;\n\n  for (const alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      const value = this[alias] == null\n        ? this.proxy(\"properties.\" + alias)\n        : this[alias]();\n      if (value == null) continue;\n      props[aliases[alias]] = value;\n      if (alias !== aliases[alias]) delete props[alias];\n    }\n  }\n\n  return props;\n};\n\n/**\n * Get the user's email from `context.traits.email` or `properties.email`,\n * falling back to `userId` if it's a valid email.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.email = function () {\n  let email =\n    this.proxy(\"context.traits.email\") || this.proxy(\"properties.email\");\n  if (email) return email;\n\n  let userId = this.userId();\n  if (isEmail(userId)) return userId;\n};\n\n/**\n * Get the page fullName. This is `$category $name` if both are present, and\n * just `name` otherwiser.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.fullName = function () {\n  let category = this.category();\n  let name = this.name();\n  return name && category ? category + \" \" + name : name;\n};\n\n/**\n * Get an event name from this page call. If `name` is present, this will be\n * `Viewed $name Page`; otherwise, it will be `Loaded a Page`.\n *\n * @param {string} name - The name of this page.\n * @return {string}\n */\np.event = function (name) {\n  return name ? \"Viewed \" + name + \" Page\" : \"Loaded a Page\";\n};\n\n/**\n * Convert this Page to a {@link Track} facade. The inputted `name` will be\n * converted to the Track's event name via {@link Page#event}.\n *\n * @param {string} name\n * @return {Track}\n */\np.track = function (name) {\n  let json = this.json();\n  json.event = this.event(name);\n  json.timestamp = this.timestamp();\n  json.properties = this.properties();\n  return new Track(json, this.opts);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}